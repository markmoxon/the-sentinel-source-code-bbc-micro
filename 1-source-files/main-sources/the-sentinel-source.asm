\ ******************************************************************************
\
\ THE SENTINEL SOURCE
\
\ The Sentinel was written by Geoff Crammond and is copyright Firebird 1985
\
\ The code on this site has been reconstructed from a disassembly of the
\ original game binaries
\
\ The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
\ in the documentation are entirely my fault
\
\ The terminology and notations used in this commentary are explained at
\ https://sentinel.bbcelite.com/terminology
\
\ The deep dive articles referred to in this commentary can be found at
\ https://sentinel.bbcelite.com/deep_dives
\
\ ------------------------------------------------------------------------------
\
\ This source file contains the main game code for The Sentinel on the BBC
\ Micro.
\
\ ------------------------------------------------------------------------------
\
\ This source file produces the following binary file:
\
\   * TheSentinel.bin
\
\ ******************************************************************************

 INCLUDE "1-source-files/main-sources/the-sentinel-build-options.asm"

 _PIAS                  = (_VARIANT = 1)

\ ******************************************************************************
\
\ Configuration variables
\
\ ******************************************************************************

 CODE% = &0400          \ The address of the main game code

 LOAD% = &1900          \ The load address of the main code binary

 IRQ1V = &0204          \ The IRQ1V vector that we intercept to implement the
                        \ interrupt handler

 BRKIV = &0287          \ The Break Intercept code (which is a JMP instruction
                        \ to the Break Intercept handler)

 BRKI = &0380           \ The CFS workspace, which we can use for the Break
                        \ Intercept handler

 SHEILA = &FE00         \ Memory-mapped space for accessing internal hardware,
                        \ such as the video ULA, 6845 CRTC and 6522 VIAs (also
                        \ known as SHEILA)

 OSRDCH = &FFE0         \ The address for the OSRDCH routine

 OSWRCH = &FFEE         \ The address for the OSWRCH routine

 OSBYTE = &FFF4         \ The address for the OSBYTE routine

 OSWORD = &FFF1         \ The address for the OSWORD routine

\ ******************************************************************************
\
\       Name: Zero page
\       Type: Workspace
\    Address: &0000 to &008F
\   Category: Workspaces
\    Summary: Mainly temporary variables that are used a lot
\
\ ******************************************************************************

 ORG &0000              \ Set the assembly address to &0000

.enemyObject

 SKIP 1                 \ An enemy object number, 0-7 ???

.currentObject

 SKIP 1                 \ Used to store the number of the object we are
                        \ currently processing

.L0002

 SKIP 0                 \ ???

.edgeGazeDistance

 SKIP 1                 \ The fractional distance along a tile edge that matches
                        \ the current position along the gaze vector

.xTileViewer

 SKIP 1                 \ The tile x-coordinate of the viewer, but with the axes
                        \ rotated to match the orientation of the viewer, so we
                        \ can draw the landscape along the line of sight,
                        \ towards the viewer's tile

.L0004

 SKIP 1                 \ ???

.drawingTableOffset

 SKIP 1                 \ The offset to use within the various drawing data
                        \ tables for the tile we are analysing

.tileAltitude

 SKIP 1                 \ Used to store a tile altitude

.minYawAngleHi

 SKIP 1                 \ ???

.lastPanKeyPressed

 SKIP 1                 \ The direction of the last pan key that was pressed
                        \ (which may not still be held down)
                        \
                        \   * Bit 7 set = not currently panning
                        \
                        \   * 0 = pan right
                        \
                        \   * 1 = pan left
                        \
                        \   * 2 = pan up
                        \
                        \   * 3 = pan down

.panKeyBeingPressed

 SKIP 1                 \ The direction in which the player is currently panning
                        \
                        \   * Bit 7 set = not currently panning
                        \
                        \   * 0 = pan right
                        \
                        \   * 1 = pan left
                        \
                        \   * 2 = pan up
                        \
                        \   * 3 = pan down

.L000A

 SKIP 1                 \ ???

.playerObject

 SKIP 1                 \ The number of the player object

.L000C

 SKIP 0                 \ ???

.zCounter

 SKIP 0                 \ A counter to iterate along tiles in the z-axis

.stashAddr

 SKIP 1                 \ The address of the four bytes in the secretCodeStash
                        \ that correspond to the landscape's secret code

.L000D

 SKIP 0                 \ ???

.xCounter

 SKIP 1                 \ A counter to iterate along tiles in the x-axis

.L000E

 SKIP 1                 \ ???

.yStoreTileView

 SKIP 0                 \ Temporary storage for Y so it can be preserved through
                        \ calls to GetTileViewAngles

.L000F

 SKIP 1                 \ ???

.screenBufferType

 SKIP 1                 \ The type of screen buffer that is currently being used
                        \
                        \   * 0 = left row buffer (for up/down pan)
                        \         for the first 256 bytes of the 320-byte row
                        \
                        \   * 1 = right row buffer (for up/down pan)
                        \         for the last 64 bytes of the 320-byte row
                        \
                        \   * 2 = column buffer (for left/right pan)

.L0011

 SKIP 1                 \ ???

.maxYawAngleHi

 SKIP 1                 \ ???

.L0013

 SKIP 1                 \ ???

.L0014

 SKIP 1                 \ ???

.loopCounter

 SKIP 1                 \ Used to store a loop counter

.L0016

 SKIP 1                 \ ???

.traceStepCounter

 SKIP 0                 \ The number of steps in the ray-tracing process when
                        \ calculating tile visibility in the GetRowVisibility
                        \ routine

.polygonPointCount

 SKIP 1                 \ The number of points in the polygon point list for the
                        \ polygon being drawn
                        \
                        \ This will be four for a triangle or five for a
                        \ quadrilateral, as the list includes the first point
                        \ repeated at the end

.L0018

 SKIP 0                 \ ???

.xTileRow

 SKIP 0                 \ Used to store the tile x-coordinate of the tile we are
                        \ analysing in the GetRowVisibility routine

.xBlock

 SKIP 1                 \ Used to store the tile x-coordinate of the tile we are
                        \ analysing when calculating the highest tile in a block

.yTileRow

 SKIP 0                 \ Used to store the tile y-coordinate of the tile we are
                        \ analysing in the GetRowVisibility routine

.polygonColours

 SKIP 1                 \ The colours of the polygon that's being drawn in the
                        \ DrawPolygon routine
                        \
                        \   * Bits 2-3 = fill colour
                        \
                        \   * Bits 24-5 = edge colour

.L001A

 SKIP 0                 \ ???

.zTileRow

 SKIP 0                 \ Used to store the tile z-coordinate of the tile row we
                        \ are analysing in the GetRowVisibility routine

.zBlock

 SKIP 1                 \ Used to store the tile z-coordinate of the tile we are
                        \ analysing when calculating the highest tile in a block

.quadrantOffset

 SKIP 1                 \ ???

.viewingArcRightYaw

 SKIP 0                 \ The yaw angle of the right edge of the viewing arc,
                        \ where the arc is 90 degrees wide

.processAction

 SKIP 1                 \ Defines the following:
                        \
                        \   * The action that's applied to tile data by the
                        \     ProcessTileData routine
                        \
                        \   * The action that's applied to tile data by the
                        \     SmoothTileData routine
                        \
                        \ See the ProcessTileData and SmoothTileData routines
                        \ for details

.zTileViewer

 SKIP 1                 \ The tile z-coordinate of the viewer, but with the axes
                        \ rotated to match the orientation of the viewer, so we
                        \ can draw the landscape along the line of sight,
                        \ towards the viewer's tile

.moreColumnsToFill

 SKIP 0                 \ Stores the number of extra columns we need to fill in
                        \ the FillScreen routine after filling up to 32 columns
                        \
                        \   * Bit 7 set = no extra columns required
                        \
                        \   * Bit 7 clear = contains the number of extra columns
                        \                   that we need to fill beyond the 32
                        \                   columns already filled

.blackDotCounter

 SKIP 0                 \ A counter for black dots that are drawn in the screen
                        \ decaying routine

.treeCounter

 SKIP 0                 \ A counter for the number of trees that are added to
                        \ the landscape in the SpawnTrees routine

.L001E

 SKIP 1                 \ ???

.yawAdjustmentLo

 SKIP 1                 \ ???

.screenLeftYawHi

 SKIP 1                 \ The high byte of the yaw angle of the left edge of
                        \ the screen, reduced into the range of a single
                        \ 90-degree quadrant (so it's relative to the 90-degree
                        \ viewing arc)

.drawingTableIndex

 SKIP 1                 \ The index into the drawing tables for the tile being
                        \ analysed

.screenAddr

 SKIP 2                 \ Storage for a screen address

.xTile

 SKIP 1                 \ Tile corner x-coordinate
                        \
                        \ The tile corner coordinate along the x-axis, where the
                        \ x-axis goes from left to right across the screen, with
                        \ one x-coordinate per tile (so this is also the corner
                        \ number along the axis)
                        \
                        \ Each tile in the landscape is defined by a tile
                        \ corner (the "anchor") and the tile shape, with the
                        \ anchor being in the front-left corner of the tile,
                        \ nearest the origin
                        \
                        \ As a result we tend to use the terms "tile" and "tile
                        \ corner" interchangeably, depending on the context

.xTileToDraw

 SKIP 0                \ The column number of the tile we are currently drawing

.columnCounter

 SKIP 1                 \ A counter for the number of columns to fill in the
                        \ FillScreen routine

.fillRowNumber

 SKIP 0                 \ The number of the character row we are currently
                        \ filling in the FillScreen routine
                        \
                        \   * 0 to 24 = we are filling this row number in
                        \               screen memory
                        \
                        \   * 25 to 49 = we are filling this row number in the
                        \                screen buffer (subtract 25 to get the
                        \                actual row number)

.zTile

 SKIP 1                 \ Tile corner z-coordinate
                        \
                        \ The tile corner coordinate along the z-axis, where the
                        \ z-axis goes into the screen, with one z-coordinate per
                        \ tile (so this is also the corner number along the
                        \ axis)
                        \
                        \ Each tile in the landscape is defined by a tile
                        \ corner (the "anchor") and the tile shape, with the
                        \ anchor being in the front-left corner of the tile,
                        \ nearest the origin
                        \
                        \ As a result we tend to use the terms "tile" and "tile
                        \ corner" interchangeably, depending on the context

.bitMask

 SKIP 1                 \ Used to return a bit mask from the GetTilesAtAltitude
                        \ routine that has a matching number of leading zeroes
                        \ as the number of tile blocks at a specific altitude

.minYawAngleLo

 SKIP 1                 \ ???

.L0029

 SKIP 1                 \ ???

.randomPixel

 SKIP 0                 \ Storage for a random value in the DrawRandomDots
                        \ routine to use as a random pixel number when drawing
                        \ dots

.sightsByteAddr

 SKIP 2                 \ Storage for an address that loops through the pixel
                        \ bytes in screen memory where the sights appear, so the
                        \ sights can be drawn and removed using the contents of
                        \ the sights pixel byte stash

.L002C

 SKIP 0                 \ ???

.xVectorBot

 SKIP 1                 \ The x-coordinate of a vector (bottom byte)
                        \
                        \ For example, this is used to store the vector from the
                        \ player's eyes to the sights within the 3D world

.L002D

 SKIP 0                 \ ???

.yVectorBot

 SKIP 1                 \ The y-coordinate of a vector (bottom byte)
                        \
                        \ For example, this is used to store the vector from the
                        \ player's eyes to the sights within the 3D world

.zVectorBot

 SKIP 1                 \ The z-coordinate of a vector (bottom byte)
                        \
                        \ For example, this is used to store the vector from the
                        \ player's eyes to the sights within the 3D world

.xVectorLo

 SKIP 1                 \ The x-coordinate of a vector (low byte)
                        \
                        \ For example, this is used to store the vector from the
                        \ player's eyes to the sights within the 3D world

.yVectorLo

 SKIP 1                 \ The y-coordinate of a vector (low byte)
                        \
                        \ For example, this is used to store the vector from the
                        \ player's eyes to the sights within the 3D world

.zVectorLo

 SKIP 1                 \ The z-coordinate of a vector (low byte)
                        \
                        \ For example, this is used to store the vector from the
                        \ player's eyes to the sights within the 3D world

.xTileViewLeft

 SKIP 0                 \ The tile number at the left edge of the tile row we
                        \ are currently processing when drawing the landscape

.cosVectorPitchLo

 SKIP 1                 \ The low byte of cos(vectorPitchAngle) when converting
                        \ pitch and yaw angles to cartesian vectors

.xTileViewRight

 SKIP 0                 \ The tile number at the right edge of the tile row we
                        \ are currently processing when drawing the landscape

.cosVectorPitchHi

 SKIP 1                 \ The high byte of cos(vectorPitchAngle) when converting
                        \ pitch and yaw angles to cartesian vectors

.xCoordBot

 SKIP 0                 \ The x-coordinate of an object or point (bottom byte)
                        \
                        \ Stored as a 24-bit value (xCoordHi xCoordLo xCoordBot)

.L0034

 SKIP 1                 \ ???

.yCoordBot

 SKIP 0                 \ The y-coordinate of an object or point (bottom byte)
                        \
                        \ Stored as a 24-bit value (yCoordHi yCoordLo yCoordBot)

.L0035

 SKIP 1                 \ ???

.zCoordBot

 SKIP 0                 \ The z-coordinate of an object or point (bottom byte)
                        \
                        \ Stored as a 24-bit value (zCoordHi zCoordLo zCoordBot)

.L0036

 SKIP 1                 \ ???

.xCoordLo

 SKIP 0                 \ The x-coordinate of an object or point (low byte)
                        \
                        \ Stored as a 24-bit value (xCoordHi xCoordLo xCoordBot)

.xTileViewLeftEdge

 SKIP 1                 \ The tile number at the left edge of the visible
                        \ portion of the row we are currently processing when
                        \ drawing the landscape

.yCoordLo

 SKIP 0                 \ The y-coordinate of an object or point (low byte)
                        \
                        \ Stored as a 24-bit value (yCoordHi yCoordLo yCoordBot)

.xTileViewRightEdge

 SKIP 1                 \ The tile number at the right edge of the visible
                        \ portion of the row we are currently processing when
                        \ drawing the landscape

.zCoordLo

 SKIP 0                 \ The z-coordinate of an object or point (low byte)
                        \
                        \ Stored as a 24-bit value (zCoordHi zCoordLo zCoordBot)

.L0039

 SKIP 1                 \ ???

.xCoordHi

 SKIP 1                 \ The x-coordinate of an object or point (high byte)
                        \
                        \ Stored as a 24-bit value (xCoordHi xCoordLo xCoordBot)

.yCoordHi

 SKIP 0                 \ The y-coordinate of an object or point (high byte)
                        \
                        \ Stored as a 24-bit value (yCoordHi yCoordLo yCoordBot)

.polygonType

 SKIP 1                 \ Bits 6 and 7 determine the type of polygon to draw in
                        \ the DrawPolygon routine (the calling subroutine is in
                        \ brackets)
                        \
                        \   * %00xxxxxx = quadrilateral (DrawOneFaceTile)
                        \
                        \   * %01xxxxxx = object polygon (DrawObject)
                        \
                        \   * %10xxxxxx = first triangle (DrawTwoFaceTile)
                        \
                        \   * %11xxxxxx = second triangle (DrawTwoFaceTile)

.zCoordHi

 SKIP 0                 \ The z-coordinate of an object or point (high byte)
                        \
                        \ Stored as a 24-bit value (zCoordHi zCoordLo zCoordBot)

.drawViewAngles

 SKIP 1                 \ The address in drawViewAngles(1 0) of the pitch and yaw
                        \ angles of the tile and polygon points that we are
                        \ drawing in the landscape view

.vectorYawAngleLo

 SKIP 1                 \ The yaw angle of a vector (low byte)
                        \
                        \ For example, this is used to store the vector from the
                        \ player's eyes to the sights within the 3D world

.vectorYawAngleHi

 SKIP 1                 \ The yaw angle of a vector (high byte)
                        \
                        \ For example, this is used to store the vector from the
                        \ player's eyes to the sights within the 3D world

.vectorPitchAngleLo

 SKIP 1                 \ The pitch angle of a vector (low byte)
                        \
                        \ For example, this is used to store the vector from the
                        \ player's eyes to the sights within the 3D world

.vectorPitchAngleHi

 SKIP 1                 \ The pitch angle of a vector (high byte)
                        \
                        \ For example, this is used to store the vector from the
                        \ player's eyes to the sights within the 3D world

.L0041

 SKIP 1                 \ ???

.L0042

 SKIP 1                 \ ???

.L0043

 SKIP 2                 \ ???

.L0045

 SKIP 5                 \ ???

.L004A

 SKIP 1                 \ ???

.viewingQuadrantOpp

 SKIP 1                 \ ???

.objTypeToAnalyse

 SKIP 1                 \ The type of the object being analysed in the
                        \ GetObjectAngles routine

 SKIP 1                 \ This byte appears to be unused

.polygonNumber

 SKIP 0                 \ A counter for the polygon number as we work through
                        \ the polygons in an object when drawing the object

.pointNumber

 SKIP 1                 \ A counter for the point number as we work through the
                        \ points in an object when calculating the point's
                        \ angles

.objectLastPolygon

 SKIP 0                 \ The number of the last polygon in the object being
                        \ drawn

.objectLastPoint

 SKIP 1                 \ The number of the last point in the object being drawn

.pitchDeltaLo

 SKIP 1                 \ The delta between two pitch angles (low byte)

.maxPitchAngle

 SKIP 1                 \ The maximum pitch angle that fits into the current
                        \ screen buffer

.minPitchAngle

 SKIP 1                 \ The minimum pitch angle that fits into the current
                        \ screen buffer

.drawingPhaseCount

 SKIP 1                 \ A phase counter for objects that need to be drawn in
                        \ multiple phases

.L0054

 SKIP 1                 \ ???

.screenOrBuffer

 SKIP 1                 \ Controls whether the graphics routines draw directly
                        \ onto the screen, or into the screen buffer
                        \
                        \   * 0 = draw directly into screen memory
                        \
                        \   * 25 = draw into the screeen buffer

.L0056

 SKIP 1                 \ ???

.screenRowCounter

 SKIP 1                 \ A counter for filling screen rows in the FillScreen
                        \ routine

.L0058

 SKIP 1                 \ ???

.objectGazeYawLo

 SKIP 1                 \ The difference in the yaw angle of the viewer's gaze
                        \ and the yaw angle (i.e. the gaze) of the object being
                        \ analysed (low byte)

.objectGazeYawHi

 SKIP 1                 \ The difference in the yaw angle of the viewer's gaze
                        \ and the yaw angle (i.e. the gaze) of the object being
                        \ analysed (low byte)

 SKIP 1                 \ This byte appears to be unused

.bLo

 SKIP 1                 \ The low byte of the opposite side of a triangle when
                        \ calculating the hypotenuse

.bHi

 SKIP 1                 \ The high byte of the opposite side of a triangle when
                        \ calculating the hypotenuse

.tileDataPage

 SKIP 2                 \ The address of the tileData page containing the
                        \ current tile's data

.considerObjects

 SKIP 0                 \ Controls whether the GetTileAltitude routine takes
                        \ objects into consideration when calculating tile
                        \ altitudes

.secondAxis

 SKIP 1                 \ The number of the second axis to calculate in the
                        \ GetRotationMatrix routine

.L0061

 SKIP 1                 \ ???

.fromAddr

 SKIP 2                 \ An address, typically used as a source address when
                        \ copying

.toAddr

 SKIP 2                 \ An address, typically used as a destination address
                        \ when copying

.viewingQuadrantx4

 SKIP 0                 \ ???

.smoothingAction

 SKIP 1                 \ The action that's applied to tile data by the
                        \ SmoothTileData routine
                        \
                        \ See the SmoothTileData routine for details

.H

 SKIP 1                 \ Temporary storage, used in the maths routines

.RR

 SKIP 1                 \ Temporary storage, used in the maths routines

.SS

 SKIP 1                 \ Temporary storage, used in the maths routines

.PP

 SKIP 1                 \ Temporary storage, used in the maths routines

.QQ

 SKIP 1                 \ Temporary storage, used in the maths routines

.L006C

 SKIP 1                 \ ???

.screenAddrHi

 SKIP 1                 \ Storage for the high byte of the screen memory address
                        \ in the ScrollPlayerView routine

.viewingObject

 SKIP 0                 \ The number of the object that is viewing the landscape
                        \ (or the title screen or game over screen) ???

.enemyCounter

 SKIP 1                 \ Used as a loop counter when adding enemies to the
                        \ landscape

.objectToAnalyse

 SKIP 1                 \ The number of the object to analyse in the
                        \ GetObjectAngles routine

.P

 SKIP 1                 \ Temporary storage, used in a number of places

.Q

 SKIP 1                 \ Temporary storage, used in a number of places

.R

 SKIP 1                 \ Temporary storage, used in a number of places

.S

 SKIP 1                 \ Temporary storage, used in a number of places

.T

 SKIP 1                 \ Temporary storage, used in a number of places

.U

 SKIP 1                 \ Temporary storage, used in a number of places

.V

 SKIP 1                 \ Temporary storage, used in a number of places

.W

 SKIP 1                 \ Temporary storage, used in a number of places

.G

 SKIP 1                 \ Temporary storage, used in a number of places

.platformAltitudeLo

 SKIP 1                 \ The low byte of the altitude of the Sentinel's tower
                        \ or boulder when returning tile data from the
                        \ GetTileAltitude routine

.aLo

 SKIP 1                 \ The low byte of the adjacent side of a triangle when
                        \ calculating the hypotenuse

.aHi

 SKIP 1                 \ The high byte of the adjacent side of a triangle when
                        \ calculating the hypotenuse

.hypotenuseLo

 SKIP 1                 \ The low byte of the hypotenuse of a triangle

.hypotenuseHi

 SKIP 1                 \ The high byte of the hypotenuse of a triangle

.angleTangent

 SKIP 1                 \ Used to store a tangent angle

.tileIsOnScreen

 SKIP 0                 \ Information on whether a tile is fully on-screen,
                        \ partially on-screen or fully off-screen

.L007F

 SKIP 1                 \ ???

.xDeltaLo

 SKIP 1                 \ The difference between two x-coordinates (low byte)

.yDeltaLo

 SKIP 1                 \ The difference between two y-coordinates (low byte)

.zDeltaLo

 SKIP 1                 \ The difference between two z-coordinates (low byte)

.xDeltaAbsoluteHi

 SKIP 1                 \ The absolute difference between two x-coordinates
                        \ (high byte), i.e. |xDeltaHi|

.yDeltaHi

 SKIP 1                 \ The difference between two y-coordinates (high byte)

.zDeltaAbsoluteHi

 SKIP 1                 \ The absolute difference between two z-coordinates
                        \ (high byte), i.e. |zDeltaHi|

.xDeltaHi

 SKIP 0                 \ The difference between two x-coordinates (high byte)

.xVectorHi

 SKIP 1                 \ The x-coordinate of a vector (high byte)
                        \
                        \ For example, this is used to when ray-tracing from the
                        \ player to tile corners in GetRowVisibility

.yVectorHi

 SKIP 1                 \ The y-coordinate of a vector (high byte)
                        \
                        \ For example, this is used to when ray-tracing from the
                        \ player to tile corners in GetRowVisibility

.zVectorHi

 SKIP 0                 \ The z-coordinate of a vector (high byte)
                        \
                        \ For example, this is used to when ray-tracing from the
                        \ player to tile corners in GetRowVisibility

.zDeltaHi

 SKIP 1                 \ The difference between two z-coordinates (high byte)

 SKIP 1                 \ This byte appears to be unused

.angleLo

 SKIP 1                 \ The high byte of an angle

.angleHi

 SKIP 1                 \ The low byte of an angle

 SKIP 1                 \ This byte appears to be unused

.pitchDeltaHi

 SKIP 1                 \ The delta between two pitch angles (high byte)

.sinA

 SKIP 1                 \ The result of the sin(A) calculation in the
                        \ GetSineAndCosine routine

.cosA

 SKIP 1                 \ The result of the cos(A) calculation in the
                        \ GetSineAndCosine routine

\ ******************************************************************************
\
\       Name: Stack variables
\       Type: Workspace
\    Address: &0100 to &01BF
\   Category: Workspaces
\    Summary: Variables that share page 1 with the stack
\
\ ******************************************************************************

 ORG &0100              \ Set the assembly address to &0100

.objectFlags

 SKIP 64                \ Object flags for up to 64 objects
                        \
                        \   * Bits 0-5 = the number of the object beneath this
                        \                one, if bit 6 is set (0 to 63)
                        \
                        \   * Bit 6 = is this object stacked on top of another
                        \             object?
                        \
                        \       * Clear = no
                        \
                        \       * Set = this object is on top of another object
                        \               and the number of the object beneath
                        \               this one is in bits 0-5
                        \
                        \   * Bit 7 = has this object number been allocated to
                        \             an object or is it unused?
                        \
                        \       * Clear = this object number has been allocated
                        \                 to an object
                        \
                        \       * Set = this object number is unused

.objectPitchAngle

 SKIP 64                \ The pitch angle for each object (i.e. the vertical
                        \ direction in which they are facing)

.tileViewData

 SKIP 0                 \ Storage for the tile data of tiles in the current
                        \ landscape view
                        \
                        \ This shares the same memory location as oddVisibility
                        \ and evenVisibility

.oddVisibility

 SKIP 32                \ Storage for the visibility of tiles corners in odd
                        \ rows as they are processed by the GetRowVisibility
                        \ routine
                        \
                        \   * 0 = tile corner is not visible
                        \
                        \   * &FF = tile corner is visible

.evenVisibility

 SKIP 32                \ Storage for the visibility of tiles corners in even
                        \ rows as they are processed by the GetRowVisibility
                        \ routine
                        \
                        \   * 0 = tile corner is not visible
                        \
                        \   * &FF = tile corner is visible

\ ******************************************************************************
\
\ THE SENTINEL MAIN GAME CODE
\
\ Produces the binary file Sentinel.bin that contains the main game code.
\
\ ******************************************************************************

 ORG CODE%              \ Set the assembly address to &0400

\ ******************************************************************************
\
\       Name: tileData
\       Type: Variable
\   Category: Landscape
\    Summary: Altitude and shape data for landscape tiles
\
\ ------------------------------------------------------------------------------
\
\ The landscape in The Sentinel consists of a tiled area of 31x31 tiles, like an
\ undulating chess board that's sitting on a table in front of us, going into
\ the screen.
\
\ The shape of the landscape is defined by the altitude of the corners of each
\ tile, so that's a 32x32 grid of altitudes, one for each tile corner.
\
\ The x-axis is along the front edge, from left to right, while the z-axis goes
\ into the screen from front to back, away from us.
\
\ This table contains one byte of data for each tile corner in the landscape.
\
\ If there is no object placed on the tile, then the data contained in each byte
\ is as follows:
\
\   * The low nibble of each byte contains the tile shape, which describes the
\     layout and structure of the landscape on that tile (0 to 15).
\
\   * The high nibble of each byte contains the altitude of the tile corner in
\     the front-left corner of the tile (i.e. the corner closest to the origin
\     of the landscape). We call this tile corner the "anchor". The altitude is
\     in the range 1 to 11, so the top nibble never has both bit 6 and 7 set.
\
\ If there is an object placed on the tile, then the data contained in each byte
\ is as follows:
\
\   * Bits 0 to 5 contain the number of the object on the tile (0 to 63). If
\     there are multiple objects stacked on the tile, this is the number of the
\     object on the top of the stack.
\
\   * Bits 6 and 7 of the byte are set.
\
\ We can therefore test for the presence of an object on a tile by checking
\ whether both bit 6 and 7 are set (as empty tiles have the tile altitude in the
\ top nibble, and this is in the range 1 to 11).
\
\ As each tile is defined by a tile corner and a shape, we tend to use the terms
\ "tile" and "tile corner" interchangeably, depending on the context. That said,
\ for tile corners along the furthest back and rightmost edges of the landscape,
\ the shape data is ignored, as there is no landscape beyond the edges.
\
\ See the GetTileShape routine for information on the different types of tile
\ shape.
\
\ ******************************************************************************

.tileData

 EQUB &00, &00, &00, &00, &00, &00, &00, &27        \ These values are workspace
 EQUB &29, &20, &27, &29, &29, &27, &20, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &29, &29, &29, &29, &29, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &20, &20, &20
 EQUB &20, &20, &20, &29, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &29, &29, &29, &29, &29, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &29, &29, &29
 EQUB &29, &29, &29, &29, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &20, &20, &20, &20, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &29, &29, &29
 EQUB &29, &29, &29, &29, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &20, &20, &20, &20, &20, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &29, &29, &29, &29, &29, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &29, &29, &29, &29, &29, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &29, &29, &29, &29, &29, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &20, &20, &29, &20, &20, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &20, &20, &29, &20, &20, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &29, &29, &29
 EQUB &29, &29, &29, &29, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &27, &29, &28, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &20, &20, &20
 EQUB &29, &20, &20, &20, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &29, &29, &29, &29, &29, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &29, &20, &20
 EQUB &29, &20, &20, &29, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &29, &29, &29, &29, &29, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &27, &29, &28, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &20, &20, &29, &20, &20, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &20, &20, &20, &20, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &28
 EQUB &29, &29, &28, &20, &29, &28, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &20, &20, &28, &20, &20, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &20, &20, &20
 EQUB &20, &20, &20, &29, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &29, &29, &29, &29, &29, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &29, &29, &29
 EQUB &29, &29, &29, &29, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &20, &20, &20, &20, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &29, &20, &20
 EQUB &28, &20, &20, &29, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &20, &20, &20, &20, &20, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &29, &29, &29, &29, &29, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &20, &20, &28, &20, &20, &29, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &29
 EQUB &20, &20, &20, &20, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &20, &20, &20, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &20, &20, &20, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &20, &20, &20
 EQUB &20, &20, &20, &20, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &20, &20, &20, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &20, &20, &20
 EQUB &20, &20, &20, &20, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &20, &20, &20, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &20, &20, &20
 EQUB &20, &20, &20, &20, &20, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &20, &20, &20, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &20, &20, &20, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &20, &20, &20, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &20
 EQUB &20, &20, &20, &20, &20, &20, &20, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &00, &00, &00, &00, &00, &00, &00
 EQUB &C0, &C0, &C0, &C0, &04, &04, &04, &04
 EQUB &00, &00, &00, &64, &00, &00, &00, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &05, &00, &00, &00, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &00, &00, &00, &00, &F0, &00, &0E
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &64, &06, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &90
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: xObject
\       Type: Variable
\   Category: 3D objects
\    Summary: The x-coordinates in 3D space for the 3D objects
\
\ ******************************************************************************

.xObject

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &18

\ ******************************************************************************
\
\       Name: yObjectHi
\       Type: Variable
\   Category: 3D objects
\    Summary: The y-coordinates in 3D space for the 3D objects (high byte)
\
\ ------------------------------------------------------------------------------
\
\ The y-coordinate (i.e. the altitude) of each object is stored as a 16-bit
\ number of the form (yObjectHi yObjectLo). The low byte is effectively a
\ fractional part, as a y-coordinate of (1 0) is the same magnitude as an
\ x-coordinate or z-coordinate of 1.
\
\ A full coordinate in the 3D space is therefore in the form:
\
\   (xObject, (yObjectHi yObjectLo), zObject)
\
\ ******************************************************************************

.yObjectHi

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &4B, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &02

\ ******************************************************************************
\
\       Name: zObject
\       Type: Variable
\   Category: 3D objects
\    Summary: The z-coordinates in 3D space for the 3D objects
\
\ ******************************************************************************

.zObject

 EQUB &00, &07, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &BF, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &07

\ ******************************************************************************
\
\       Name: objectYawAngle
\       Type: Variable
\   Category: 3D objects
\    Summary: The yaw angle for each object (i.e. the horizontal direction in
\             which they are facing)
\
\ ******************************************************************************

.objectYawAngle

 EQUB &00, &CE, &F8, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &12, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &80

\ ******************************************************************************
\
\       Name: yObjectLo
\       Type: Variable
\   Category: 3D objects
\    Summary: The y-coordinates in 3D space for the 3D objects (low byte)
\
\ ------------------------------------------------------------------------------
\
\ The y-coordinate (i.e. the altitude) of each object is stored as a 16-bit
\ number of the form (yObjectHi yObjectLo). The low byte is effectively a
\ fractional part, as a y-coordinate of (1 0) is the same magnitude as an
\ x-coordinate or z-coordinate of 1.
\
\ A full coordinate in the 3D space is therefore in the form:
\
\   (xObject, (yObjectHi yObjectLo), zObject)
\
\ ******************************************************************************

.yObjectLo

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &E0

\ ******************************************************************************
\
\       Name: objectTypes
\       Type: Variable
\   Category: 3D objects
\    Summary: The object types table for up to 64 objects
\
\ ------------------------------------------------------------------------------
\
\ The different object types are as follows:
\
\   * 0 = Robot (one of which is the player)
\
\   * 1 = Sentry
\
\   * 2 = Tree
\
\   * 3 = Boulder
\
\   * 4 = Meanie
\
\   * 5 = The Sentinel
\
\   * 6 = The Sentinel's tower
\
\ ******************************************************************************

.objectTypes

 EQUB &00, &06, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &09

\ ******************************************************************************
\
\       Name: drawViewPitchLo
\       Type: Variable
\   Category: Drawing the landscape
\    Summary: Storage for the pitch angles of tiles and object points for
\             drawing the current landscape view (low bytes)
\
\ ------------------------------------------------------------------------------
\
\ Tile angles are stored in the first 64 bytes (in two sets of 32 bytes), and
\ object point angles are stored in the last 32 bytes, from offset 64 onwards.
\
\ ******************************************************************************

.drawViewPitchLo

 EQUB &6F, &70, &71, &73, &74, &75, &76, &78        \ These values are workspace
 EQUB &79, &7B, &7C, &7E, &7F, &81, &82, &84        \ noise and have no meaning
 EQUB &86, &87, &89, &8B, &8D, &8E, &90, &92
 EQUB &95, &96, &98, &9A, &9C, &9E, &A0, &A2
 EQUB &73, &75, &76, &77, &78, &79, &7A, &7C
 EQUB &7D, &7E, &80, &82, &83, &84, &86, &88
 EQUB &89, &8B, &8D, &8F, &90, &92, &94, &96
 EQUB &98, &99, &9B, &9D, &9F, &A1, &A3, &A5
 EQUB &96, &96, &9A, &9C, &A0, &9E, &A1, &A4
 EQUB &58, &59, &5A, &5A, &A1, &A3, &B1, &B0
 EQUB &AC, &AD, &B3, &B3, &A9, &AA, &B9, &B9
 EQUB &BC, &BC, &C6, &C6, &C4, &C4, &00, &00

\ ******************************************************************************
\
\       Name: drawViewPitchHi
\       Type: Variable
\   Category: Drawing the landscape
\    Summary: Storage for the pitch angles of tiles and object points for
\             drawing the current landscape view (high bytes)
\
\ ------------------------------------------------------------------------------
\
\ Tile angles are stored in the first 64 bytes (in two sets of 32 bytes), and
\ object point angles are stored in the last 32 bytes, from offset 64 onwards.
\
\ ******************************************************************************

.drawViewPitchHi

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &10, &10

\ ******************************************************************************
\
\       Name: L0B40
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L0B40

 EQUB &10, &10, &10, &10, &10, &10, &10, &10        \ These values are workspace
 EQUB &10, &10, &10, &10, &10, &10, &10, &10        \ noise and have no meaning
 EQUB &10, &10, &10, &10, &10, &10, &10, &10
 EQUB &10, &10, &10, &10, &10, &10, &10, &10
 EQUB &10, &10, &10, &10, &10, &10, &10, &10
 EQUB &10, &10, &10, &10, &10, &10, &10, &10
 EQUB &10, &10, &10, &10, &10, &10, &10, &10
 EQUB &10, &10, &10, &10, &10, &10, &10, &10
 EQUB &10, &10, &10, &10, &10, &10, &10, &10
 EQUB &10, &10, &10, &10, &10, &10, &10, &10
 EQUB &10, &10, &10, &10, &10, &10, &10, &10
 EQUB &10, &10, &10, &10, &10, &10, &10, &10

\ ******************************************************************************
\
\       Name: drawViewYawLo
\       Type: Variable
\   Category: Drawing the landscape
\    Summary: Storage for the yaw angles of tiles and object points for drawing
\             the current landscape view (low bytes)
\
\ ------------------------------------------------------------------------------
\
\ Tile angles are stored in the first 64 bytes (in two sets of 32 bytes), and
\ object point angles are stored in the last 32 bytes, from offset 64 onwards.
\
\ ******************************************************************************

.drawViewYawLo

 EQUB &3B, &C1, &48, &D6, &5A, &DD, &69, &EB        \ These values are workspace
 EQUB &6B, &F3, &71, &EE, &73, &ED, &67, &E7        \ noise and have no meaning
 EQUB &5E, &D3, &50, &C3, &35, &AE, &1D, &8A
 EQUB &FF, &6A, &D5, &44, &AC, &12, &77, &E2
 EQUB &1D, &A4, &2B, &B0, &35, &B8, &3B, &BC
 EQUB &46, &C6, &44, &C2, &3E, &B9, &32, &AB
 EQUB &2B, &A1, &16, &8A, &FC, &6E, &DE, &4C
 EQUB &C1, &2D, &98, &02, &6A, &D1, &37, &9B
 EQUB &71, &02, &30, &95, &D2, &6D, &30, &95
 EQUB &4E, &2D, &58, &84, &E0, &1D, &65, &49
 EQUB &9B, &B7, &EC, &2A, &F8, &8D, &CD, &49
 EQUB &47, &53, &33, &A5, &E2, &65, &10, &10

\ ******************************************************************************
\
\       Name: Main variable workspace
\       Type: Workspace
\    Address: &0C00 to &0CFF
\   Category: Workspaces
\    Summary: The main block of game variables
\
\ ******************************************************************************

.sinAngleLo

 EQUB 0                 \ The low byte of the sine of a pitch or yaw angle,
                        \ as calculated by the GetRotationMatrix routine

.cosAngleLo

 EQUB 0                 \ The low byte of the cosine of a pitch or yaw angle,
                        \ as calculated by the GetRotationMatrix routine

.sinAngleHi

 EQUB 0                 \ The high byte of the sine of a pitch or yaw angle,
                        \ as calculated by the GetRotationMatrix routine

.cosAngleHi

 EQUB 0                 \ The high byte of the cosine of a pitch or yaw angle,
                        \ as calculated by the GetRotationMatrix routine

.scannerUpdate

 EQUB 0                 \ A flag to control whether the scanner gets updated:
                        \
                        \   * Non-zero = update scanner
                        \
                        \   * Zero = do not update scanner

.xIconCounter

 EQUB &28               \ A counter for drawing the icons in the top-left of the
                        \ screen that show the player's energy level, as we work
                        \ from left top right along the x-axis

.minEnemyAltitude

 EQUB 0                 \ The altitude of the lowest enemy on the landscape

.maxNumberOfEnemies

 EQUB 0                 \ The maximum number of enemies that can appear on the
                        \ current landscape, which is calculated as follows:
                        \
                        \   min(8, 1 + (landscapeNumber div 10))
                        \
                        \ So landscapes 0000 to 0009 have a maximum enemy count
                        \ of 1, landscapes 0010 to 0019 have a maximum enemy
                        \ count of 2, and so on up to landscapes 0070 and up,
                        \ which have a maximum enemy count of 8

.tileDataMultiplier

 EQUB 0                 \ A multiplier that we apply to the altitudes of the
                        \ tile corners to alter the steepness of the landscape
                        \ during landscape generation

.lastScannerState

 EQUB 0                 \ The state of the scanner the last time that it was
                        \ upated:
                        \
                        \   * 0 = fill scanner with black
                        \
                        \   * 4 = fill the scanner with static in colour 3
                        \
                        \   * 8 = fill scanner with green

.playerEnergy

 EQUB 0                 \ The player's energy level (in the range 0 to 63)

 EQUB 0                 \ This byte appears to be unused

.J

 EQUB 0                 \ Temporary storage, used in the maths routines from
                        \ Revs

.gameplayStack

 EQUB 0                 \ Storage for the stack pointer at the start of the
                        \ sub_C16A8 routine, just after it is called from
                        \ ProcessGameplay, so the return address at this point
                        \ on the stack will take us back to ProcessGameplay
                        \ when we next execute an RTS instruction

.L0C0E

 EQUB 0                 \ ???

.textDropShadow

 EQUB 0                 \ Controls whether text in text tokens is printed with a
                        \ drop shadow
                        \
                        \   * Bit 7 clear = drop shadow
                        \
                        \   * Bit 7 set = no drop shadow

.characterDef

 EQUB 0, 0, 0, 0        \ An OSWORD block for reading a character definition
 EQUB 0, 0, 0, 0        \ from the operating system, for use when drawing text
 EQUB 0                 \ in large 3D blocks

.xTileSentinel

 EQUB 0                 \ The tile x-coordinate of the Sentinel

.zTileSentinel

 EQUB 0                 \ The tile z-coordinate of the Sentinel

.keepCheckingPanKey

 EQUB 0                 \ Controls whether the DrawLandscapeView routine aborts
                        \ drawing if the pan key is released before it has
                        \ finished
                        \
                        \   * Bit 7 clear = keep drawing the landscape view
                        \                   irrespective of whether the pan key
                        \                   is still being pressed
                        \
                        \   * Bit 7 set = check whether the same pan key is
                        \                 being held down and abort the drawing
                        \                 if it is no longer being pressed

.titleObjectToDraw

 EQUB 5                 \ The object we are drawing in the DrawTitleView routine

.latestPanKeyPress

 EQUB 0                 \ The key logger value of the latest pan key press,
                        \ which will either be a current key press or the value
                        \ from the last pan key press to be made
                        \
                        \   * 0 = pan right
                        \
                        \   * 1 = pan left
                        \
                        \   * 2 = pan up
                        \
                        \   * 3 = pan down

.L0C1E

 EQUB 0                 \ ???

.samePanKeyPress

 EQUB 0                 \ Records whether the same pan key is being held down
                        \ after we have just finished panning the landscape view
                        \
                        \   * Bit 7 clear = same pan key is not being held down
                        \
                        \   * Bit 7 set = same pan key is being held down

.L0C20

 EQUB 0, 0, 0, 0        \ ???
 EQUB 0, 0, 0, 0

.L0C28

 EQUB 0, 0, 0, 0        \ ???
 EQUB 0, 0, 0, 0

.objRotationTimer

 EQUB 0, 0, 0, 0        \ A timer that counts down on each iteration of the main
 EQUB 0, 0, 0, 0        \ game loop for each object, to control when that object
 EQUB 0, 0, 0, 0        \ rotates
 EQUB 0, 0, 0, 0

.L0C40

 EQUB 0                 \ ???

.L0C41

 EQUB 0                 \ ???

.L0C42

 EQUB 0                 \ ???

.L0C43

 EQUB 0                 \ ???

.L0C44

 EQUB 0

 EQUB 0, 0              \ These bytes appear to be unused

.drawingPhase

 EQUB 0                 \ The number of the current drawing phase when drawing
                        \ two-phase objects:
                        \
                        \   * Bit 7 = 0: first phase
                        \
                        \   * Bit 7 = 1: second phase

.xTileLeftPrevious

 EQUB 2                 \ Storage for the previous value of xTileViewLeft
                        \
                        \ This makes the search for edges more efficient in the
                        \ DrawLandscapeView routine as the edges in neighbouring
                        \ rows will be close together

.xTileCharacter

 EQUB 32                \ The tile x-coordinate of the character being spawned
                        \ in large 3D blocks on the landscape for the title
                        \ screen

.zTileCharacter

 EQUB 7                 \ The tile z-coordinate of the character being spawned
                        \ in large 3D blocks on the landscape for the title
                        \ screen

.drawingTitleScreen

 EQUB %10000000         \ A flag to indicate whether we are currently drawing a
                        \ title screen in the DrawTitleScreen routine
                        \
                        \   * Bit 7 clear = we are not drawing a title screen
                        \
                        \   * Bit 7 set = we are drawing a title screen

.screenBackground

 EQUB 1                 \ The type of screen background when clearing the screen
                        \
                        \   * 0 = fill with alternating colour 0/1 (blue/black)
                        \         pixel rows, for the sky during gameplay
                        \
                        \   * 1 = fill with solid colour 0 (blue)
                        \
                        \   * 2 = fill with dithered pixels in colour 0 (blue)
                        \         and colour 3 (e.g. green in landscape 0000)
                        \         by alternating colour 3/0/3/0 and 0/3/0/3
                        \         pixel bytes
                        \
                        \   * 3 = fill with solid colour 1 (black) and draw 240
                        \         randomly positioned stars on the background

.L0C4D

 EQUB 0                 \ ???

.sentinelHasWon

 EQUB 0                 \ A flag to record when the player runs out of energy
                        \ (i.e. the energy level goes negative), at which point
                        \ the Sentinel wins
                        \
                        \   * Bit 7 clear = player still has positive energy
                        \
                        \   * Bit 7 set = player has run out of energy and the
                        \                 Sentinel has won

.playerTileIsHidden

 EQUB 0                 \ A flag that records when the player is being scanned
                        \ but the player's tile is hidden from the Sentinel or
                        \ sentry doing the scan
                        \
                        \   * 64 = player's tile is hidden from the scan
                        \
                        \   * Not 64 = player's tile is visible

.L0C50

 EQUB 0                 \ ???

.uTurnStatus

 EQUB 0                 \ A flag to record whether we are performing or have
                        \ just performed a U-turn
                        \
                        \   * Bit 6 clear = do not perform a U-turn if "U" is
                        \                   pressed
                        \
                        \   * Bit 6 set = do a U-turn if "U" is pressed
                        \
                        \ Bit 6 is set in CheckForKeyPresses (which is called by
                        \ the interrupt handler) if "U" is not being pressed, so
                        \ this flag ensures that pressing and holding the "U"
                        \ key does not continuously perform U-turns, and instead
                        \ only performs a single U-turn
                        \
                        \ When a "U" key press is detected in ProcessActionKeys,
                        \ uTurnStatus is shifted left, so for the first
                        \ iteration of the main game loop after "U" is pressed,
                        \ bit 7 is set to indicate that we just performed a
                        \ U-turn

.landscapeZero

 EQUB 0                 \ A flag that is set depending on whether we are playing
                        \ landscape 0000
                        \
                        \   * Zero = this is landscape 0000
                        \
                        \   * Non-zero = this is not landscape 0000

.G2

 EQUB 0                 \ Temporary storage, used in the maths routines from
                        \ Revs, where the original variable name was G (this
                        \ variable has been renamed to G2 to prevent a clash
                        \ with the G variable that is used by The Sentinel)

.H2

 EQUB 0                 \ Temporary storage, used in the maths routines from
                        \ Revs, where the original variable name was H (this
                        \ variable has been renamed to H2 to prevent a clash
                        \ with the H variable that is used by The Sentinel)

.stashOffset

 EQUB 0                 \ The offset into the secretCodeStash where we store a
                        \ set of generated values for later checking in the
                        \ GetRowVisibility routine
                        \
                        \ The value of stashOffset is set in the SetSecretStash
                        \ routine during the landscape drawing process, where it
                        \ is set to a value that is unique and consistent for
                        \ each individual landscape

.targetOnTile

 EQUB 0                 \ A flag to record whether the tile being analysed in
                        \ the GetTileAltitude routine contains the target object
                        \ whose number is in targetObject
                        \
                        \   * Bit 7 clear = tile does not contain the target
                        \                   object
                        \
                        \   * Bit 7 set = tile contains the target object

.objectViewYawHi

 EQUB 13                \ The yaw angle of the object being analysed, relative
                        \ to the current viewer (high byte)

.targetObject

 EQUB 0                 \ The number of the object that is being targeted in the
                        \ DrainObjectEnergy routine

.objectViewYawLo

 EQUB &16               \ The yaw angle of the object being analysed, relative
                        \ to the current viewer (low byte)

 EQUB 0                 \ This byte appears to be unused

.objectOppositeLo

 EQUB &E0               \ The height of an object relative to the viewer,
                        \ expressed as the length of the opposite side in a
                        \ triangle with the vector from the viewer to the object
                        \ as the hypotenuse (low byte)

.objectOppositeHi

 EQUB &B7               \ The height of an object relative to the viewer,
                        \ expressed as the length of the opposite side in a
                        \ triangle with the vector from the viewer to the object
                        \ as the hypotenuse (high byte)

.objectAdjacentLo

 EQUB &E4               \ The distance of an object from the viewer, expressed
                        \ as the length of the adjacent side in a triangle with
                        \ the vector from the viewer to the object as the
                        \ hypotenuse (low byte)

.objectAdjacentHi

 EQUB &52               \ The distance of an object from the viewer, expressed
                        \ as the length of the adjacent side in a triangle with
                        \ the vector from the viewer to the object as the
                        \ hypotenuse (high byte)

.sightsAreVisible

 EQUB 0                 \ Controls whether the sights are being shown
                        \
                        \   * Bit 7 clear = sights are not being shown
                        \
                        \   * Bit 7 set = sights are being shown

.printTextIn3D

 EQUB 0                 \ Controls whether we are printing text normally or in
                        \ 3D (as in the game's title on the title screen)
                        \
                        \   * Bit 7 clear = normal text
                        \
                        \   * Bit 7 set = 3D text

.objectType

 SKIP 0                 \ Storage for the type of object that we are spawning
                        \
                        \ This shares the same memory location as keyPress

.keyPress

 EQUB 0                 \ Storage for the key logger value for a key press
                        \
                        \ This shares the same memory location as objectType
                        \
                        \ This means that if the player presses one of the
                        \ "create" keys, then the value in the key logger (as
                        \ defined in the keyLoggerConfig table) can be used as
                        \ the object type to create, as "Create robot" puts a 0
                        \ in the key logger (the object type for a robot),
                        \ "Create tree" puts a 2 in the logger (the object type
                        \ for a tree) and "Create boulder" puts a 3 in the
                        \ logger (the object type for a boulder)

.L0C62

 EQUB 0                 \ ???

.playerHasMovedTile

 EQUB 0                 \ A flag to record whether the player has moved to a new
                        \ tile by transferring or hyperspacing, so we can decide
                        \ whether to regenerate the player's landscape view
                        \
                        \   * Bit 7 clear = player has not moved to a new tile
                        \
                        \   * Bit 7 set = player has moved to a new tile

.quitGame

 EQUB 0                 \ A flag to record whether the player has pressed
                        \ function key f1 to quit the game
                        \
                        \   * Bit 7 clear = do not quit the game
                        \
                        \   * Bit 7 set = quit the game

.secretCodeChecks

 EQUB 0                 \ Bits 1 to 4 store the results of checking each of the
                        \ four two-digit numbers in a landscape's secret entry
                        \ code
                        \
                        \ A set bit indicates a match while a clear bit
                        \ indicates a failure

 EQUB 0                 \ This byte appears to be unused

.boulderOnTile

 EQUB 0                 \ A flag to record whether the tile being analysed in
                        \ the GetTileAltitude routine contains a boulder
                        \
                        \   * Bit 7 clear = tile does not contain a boulder
                        \
                        \   * Bit 7 set = tile contains a boulder

.L0C68

 EQUB 0                 \ ???

.bufferColumns

 EQUB 0                 \ The number of character columns in the current screen
                        \ buffer

.L0C6A

 EQUB 0                 \ ???

.objectStackCounter

 EQUB 0                 \ A counter for the objects in an object stack, for use
                        \ when drawing the stack

.topObjectOnStack

 EQUB 0                 \ The number of the object on the top of an object stack

.L0C6D

 EQUB 0                 \ ???

.L0C6E

 EQUB 0                 \ Another bit 7 flag ???

.numberOfEnemies

 EQUB 0                 \ The number of enemies in the current landscape,
                        \ including the Sentinel (in the range 1 to 8)

.noteCounter

 EQUB 0                 \ Storage for the sound counter for an individual note
                        \ while playing chords in the music player

.doNotPlayLandscape

 EQUB 0                 \ A flag that controls whether we preview and play the
                        \ landscape after generating it
                        \
                        \   * Bit 7 clear = preview and play the landscape
                        \
                        \   * Bit 7 set = do not preview or play the landscape
                        \
                        \ This allows us to generate a landscape and its secret
                        \ code without actually playing it, which we need to do
                        \ in two cases:
                        \
                        \   * When the player enters an incorrect secret code
                        \
                        \   * When displaying a landscape's secet code after the
                        \     level is completed
                        \
                        \ In both cases we need to generate the landscape before
                        \ we can check or display the secret code, but we don't
                        \ want to go on to preview or play the landscape
                        \
                        \ This variable is reset to zero by the ResetVariables
                        \ routine, so when a new game starts the default
                        \ behaviour is to preview and play the landscape after
                        \ generating it in the GenerateLandscape routine

.gamePaused

 EQUB 0                 \ A flag to record whether the game is paused
                        \
                        \   * Bit 7 clear = the game is not paused
                        \
                        \   * Bit 7 set = the game is paused

.soundEffect

 EQUB 0                 \ Determines how the current sound is processed by the
                        \ ProcessSound routine
                        \
                        \   * 0 = no processing required
                        \
                        \   * 3 = music
                        \
                        \   * 4 = scanner sound effect ???
                        \
                        \   * 6 = game over sound effect

.gameOverSoundPitch

 EQUB 0                 \ A timer for the game over sound
                        \
                        \ Sound is made in ProcessSound when the timer is 80 or
                        \ higher, and it starts at 250 in ShowGameOverScreen and
                        \ decrements in ProcessSound until it dips below 80, at
                        \ which point the sound stops

.alteredSeed

 EQUB 0                 \ An altered version of the anti-cracker seed-related
                        \ data that gets created in AlterCrackerSeed and checked
                        \ in CheckCreckerSeed as part of the anti-cracker code

.L0C76

 EQUB 0                 \ ???

 EQUB 0                 \ This byte appears to be unused

.xTitleOffset

 EQUB 239               \ An x-coordinate offset for drawing the title screen
                        \ this is zero during gameplay)

 EQUB 0                 \ This byte appears to be unused

.blendPolygonEdges

 EQUB &AA               \ A flag to determine whether polygon edges are drawn
                        \ in the same colour as the polygon fill, thus blending
                        \ the edges into the polygon body
                        \
                        \   * Bit 7 set = draw edges in the fill colour so they
                        \                 blend with the polygon body
                        \
                        \   * Bit 7 clear = draw edges in the edge colour

.seedNumberLFSR

 EQUB 0                 \ A five-byte linear feedback shift register for
 EQUB 0                 \ generating a sequence of seed numbers for each
 EQUB 1                 \ landscape
 EQUB 0
 EQUB 0

.enemyData1

 EQUB 0, 0, 0, 0        \ ???
 EQUB 0, 0, 0, 0

.enemyEnergy

 EQUB 0, 0, 0, 0        \ Energy levels for up to eight enemies (the Sentinel
 EQUB 0, 0, 0, 0        \ and up to seven sentries)

.enemyData3

 EQUB 0, 0, 0, 0        \ ???
 EQUB 0, 0, 0, 0

.enemyData4

 EQUB 0, 0, 0, 0        \ ???
 EQUB 0, 0, 0, 0

.enemyData5

 EQUB 0, 0, 0, 0        \ ???
 EQUB 0, 0, 0, 0

.enemyData6

 EQUB 0, 0, 0, 0        \ ???
 EQUB 0, 0, 0, 0

.enemyData7

 EQUB 0, 0, 0, 0        \ ???
 EQUB 0, 0, 0, 0

.enemyData8

 EQUB 0, 0, 0, 0        \ ???
 EQUB 0, 0, 0, 0

 EQUB 0                 \ ???

.scrollCounter

 EQUB 0                 \ A counter for the number of columns or rows we still
                        \ need to scroll in the player's scrolling landscape
                        \ view when the player pans
                        \
                        \ Scrolling is implemented in the interrupt handler one
                        \ column or row at a time, scrolling one character block
                        \ width or height at each step via the ScrollPlayerView
                        \ routine
                        \
                        \ This counter keeps track of each step, decrementing
                        \ after each column or row is scrolled, so we only
                        \ scroll when scrollCounter is non-zero

.viewScreenAddr

 EQUW &60C0             \ The screen address of the player's scrolling landscape
                        \ view, which is just below the icon and scanner row at
                        \ the top of the screen

.sightsScreenAddr

 EQUW 0                 \ The screen address of the sights

.xSights

 EQUB 0                 \ The pixel x-coordinate of the sights on-screen

.ySights

 EQUB 0                 \ The pixel y-coordinate of the sights on-screen

.sightsInitialMoves

 EQUB 0                 \ Controls the initial movement of the sights over the
                        \ first eight calls to the CheckForKeyPresses routine
                        \
                        \ Movement in the first eight calls is determined by
                        \ the settings of bit 7 to bit 0, where a set bit
                        \ indicates a pause and a clear bit indicates a move

.sightsByteCount

 EQUB 0                 \ The number of screen bytes in the sights pixel byte
                        \ stash that contain the contents of the screen behind
                        \ the sights (so they can be restored to remove the
                        \ sights)

.iconRowAddr

 EQUW &7F80             \ The screen address of the icon and scanner row along
                        \ the top of the screen

.xSightsBrush

 EQUB 0                 \ The x-coordinate of the "brush" that we use to draw
                        \ the sights, relative to the top-left corner of the
                        \ character block containig the top of the sights

.L0CCD

 EQUB 0                 \ ???

.doNotCheckSecret

 EQUB 0                 \ A flag to control whether we perform the secret code
                        \ check that's buried in the GetRowVisibility routine
                        \
                        \   * Bit 7 clear = perform check
                        \
                        \   * Bit 7 set = do not perform check

.L0CCF

 EQUB 0                 \ ???

.L0CD0

 EQUB 0                 \ ???

.numberOfScrolls

 EQUB 0                 \ The total number of scrolls that we need to perform
                        \ for the current panning operation
                        \
                        \ This is used to initialise the value of the scroll
                        \ counter in scrollCounter before we start scrolling

.L0CD2

 EQUB 0                 \ ???

.L0CD3

 EQUB 0                 \ ???

.L0CD4

 EQUB 0                 \ ???

 EQUB 0, 0              \ These bytes appear to be unused

.doNotDrawSights

 EQUB 0                 \ A flag that controls whether we draw the sights in the
                        \ DrawSights routine
                        \
                        \   * Bit 7 clear = draw the sights
                        \
                        \   * Bit 7 set = do not draw the sights

 EQUB 0, 0, 0, 0        \ These bytes appear to be unused

.previousFocus

 EQUB 0                 \ Storage for the previous setting of focusOnKeyAction,
                        \ so we can detect (in the ProcessGameplay routine)
                        \ whether the player is still holding down a pan key
                        \ after we finish scrolling the screen for the previous
                        \ pan

.gazeCanSeeTree

 EQUB 0                 \ A flag to record whether the gaze vector can see a
                        \ tree:
                        \
                        \   * Bit 7 clear = gaze vector cannot see a tree
                        \
                        \   * Bit 7 set = gaze vector can see a tree

.hyperspaceEndsGame

 EQUB 0                 \ Records whether the player performing a hyperspace has
                        \ just ended the game
                        \
                        \   * Bit 7 set = the player has hyperspaced and has
                        \                 ended the game (see bit 6 for the
                        \                 details)
                        \
                        \     Bit 7 clear = the game has not been ended by a
                        \                   hyperspace action
                        \
                        \   * Bit 6 set = the player has won by hyperspacing
                        \                 from the Sentinel's tower
                        \
                        \     Bit 6 clear = the player has run out of energy by
                        \                   trying to hyperspace without being
                        \                   able to create a robot into which
                        \                   they can hyperspace


.soundCounter

 EQUB 0                 \ A counter for the sound currently being made, which
                        \ counts down in the IRQHandler routine at a rate of 50
                        \ times a second
                        \
                        \ When the counter reaches zero, it indicates that the
                        \ sound has finished

 EQUB 0, 0, 0, 0        \ These bytes appear to be unused

.focusOnKeyAction

 EQUB %10000000         \ A flag that determines whether the game should focus
                        \ effort on implementing a key action, such as a pan of
                        \ the landscape view
                        \
                        \   * Bit 7 clear = run everything normally
                        \
                        \   * Bit 7 set = focus effort on the key action
                        \
                        \ Specifically, setting bit 7 disables the following
                        \ keyboard scans:
                        \
                        \   * Volume keys in ProcessVolumeKeys
                        \
                        \   * Game key presses in IRQHandler
                        \
                        \   * Game key presses in ProcessGameplay
                        \
                        \ This speeds things up so the action can be implemented
                        \ more quickly and without having to run unnecessary
                        \ keyboard scans

.activateSentinel

 EQUB %10000000         \ A flag to record when the Sentinel is activated at the
                        \ start of the game (by the player pressing a key that
                        \ expends or absorbs energy
                        \
                        \   * Bit 7 clear = the Sentinel is activated
                        \
                        \   * Bit 7 set = the Sentinel is not yet activated
                        \
                        \ This gives the player time to get their bearings when
                        \ they first start a landscape

.playerIsOnTower

 EQUB 128               \ A flag to record whether the player is on top of the
                        \ the Sentinel's tower
                        \
                        \   * 6 = the player is on top of the Sentinel's tower
                        \
                        \   * Any other value = the player is not on top of the
                        \                       Sentinel's tower
                        \
                        \ This value is used when generating the secret code on
                        \ completion of a level, where an incorrect value will
                        \ corrupt the code (so this forms part of the cracker
                        \ protection code)

.musicCounter

 EQUB %10000000         \ A counter for the music currently being made, which
                        \ counts up in the ProcessMusic routine while the music
                        \ is being played
                        \
                        \ If bit 7 is set then there is no music being played

.keyLogger

 EQUB &80, &80          \ The four-byte key logger for logging game key presses
 EQUB &80, &80

 EQUB &80, &80          \ These bytes appear to be unused
 EQUB &80, &80

.inputBuffer

 EQUB 0, 0, 0, 0        \ The eight-byte keyboard input buffer
 EQUB 0, 0, 0, 0        \
                        \ Key presses are stored in the input buffer using an
                        \ ascending stack, with new input being pushed into
                        \ inputBuffer, and any existing content in the buffer
                        \ moving up in memory

 EQUB 0, 0, 0, 0        \ These bytes appear to be unused

.gameInProgress

 EQUB %11000000         \ Flags whether or not a game is in progress (i.e. the
                        \ player is playing a landscape rather than interacting
                        \ with the title and preview screens)
                        \
                        \   * Bit 7 clear = game is in progress
                        \
                        \   * Bit 7 set = game is not in progress
                        \
                        \ This controls whether or not the interrupt handler
                        \ updates the game

.landscapeNumberLo

 EQUB 0                 \ The low byte of the four-digit binary coded decimal
                        \ landscape number (0000 to 9999)

.landscapeNumberHi

 EQUB 0                 \ The high byte of the four-digit binary coded decimal
                        \ landscape number (0000 to 9999)

 EQUB 0                 \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: NMIHandler
\       Type: Subroutine
\   Category: Setup
\    Summary: The NMI handler at the start of the NMI workspace
\
\ ******************************************************************************

.NMIHandler

 RTI                    \ This is the address of the current NMI handler, at
                        \ the start of the NMI workspace at address &0D00
                        \
                        \ We put an RTI instruction here to make sure we return
                        \ successfully from any NMIs that call this workspace

\ ******************************************************************************
\
\       Name: irq1Address
\       Type: Variable
\   Category: Main game loop
\    Summary: Stores the previous value of IRQ1V before we install our custom
\             IRQ handler
\
\ ******************************************************************************

.irq1Address

 EQUW &DC93             \ This value is workspace noise and has no meaning

\ ******************************************************************************
\
\       Name: Multiply8x8
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate (A T) = T * U
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of two unsigned 8-bit numbers:
\
\   (A T) = A * U
\
\ This routine is from Revs, Geoff Crammond's previous game.
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   X is unchanged
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   Multiply8x8+2       Calculate (A T) = T * U
\
\ ******************************************************************************

.Multiply8x8

 STA T                  \ Set T = A

                        \ We now calculate (A T) = T * U
                        \                        = A * U

 LDA #0                 \ Set A = 0 so we can start building the answer in A

 LSR T                  \ Set T = T >> 1
                        \ and C flag = bit 0 of T

                        \ We are now going to work our way through the bits of
                        \ T, and do a shift-add for any bits that are set,
                        \ keeping the running total in A, and instead of using a
                        \ loop, we unroll the calculation, starting with bit 0

 BCC P%+5               \ If C (i.e. the next bit from T) is set, do the
 CLC                    \ addition for this bit of T:
 ADC U                  \
                        \   A = A + U

 ROR A                  \ Shift A right to catch the next digit of our result,
                        \ which the next ROR sticks into the left end of T while
                        \ also extracting the next bit of T

 ROR T                  \ Add the overspill from shifting A to the right onto
                        \ the start of T, and shift T right to fetch the next
                        \ bit for the calculation into the C flag

 BCC P%+5               \ Repeat the shift-and-add loop for bit 1
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 2
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 3
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 4
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 5
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 6
 CLC
 ADC U
 ROR A
 ROR T

 BCC P%+5               \ Repeat the shift-and-add loop for bit 7
 CLC
 ADC U
 ROR A
 ROR T

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetAngleFromCoords (Part 1 of 3)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Given the coordinates along two axes, calculate the pitch or yaw
\             angle to those coordinates
\
\ ------------------------------------------------------------------------------
\
\ The first part of this routine is based on the Divide16x16 routine in Revs,
\ Geoff Crammond's previous game, except it supports a divisor (V W) instead of
\ (V 0), though only the top three bits of W are included in the calculation.
\
\ The calculation is as follows:
\
\   (angleHi angleLo) = arctan( (A T) / (V W) )
\
\ where (A T) < (V W).
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   (A T)               First coordinate as an unsigned integer
\
\   (V W)               Second coordinate as an unsigned integer
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   (angleHi angleLo)   The pitch or yaw angle from the origin to the coordinate
\
\   angleTangent        Contains 256 * (A T) / (V W), which is the tangent of
\                       the pitch or yaw angle
\
\ ******************************************************************************

.GetAngleFromCoords

                        \ We start by calculating the following using a similar
                        \ shift-and-subtract algorithm as Revs:
                        \
                        \   T = 256 * (A T) / (V W)
                        \
                        \ In Revs, W is always zero, so there is some extra code
                        \ below to cater for a full 16-bit value in (V W)

 ASL T                  \ Shift T left, which clears bit 0 of T, ready for us to
                        \ start building the result in T at the same time as we
                        \ shift the low byte of (A T) out to the left

                        \ We now repeat the following seven-instruction block
                        \ eight times, one for each bit in T

 ROL A                  \ Shift the high byte of (A T) to the left to extract
                        \ the next bit from the number being divided

 BCS gang1              \ If we just shifted a 1 out of A, skip the next few
                        \ instructions and jump straight to the subtraction

 CMP V                  \ If A < V then jump to gang2 with the C flag clear, so
 BCC gang2              \ we shift a 0 into the result in T

                        \ This part of the routine has been added to the Revs
                        \ algorithm to cater for both arguments being full
                        \ 16-bit values (in Revs the second value always has a
                        \ low byte of zero)

 BNE gang1              \ If A > V then jump to gang1 to calculate a full 16-bit
                        \ subtraction

                        \ If we get here then A = V

 LDY T                  \ If T < W then jump to gang2 with the C flag clear, so
 CPY W                  \ we shift a 0 into the result in T
 BCC gang2

.gang1

                        \ If we get here then T >= W and A >= V, so we know that
                        \ (A T) >= (V W)
                        \
                        \ We now calculate (A T) - (V W) as the subtraction part
                        \ of the shift-and-subtract algorithm

 STA U                  \ Store A in U so we can retrieve it after the following
                        \ calculation

 LDA T                  \ Subtract the low bytes as T = T - W
 SBC W                  \
 STA T                  \ This calculation works as we know the C flag is set,
                        \ as we passed through a BCC above

 LDA U                  \ Restore the value of A from before the subtraction

 SBC V                  \ Subtract the high bytes as A = A - V

 SEC                    \ Set the C flag so we shift a 1 into the result in T

.gang2

 ROL T                  \ Shift the result in T to the left, pulling the C flag
                        \ into bit 0

 ROL A                  \ Repeat the 16-bit shift-and-subtract loop for the
 BCS gang3              \ second shift
 CMP V
 BCC gang4
 BNE gang3
 LDY T
 CPY W
 BCC gang4

.gang3

 STA U                  \ Repeat the 16-bit subtraction for the second shift
 LDA T
 SBC W
 STA T
 LDA U
 SBC V
 SEC

.gang4

 ROL T                  \ Shift the result for the second shift into T

 ROL A                  \ Repeat the 16-bit shift-and-subtract loop for the
 BCS gang5              \ third shift
 CMP V
 BCC gang6
 BNE gang5
 LDY T
 CPY W
 BCC gang6

.gang5

 STA U                  \ Repeat the 16-bit subtraction for the third shift
 LDA T
 SBC W
 STA T
 LDA U
 SBC V
 SEC

.gang6

 PHP                    \ Store the C flag on the stack, so the stack contains
                        \ the result bit from shifting and subtracting the third
                        \ shift

 CMP V                  \ If A = V then jump to gang10 with the C flag set, as
 BEQ gang10             \ we can skip the rest of the shifts and still get a
                        \ good result ???

 ASL T                  \ Shift a zero for the third shift into T, so bit 5 of
                        \ the result is always clear
                        \
                        \ We do this so we can set this bit later, depending on
                        \ the value that we stored on the stack above

 ROL A                  \ Repeat the shift-and-subtract loop for the fourth
 BCS P%+6               \ shift
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

 ROL A                  \ Repeat the shift-and-subtract loop for the fifth shift
 BCS P%+6
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

 ROL A                  \ Repeat the shift-and-subtract loop for the sixth shift
 BCS P%+6
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

 ROL A                  \ Repeat the shift-and-subtract loop for the seventh
 BCS P%+6               \ shift
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

 ROL A                  \ Repeat the shift-and-subtract loop for the eighth
 BCS P%+6               \ shift
 CMP V
 BCC P%+5
 SBC V
 SEC
 ROL T

                        \ We now have the division result that we want:
                        \
                        \   T = 256 * (A T) / (V W)
                        \
                        \ but with bit 5 clear rather than the actual result
                        \
                        \ This result can be used to look up the resulting angle
                        \ from the arctangent table, but first we continue the
                        \ division to enable us to improve accuracy

\ ******************************************************************************
\
\       Name: GetAngleFromCoords (Part 2 of 3)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Overflow and accuracy calculations
\
\ ******************************************************************************

                        \ We now do two more shift-and-subtracts to see if we
                        \ can should make the result more accurate in part 3
                        \ with interpolation and rounding

 ROL A                  \ Repeat the shift-and-subtract loop for the ninth
 BCS P%+6               \ shift, but without updating the result in T
 CMP V
 BCC P%+5
 SBC V
 SEC

 ROR G                  \ Shift the carry into bit 7 of G, so it contains the
                        \ result from shifting and subtracting bit 8

 ROL A                  \ Repeat the shift-and-subtract loop for the tenth
 BCS gang7              \ shift, but without subtracting or updating the result
 CMP V                  \ in T

.gang7

 ROR G                  \ Shift the carry into bit 7 of G, so it contains the
                        \ result from shifting and subtracting the tenth shift,
                        \ and the result from the ninth shift is now in bit 6
                        \ of G
                        \
                        \ So G now contains two results bits as follows:
                        \
                        \   * Bit 6 is the first extra bit from the result,
                        \     and if it is set then we apply interpolation to
                        \     the result in part 3
                        \
                        \   * Bit 7 is the second extra bit from the result,
                        \     and if it is set then we apply rounding to the
                        \     result in part 3
                        \
                        \ We use these below to work out whether to interpolate
                        \ results from the arctan lookup table, to improve the
                        \ accuracy of the result

 LDA T                  \ Set A to the result of the division we did above, so
                        \ we now have the following:
                        \
                        \   A = 256 * (A T) / (V W)
                        \
                        \ but with bit 5 clear rather than the actual result
                        \ and the next two result bits in bits 6 and 7 of Q

.gang8

                        \ We now use the result of the third shift of the
                        \ shift-and-subtract calculation to set bit 5 in the
                        \ result, which we cleared in the calculation above

 PLP                    \ Retrieve the result bit from the third shift, which
                        \ we stored on the stack in part 1
                        \
                        \ This bit repesents the third bit pushed into the
                        \ result, so that's what should be bit 5 of the result
                        \
                        \ It is now in the C flag (because it was in the C flag
                        \ when we performed the PHP to push it onto the stack)

 BCC gang9              \ If the C flag is clear then bit 5 of the result should
                        \ remain clear, so skip the following

                        \ Otherwise bit 5 of the result should be set, which we
                        \ can do with the following addition (in which we know
                        \ that the C flag is set, as we just passed through a
                        \ BCC instruction)

 ADC #%00100000 - 1     \ Set A = A + %00100000 - 1 + C
                        \       = A + %00100000
                        \
                        \ If we get here having done all ten shifts, then we
                        \ know that bit 5 of the result in A is clear, as we
                        \ cleared it with the ASL T instruction just after gang6
                        \ above, so this just sets bit 5 of the result in A
                        \ without any risk of the addition overflowing
                        \
                        \ If, however, we get here by aborting the sequence of
                        \ shifts after the second shift and jumping to gang10,
                        \ then we have already set bit 5 of the result with an
                        \ ORA instruction in gang10 before jumping back to
                        \ gang8, so there is a possibility for this addition to
                        \ overflow ???

.gang9

 BCC gang11             \ If the above addition was skipped, or it was applied
                        \ and didn't overflow, then jump to gang11 to continue
                        \ with the calculation

                        \ If we get here then the above addition overflowed, so
                        \ we return the highest angle possible from the table,
                        \ which is 45 degrees

 LDA #255               \ Set angleTangent = 255, which is the closest we can
 STA angleTangent       \ get to the tangent of 45 degrees, which should really
                        \ be represented by (1 0) in our scale

 LDA #&00               \ Set (angleHi angleLo) = (&20 0)
 STA angleLo            \
 LDA #&20               \ This represents an angle of 45 degrees, as a full
 STA angleHi            \ circle of 360 degrees is represented by (1 0 0), and:
                        \
                        \   360 degrees / 8 = 45
                        \
                        \   256 / 8 = &20

 RTS                    \ Return from the subroutine

.gang10

                        \ If we get here then we have stopped shifting and
                        \ subtracting after just three shifts
                        \
                        \ We stored the first two shifts in T, but didn't store
                        \ the third shift in T

 LDA #0                 \ Clear bits 6 and 7 of G to indicate that we should not
 STA G                  \ apply interpolation or rounding in part 3

 ROR T                  \ Set A to the bottom two bits of T, which is the same
 ROR A                  \ result as if we had shifted T left through the rest of
 ROR T                  \ the shift-and-subtract process that we've skipped
 ROR A

 ORA #%00100000         \ Set bit 5 of the result in A ???
                        \
                        \ So we now have the result of the division in A

 JMP gang8              \ Jump to gang8 to continue the processing from the end
                        \ of the division process

\ ******************************************************************************
\
\       Name: GetAngleFromCoords (Part 3 of 3)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the arctangent to get the angle
\
\ ******************************************************************************

.gang11

                        \ By this point we have calculated the following:
                        \
                        \   A = 256 * (A T) / (V W)
                        \
                        \ so now we calculate arctan(A)

 TAY                    \ Set Y to the value of A so we can use it as an index
                        \ into the arctan tables

 STA angleTangent       \ Set angleTangent = 256 * (A T) / (V W)
                        \
                        \ So we return the tangent from the routine in
                        \ angleTangent

 LDA arctanLo,Y         \ Set (angleHi angleLo) = arctan(Y)
 STA angleLo
 LDA arctanHi,Y
 STA angleHi

                        \ We now improve the accuracy of this result by applying
                        \ interpolation and rounding, but only if one of bit 6
                        \ or bit 7 is set in G

 BIT G                  \ If bit 7 of G is set, jump to gang12 to calculate
 BMI gang12             \ a value in (U T) that we can then use for rounding up
                        \ the result of the interpolation

 BVS gang14             \ If bit 7 of G is clear and bit 6 of G is set, jump to
                        \ gang14 to interpolate the result with the next entry
                        \ in the arctan table, without using rounding

 JMP gang16             \ Otherwise both bit 7 and bit 6 of G must be clear, so
                        \ jump to gang16 to return from the subroutine, as the
                        \ result in (angleHi angleLo) is already accurate and
                        \ doesn't need interpolating

.gang12

                        \ If we get here then we need to apply rounding to the
                        \ result as well as interpolating the result between
                        \ arctan(Y) and arctan(Y + 1)

 LDA angleLo            \ Set (A T) = (angleHi angleLo) - arctan(Y + 1)
 SEC                    \           = arctan(Y) - arctan(Y + 1)
 SBC arctanLo+1,Y       \
 STA T                  \ So (A T) contains the amount of rounding we need to
 LDA angleHi            \ add to the result (the result is divided by two below)
 SBC arctanHi+1,Y

 BIT G                  \ If bit 6 of G is set, negate (A T) to give the correct
 BVC gang13             \ sign to the amount of rounding
 JSR Negate16Bit

.gang13

 STA U                  \ Set (U T) = (A T)
                        \           = arctan(Y) - arctan(Y + 1)

 ROL A                  \ Set the C flag to bit 7 of A, which is the top bit of
                        \ (U T), so the next instruction rotates the correct
                        \ bit into bit 7 of U to retain the sign of the result

 ROR U                  \ Set (U T) = (U T) / 2
 ROR T                  \           = arctan(Y) - arctan(Y + 1)
                        \
                        \ So (U T) contains half the difference between
                        \ arctan(Y) and arctan(Y + 1)
                        \
                        \ This is effectively half the difference between the
                        \ two values, so this is the equivalent of the 0.5 in
                        \ INT(x + 0.5) when rounding x to the nearest integer,
                        \ just with the arctan results in our calculation

.gang14

                        \ If we get here then we need to interpolate the result
                        \ between arctan(Y) and arctan(Y + 1)

 LDA angleLo            \ Set (angleHi angleLo) = (angleHi angleLo)
 CLC                    \                                        + arctan(Y + 1)
 ADC arctanLo+1,Y       \                       = arctan(Y) and arctan(Y + 1)
 STA angleLo            \
 LDA angleHi            \ We will divide this value by two to get the average
 ADC arctanHi+1,Y       \ of arctan(Y) and arctan(Y + 1), but first we need to
 STA angleHi            \ add the rounding in (U T), if applicable

 BIT G                  \ If bit 7 of G is clear, jump to gang15 to skip the
 BPL gang15             \ following, as the rounding in (U T) is only applied
                        \ when bit 7 of G is set

                        \ If we get here then bit 7 of G is set and we need to
                        \ add on the rounding in (U T)

 LDA angleLo            \ Set (angleHi angleLo) = (angleHi angleLo) + (U T)
 CLC
 ADC T
 STA angleLo
 LDA angleHi
 ADC U
 STA angleHi

.gang15

 LSR angleHi            \ Set (angleHi angleLo) = (angleHi angleLo) / 2
 ROR angleLo            \
                        \ So we now have the average value of arctan(Y) and
                        \ arctan(Y + 1), including rounding if applicable, so
                        \ the result has now been interpolated for more accuracy

.gang16

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetRotationMatrix (Part 1 of 5)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the rotation matrix for rotating the pitch or yaw angle
\             for the sights into the global 3D coordinate system
\
\ ------------------------------------------------------------------------------
\
\ This routine is used to calculate the following:
\
\   sinAngle = sin(vectorPitchAngle)
\   cosAngle = cos(vectorPitchAngle)
\
\ or:
\
\   sinAngle = sin(vectorYawAngle)
\   cosAngle = cos(vectorYawAngle)
\
\ We can use these to convert the pitch and yaw angles of the vector from the
\ player's eyes to the sights into a cartesian vector within the 3D world.
\
\ This routine is from Revs, Geoff Crammond's previous game. There are only
\ minor differences: the argument is (A T) instead of (A X), and the value of X
\ is preserved. Note that to avoid clashing names, the variables G and H have
\ been renamed to G2 and H2, but the routine is otherwise the same.
\
\ For the calculations in The Sentinel we don't need a full rotation matrix,
\ but the Revs routine calculates the values that we do need, as mentioned
\ above. I could have renamed this routine for The Sentinel to something like
\ GetSinAndCos16, as all it does is calculate the sine and cosine to 16-bit
\ accuracy, but I've left the Revs code alone as much as possible to show the
\ influence of Geoff Crammond's previous game.
\
\ Also, because this routine comes from Revs, where it is only used to rotate
\ through the driver's yaw angle, I have renamed the result variables from
\ sinYawAngle and cosYawAngle to sinAngle and cosAngle, as The Sentinel uses
\ the routine to rotate through both yaw angles and pitch angles. To keep things
\ simple the commentary still refers to yaw angles, but the calculations apply
\ equally to pitch angles.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   (A T)               The pitch or yaw angle to encapsulate in the rotation
\                       matrix
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   X is preserved
\
\ ******************************************************************************

.GetRotationMatrix

 STA J                  \ Set (J T) = (A T)
                        \           = vectorYawAngle or vectorPitchAngle
                        \
                        \ Note that because this routine is copied almost
                        \ verbatim from Revs, the commentary only refers to yaw
                        \ angles, but this routine can work just as well with
                        \ pitch angles as arguments

 STX xStoreMatrix       \ Store X in xStoreMatrix so it can be preserved across
                        \ calls to the routine

 JSR GetAngleInRadians  \ Set (U A) to the vectorYawAngle, reduced to a quarter
                        \ circle, converted to radians, and halved
                        \
                        \ Let's call this yawRadians / 2, where yawRadians is
                        \ the reduced player yaw angle in radians

 STA G2                 \ Set (U G) = (U A) = yawRadians / 2

 LDA U                  \ Set (A G) = (U G) = yawRadians / 2

 STA H2                 \ Set (H G) = (A G) = yawRadians / 2

                        \ So we now have:
                        \
                        \   (H G) = (A G) = (U G) = yawRadians / 2
                        \
                        \ This is the angle vector that we now project onto the
                        \ x- and z-axes of the world 3D coordinate system

 LDX #1                 \ Set X = 0 and secondAxis = 1, so we project sin(H G)
 STX secondAxis         \ into sinAngle and cos(H G) into cosAngle
 LDX #0

 BIT J                  \ If bit 6 of J is clear, then vectorYawAngle is in one
 BVC rotm1              \ of these ranges:
                        \
                        \   * 0 to 63 (%00000000 to %00111111)
                        \
                        \   * -128 to -65 (%10000000 to %10111111)
                        \
                        \ The degree system in the Sentinel looks like this:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of player
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ So vectorYawAngle is in the top-right or bottom-left
                        \ quarter in the above diagram
                        \
                        \ In both cases we jump to rotm1 to set sinAngle and
                        \ cosAngle

                        \ If we get here then bit 6 of J is set, so
                        \ vectorYawAngle is in one of these ranges:
                        \
                        \   * 64 to 127 (%01000000 to %01111111)
                        \
                        \   * -64 to -1 (%11000000 to %11111111)
                        \
                        \ So vectorYawAngle is in the bottom-right or top-left
                        \ quarter in the above diagram
                        \
                        \ In both cases we set the variables the other way
                        \ round, as the triangle we draw to calculate the angle
                        \ is the opposite way round (i.e. it's reflected in the
                        \ x-axis or y-axis)

 INX                    \ Set X = 1 and secondAxis = 0, so we project sin(H G)
 DEC secondAxis         \ into cosAngle and cos(H G) into sinAngle

                        \ We now enter a loop that sets sinAngle + X to
                        \ sin(H G) on the first iteration, and sets
                        \ sinAngle + secondAxis to cos(H G) on the second
                        \ iteration
                        \
                        \ The commentary is for the sin(H G) iteration, see the
                        \ end of the loop for details of how the second
                        \ iteration calculates cos(H G) instead

.rotm1

                        \ If we get here, then we are set up to calculate the
                        \ following:
                        \
                        \   * If vectorYawAngle is top-right or bottom-left:
                        \
                        \     sinAngle = sin(vectorYawAngle)
                        \     cosAngle = cos(vectorYawAngle)
                        \
                        \   * If vectorYawAngle is bottom-right or top-left:
                        \
                        \     sinAngle = cos(vectorYawAngle)
                        \     cosAngle = sin(vectorYawAngle)
                        \
                        \ In each case, the calculation gives us the correct
                        \ coordinate, as the second set of results uses angles
                        \ that are "reflected" in the x-axis or y-axis by the
                        \ capping process in the GetAngleInRadians routine

 CMP #122               \ If A < 122, i.e. U < 122 and H < 122, jump to rotm2
 BCC rotm2              \ to calculate sin(H G) for smaller angles

 BCS rotm3              \ Jump to rotm3 to calculate sin(H G) for larger angles
                        \ (this BCS is effectively a JMP as we just passed
                        \ through a BCS)

 LDA G2                 \ It doesn't look like this code is ever reached, so
 CMP #240               \ presumably it's left over from development
 BCS rotm3

\ ******************************************************************************
\
\       Name: GetRotationMatrix (Part 2 of 5)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate sin(H G) for smaller angles
\
\ ******************************************************************************

.rotm2

                        \ If we get here then (U G) = yawRadians / 2 and U < 122

 LDA #171               \ Set A = 171

 JSR Multiply8x8        \ Set (A T) = (A * U) * U
 JSR Multiply8x8        \           = A * U^2
                        \           = 171 * (yawRadians / 2)^2

 STA V                  \ Set (V T) = (A T)
                        \           = 171 * (yawRadians / 2)^2

 JSR Multiply8x16       \ Set (U T) = U * (V T) / 256
                        \           = (171 / 256) * (yawRadians / 2)^3
                        \           = 2/3 * (yawRadians / 2)^3

 LDA G2                 \ Set (A T) = (H G) - (U T)
 SEC                    \           = yawRadians / 2 - 2/3 * (yawRadians / 2)^3
 SBC T                  \
 STA T                  \ starting with the low bytes

 LDA H2                 \ And then the high bytes
 SBC U

 ASL T                  \ Set (A T) = (A T) * 2
 ROL A

                        \ So we now have the following in (A T):
                        \
                        \     (yawRadians / 2 - 2/3 * (yawRadians / 2)^3) * 2
                        \
                        \   = yawRadians - 4/3 * (yawRadians / 2)^3
                        \
                        \   = yawRadians - 4/3 * yawRadians^3 / 2^3
                        \
                        \   = yawRadians - 8/6 * yawRadians^3 * 1/8
                        \
                        \   = yawRadians - 1/6 * yawRadians^3
                        \
                        \   = yawRadians - yawRadians^3 / 3!
                        \
                        \ The Taylor series expansion of sin(x) starts like
                        \ this:
                        \
                        \   sin(x) = x - (x^3 / 3!) + (x^5 / 5!) - ...
                        \
                        \ If we take the first two parts of the series and
                        \ apply them to yawRadians, we get:
                        \
                        \   sin(yawRadians) = yawRadians - (yawRadians^3 / 3!)
                        \
                        \ which is the same as our value in (A T)
                        \
                        \ So the value in (A T) is equal to the first two parts
                        \ of the Taylor series, and we have effectively just
                        \ calculated an approximation of this:
                        \
                        \   (A T) = sin(yawRadians)

 STA sinAngleHi,X       \ Set (sinAngleHi sinAngleLo) = (A T)
 LDA T                  \
 AND #%11111110         \ with the sign bit cleared in bit 0 of sinAngleLo to
 STA sinAngleLo,X       \ denote a positive result

 JMP rotm5              \ Jump to rotm5 to move on to the next axis

\ ******************************************************************************
\
\       Name: GetRotationMatrix (Part 3 of 5)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate sin(H G) for bigger angles
\
\ ******************************************************************************

.rotm3

                        \ If we get here then (H G) = yawRadians / 2 and
                        \ H >= 122

                        \ PI is represented by 804, as 804 / 256 = 3.14, so 201
                        \ represents PI/4, which we use in the following
                        \ subtraction

 LDA #0                 \ Set (U T) = (201 0) - (H G)
 SEC                    \           = PI/4 - yawRadians / 2
 SBC G2                 \
 STA T                  \ starting with the low bytes

 LDA #201               \ And then the high bytes
 SBC H2
 STA U

 STA V                  \ Set (V T) = (U T)
                        \           = PI/4 - yawRadians / 2

 JSR Multiply8x16       \ Set (U T) = U * (V T) / 256
                        \           = U * (PI/4 - yawRadians / 2)
                        \
                        \ U is the high byte of (U T), which also contains
                        \ PI/4 - yawRadians / 2, so this approximation holds
                        \ true:
                        \
                        \   (U T) = U * (PI/4 - yawRadians / 2)
                        \         =~ (PI/4 - yawRadians / 2) ^ 2

 ASL T                  \ Set (U T) = (U T) * 2
 ROL U                  \           = (PI/4 - yawRadians / 2) ^ 2 * 2

                        \ By this point we have the following:
                        \
                        \   (U T) = (PI/4 - yawRadians / 2) ^ 2 * 2
                        \         = ((PI/2 - yawRadians) / 2) ^ 2 * 2
                        \
                        \ If we define x = PI/2 - yawRadians, then we have:
                        \
                        \   (U T) = (x / 2) ^ 2 * 2
                        \         = ((x ^ 2) / (2 ^ 2)) * 2
                        \         = (x ^ 2) / 2
                        \
                        \ The small angle approximation states that for small
                        \ values of x, the following approximation holds true:
                        \
                        \   cos(x) =~ 1 - (x ^ 2) / 2!
                        \
                        \ As yawRadians is large, this means x is small, so we
                        \ can use this approximation
                        \
                        \ We are storing the cosine, which is in the range 0 to
                        \ 1, in the 16-bit variable (U T), so in terms of 16-bit
                        \ arithmetic, the 1 in the above equation is (1 0 0)
                        \
                        \ So this is the same as:
                        \
                        \   cos(x) =~ (1 0 0) - (x ^ 2) / 2!
                        \          =  (1 0 0) - (U T)
                        \
                        \ It's a trigonometric identity that:
                        \
                        \   cos(PI/2 - x) = sin(x)
                        \
                        \ so we have:
                        \
                        \   cos(x) = cos(PI/2 - yawRadians)
                        \          = sin(yawRadians)
                        \
                        \ and we already calculated that:
                        \
                        \   cos(x) =~ (1 0 0) - (U T)
                        \
                        \ so that means that:
                        \
                        \   sin(yawRadians) = cos(x)
                        \                   =~ (1 0 0) - (U T)
                        \
                        \ So we just need to calculate (1 0 0) - (U T) to get
                        \ our result

 LDA #0                 \ Set A = (1 0 0) - (U T)
 SEC                    \
 SBC T                  \ starting with the low bytes

 AND #%11111110         \ Which we store in sinAngleLo, with bit 0 cleared to
 STA sinAngleLo,X       \ denote a positive result (as it's a sign-magnitude
                        \ number we want to store)

 LDA #0                 \ And then the high bytes
 SBC U

 BCC rotm4              \ We now need to subtract the top bytes, i.e. the 1 in
                        \ (1 0 0) and the 0 in (0 U T), while including the
                        \ carry from the high byte subtraction
                        \
                        \ So the top byte should be:
                        \
                        \   A = 1 - 0 - (1 - C)
                        \     = 1 - (1 - C)
                        \     = C
                        \
                        \ If the C flag is clear, then that means the top byte
                        \ is zero, so we already have a valid result from the
                        \ high and low bytes, so we jump to rotm4 to store the
                        \ high byte of the result in sinAngleHi
                        \
                        \ If the C flag is set, then the result is (1 A T), but
                        \ the highest possible value for sin or cos is 1, so
                        \ that's what we return
                        \
                        \ Because sinAngle is a sign-magnitude number with
                        \ the sign bit in bit 0, we return the following value
                        \ to represent the closest value to 1 that we can fit
                        \ into 16 bits:
                        \
                        \   (11111111 11111110)

 LDA #%11111110         \ Set sinAngleLo to the highest possible positive
 STA sinAngleLo,X       \ value (i.e. all ones except for the sign in bit 0)

 LDA #%11111111         \ Set A to the highest possible value of sinAngleHi,
                        \ so we can store it in the next instruction

.rotm4

 STA sinAngleHi,X       \ Store A in the high byte in sinAngleHi

\ ******************************************************************************
\
\       Name: GetRotationMatrix (Part 4 of 5)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Loop back to calculate cos instead of sin
\
\ ******************************************************************************

.rotm5

 CPX secondAxis         \ If we just processed the second axis, then we have
 BEQ rotm6              \ now set both sinAngle and cosAngle, so jump to
                        \ rotm6 to set their signs

 LDX secondAxis         \ Otherwise set X = secondAxis so the next time we reach
                        \ the end of the loop, we take the BEQ branch we just
                        \ passed through

 LDA #0                 \ Set (H G) = (201 0) - (H G)
 SEC                    \
 SBC G2                 \ starting with the low bytes
 STA G2

 LDA #201               \ And then the high bytes
 SBC H2
 STA H2

 STA U                  \ Set (U G) = (H G)
                        \
                        \ (U G) and (H G) were set to yawRadians / 2 for the
                        \ first pass through the loop above, so we now have the
                        \ following:
                        \
                        \   201 - yawRadians / 2
                        \
                        \ PI is represented by 804, as 804 / 256 = 3.14, so 201
                        \ represents PI/4, so this the same as:
                        \
                        \   PI/4 - yawRadians / 2
                        \
                        \ Given that we expect (U G) to contain half the angle
                        \ we are projecting, this means we are going to find the
                        \ sine of this angle when we jump back to rotm1:
                        \
                        \   PI/2 - yawRadians
                        \
                        \ It's a trigonometric identity that:
                        \
                        \   sin(PI/2 - x) = cos(x)
                        \
                        \ so jumping back will, in fact, find the cosine of the
                        \ angle

 JMP rotm1              \ Loop back to set the other variable of sinAngle and
                        \ cosAngle to the cosine of the angle

\ ******************************************************************************
\
\       Name: GetRotationMatrix (Part 5 of 5)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Apply the correct signs to the result
\
\ ******************************************************************************

.rotm6

                        \ By this point, we have the yaw angle vector's
                        \ x-coordinate in sinAngle and the y-coordinate in
                        \ cosAngle
                        \
                        \ The above calculations were done on an angle that was
                        \ reduced to a quarter-circle, so now we need to add the
                        \ correct signs according to which quarter-circle the
                        \ original vectorYawAngle in (J T) was in

 LDA J                  \ If J is positive then vectorYawAngle is positive (as
 BPL rotm7              \ J contains vectorYawAngleHi), so jump to rotm7 to skip
                        \ the following

                        \ If we get here then vectorYawAngle is negative
                        \
                        \ The degree system in the Sentinel looks like this:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of player
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ So vectorYawAngle is in the left half of the above
                        \ diagram, where the x-coordinates are negative, so we
                        \ need to negate the x-coordinate

 LDA #1                 \ Negate sinAngle by setting bit 0 of the low byte,
 ORA sinAngleLo         \ as sinAngle is a sign-magnitude number
 STA sinAngleLo

.rotm7

 LDA J                  \ If bits 6 and 7 of J are the same (i.e. their EOR is
 ASL A                  \ zero), jump to rotm8 to return from the subroutine as
 EOR J                  \ the sign of cosAngle is correct
 BPL rotm8

                        \ Bits 6 and 7 of J, i.e. of vectorYawAngleHi, are
                        \ different, so the angle is in one of these ranges:
                        \
                        \   * 64 to 127 (%01000000 to %01111111)
                        \
                        \   * -128 to -65 (%10000000 to %10111111)
                        \
                        \ The degree system in the Sentinel looks like this:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of player
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ So vectorYawAngle is in the bottom half of the above
                        \ diagram, where the y-coordinates are negative, so we
                        \ need to negate the y-coordinate

 LDA #1                 \ Negate cosAngle by setting bit 0 of the low byte,
 ORA cosAngleLo         \ as cosAngle is a sign-magnitude number
 STA cosAngleLo

.rotm8

 LDX xStoreMatrix       \ Restore the value of X that we stored in xStoreMatrix
                        \ at the start of the routine, so that it's preserved

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: xStoreMatrix
\       Type: Variable
\   Category: Maths (Geometry)
\    Summary: Temporary storage for X so it can be preserved through calls to
\             GetRotationMatrix
\
\ ******************************************************************************

.xStoreMatrix

 EQUB 0

\ ******************************************************************************
\
\       Name: CrackerSeed
\       Type: Subroutine
\   Category: Cracker protection
\    Summary: Obfuscated storage for the high byte of the landscape number as
\             part of the anti-cracker code
\
\ ******************************************************************************

.CrackerSeed

 LDA #0                 \ This instruction is never run but the operand is used
                        \ to hide data as part of the anti-cracker code

\ ******************************************************************************
\
\       Name: GetAngleInRadians
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Convert a 16-bit angle into radians, restricted to a quarter
\             circle
\
\ ------------------------------------------------------------------------------
\
\ This routine is from Revs, Geoff Crammond's previous game.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   (A T)               A yaw angle (-128 to +127)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   (U A)               The angle, reduced to a quarter circle, converted to
\                       radians, and halved
\
\ ******************************************************************************

.GetAngleInRadians

 ASL T                  \ Set (V T) = (A T) << 2
 ROL A                  \
 ASL T                  \ This shift multiplies (A T) by four, removing bits 6
 ROL A                  \ and 7 in the process
 STA V                  \
                        \ The degree system in the Sentinel looks like this:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of player
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ The top byte of (A T) is in this range, so shifting to
                        \ the left by two places drops bits 6 and 7 and scales
                        \ the angle into the range 0 to 252, as follows:
                        \
                        \   * 0 to 63 (%00000000 to %00111111)
                        \     -> 0 to 252 (%00000000 to %11111100)
                        \
                        \   * 64 to 127 (%01000000 to %01111111)
                        \     -> 0 to 252 (%00000000 to %11111100)
                        \
                        \   * -1 to -64 (%11111111 to %11000000)
                        \     -> 252 to 0 (%11111100 to %00000000)
                        \
                        \   * -65 to -128 (%10111111 to %10000000)
                        \     -> 252 to 0 (%11111100 to %00000000)

                        \ We now convert this number from a Revs angle into
                        \ radians
                        \
                        \ The value of (V T) represents a quarter-circle, which
                        \ is PI/2 radians, but we actually multiply by PI/4 to
                        \ return the angle in radians divided by 2, to prevent
                        \ overflow in the GetRotationMatrix routine

 LDA #201               \ Set U = 201
 STA U

                        \ Fall through into Multiply8x16 to calculate:
                        \
                        \   (U A) = U * (V T) / 256
                        \         = 201 * (V T) / 256
                        \         = (201 / 256) * (V T)
                        \         = (3.14 / 4) * (V T)
                        \
                        \ So we return (U A) = PI/4 * (V T)
                        \
                        \ which is the original angle, reduced to a quarter
                        \ circle, converted to radians, and halved

\ ******************************************************************************
\
\       Name: Multiply8x16
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Multiply an 8-bit and a 16-bit number
\
\ ------------------------------------------------------------------------------
\
\ Do the following multiplication of two unsigned numbers:
\
\   (U T) = U * (V T) / 256
\
\ The result is also available in (U A).
\
\ This routine is from Revs, Geoff Crammond's previous game.
\
\ ******************************************************************************

.Multiply8x16

 JSR Multiply8x8+2      \ Set (A T) = T * U

 STA W                  \ Set (W T) = (A T)
                        \           = T * U
                        \
                        \ So W = T * U / 256

 LDA V                  \ Set A = V

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = V * U

 STA U                  \ Set (U T) = (A T)
                        \           = V * U

 LDA W                  \ Set (U T) = (U T) + W
 CLC                    \
 ADC T                  \ starting with the low bytes
 STA T

 BCC mult1              \ And then the high bytes, so we get the following:
 INC U                  \
                        \   (U T) = (U T) + W
                        \         = V * U + (T * U / 256)
                        \         = U * (V + T / 256)
                        \         = U * (256 * V + T) / 256
                        \         = U * (V T) / 256
                        \
                        \ which is what we want

.mult1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ScanKeyboard
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan the keyboard for a specific key press
\
\ ------------------------------------------------------------------------------
\
\ This routine is from Revs, Geoff Crammond's previous game. There is only one
\ minor difference: the value of Y is preserved.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The negative inkey value of the key to scan for (in the
\                       range &80 to &FF)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   Z flag              The result:
\
\                         * Set if the key in X is being pressed, in which case
\                           BEQ will branch
\
\                         * Clear if the key in X is not being pressed, in which
\                           case BNE will branch
\
\   Y                   Y is preserved
\
\ ******************************************************************************

.ScanKeyboard

 TYA                    \ Store Y on the stack so we can preserve it
 PHA

 LDA #129               \ Call OSBYTE with A = 129, Y = &FF and the inkey value
 LDY #&FF               \ in X, to scan the keyboard for key X
 JSR OSBYTE

 PLA                    \ Retrieve Y from the stack so it is unchanged
 TAY

 CPX #&FF               \ If the key in X is being pressed, the above call sets
                        \ both X and Y to &FF, so this sets the Z flag depending
                        \ on whether the key is being pressed (so a BEQ after
                        \ the call will branch if the key in X is being pressed)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetSineAndCosine
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the absolute sine and the cosine of an angle
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   (A T)               The angle, representing a full circle with the range
\                       A = 0 to 255, and T representing the fractional part
\                       (though only bit 7 of T is used)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   sinA                The value of |sin(A)|
\
\   cosA                The value of |cos(A)|
\
\   H                   The quadrant of the angle in bits 6 and 7 ???
\
\ ******************************************************************************

.GetSineAndCosine

 BPL scos1              \ If A is in the range 128 to 255, flip bit 6
 EOR #%01000000         \
                        \ The degree system in the Sentinel looks like this:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of player
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ Bit 7 is set in the left half, so this operation only
                        \ affects angles in that half
                        \
                        \ In the left half, bit 6 is as follows:
                        \
                        \   * -1 to -64 (%11111111 to %11000000)
                        \
                        \   * -65 to -128 (%10111111 to %10000000)
                        \
                        \ so flipping bit 6 effectively swaps the two quarters
                        \ from this:
                        \
                        \            0
                        \      -32   |
                        \         \  |
                        \          \ |
                        \           \|
                        \   -64 -----+
                        \           /|
                        \          / |
                        \         /  |
                        \      -96   |
                        \           128
                        \
                        \ into this:
                        \
                        \           -64
                        \      -96   |
                        \         \  |
                        \          \ |
                        \           \|
                        \   128 -----+
                        \
                        \ and this:
                        \
                        \     0 -----+
                        \           /|
                        \          / |
                        \         /  |
                        \      -32   |
                        \           -64
                        \
                        \ by doing these conversions:
                        \
                        \   * -1 to -64 (%11111111 to %11000000)
                        \     -> -65 to -128 (%10111111 to %10000000)
                        \
                        \   * -65 to -128 (%10111111 to %10000000)
                        \   * -1 to -64 (%11111111 to %11000000)
                        \
                        \ This is the same as rotating the angle through 90
                        \ degrees, which is the same as adding PI/2 to the angle
                        \
                        \ It's a trigonometric identity that:
                        \
                        \   cos(x) = sin(x + PI/2)
                        \
                        \ so this shifts the angle so that when we fetch from
                        \ sine lookup table, we are actually getting the cosine
                        \
                        \ We use this fact below to determine which result to
                        \ return in sinA and cosA after we have done the lookups
                        \ from the sine table

.scos1

 STA H                  \ Store the updated angle argument in H so we can fetch
                        \ bits 6 and 7 from the angle below

 ASL T                  \ Set (A T) = (A T) << 1
 ROL A                  \
                        \ The original argument represents a full circle in the
                        \ range A = 0 to 255, so this reduces that range to a
                        \ half circle with A = 0 to 255, as bit 7 is shifted out
                        \ of the top
                        \
                        \ This effectively drops the left half of the angle
                        \ circle, to leave us with an angle in this range:
                        \
                        \            0
                        \            |   +64
                        \            |  /
                        \            | /
                        \            |/
                        \            +----- +128
                        \            |\
                        \            | \
                        \            |  \
                        \            |   +192
                        \           256

 AND #%01111111         \ Clear bit 6 of the result, so A represents a quarter
                        \ circle in the range 0 to 127
                        \
                        \ This effectively drops the bottom-right quarter of the
                        \ angle circle, to leave us with an angle in this range:
                        \
                        \            0
                        \            |   +64
                        \            |  /
                        \            | /
                        \            |/
                        \            +----- +127
                        \
                        \ So by this point we have discarded bits 6 and 7 of the
                        \ original angle and scaled the angle to be in the range
                        \ 0 to 127, so we can use the result as an index into
                        \ the sine table (which contains 128 values)
                        \
                        \ The sine table only covers angles in the first quarter
                        \ of the circle, which means the result of looking up a
                        \ value from the sine table will always be positive, so
                        \ this will return the absolute value, i.e. |sin(x)|

 TAX                    \ Copy A into X so we can use it as an index to fetch
                        \ the sine of our angle

 EOR #%01111111         \ Negate A using two's complement, leaving bit 7 clear
 CLC                    \
 ADC #1                 \ Because A was in the range 0 to 127 before being
                        \ negated, this is effectively the same as subtracting
                        \ A from 127, like this:
                        \
                        \   A = 127 - X

 BPL scos2              \ If A > 127 then set A = 127, so A is capped to the
 LDA #127               \ range 0 to 127 and is suitable for looking up the
                        \ result from the sine table

.scos2

 TAY                    \ Copy A into Y so we can use it as an index into the
                        \ sine table, so we have the following:
                        \
                        \   Y = 127 - X

                        \ Because our angle is in the first quadrant where 127
                        \ represents a quarter circle of 90 degrees or PI/2
                        \ radians, we can now look up the sine and cosine as
                        \ follows:

 LDA sin,X              \ Set A = sin(X)

 LDX sin,Y              \ Set X = sin(Y)
                        \       = sin(127 - X)
                        \       = sin(PI/2 - X)
                        \
                        \ And because X is in the range 0 to PI/2, we have:
                        \
                        \   X = sin(PI/2 - X)
                        \     = cos(X)

                        \ Because the sine table only contains positive values
                        \ from the first quadrant, this means we have the
                        \ following:
                        \
                        \   A = |sin(X)|
                        \
                        \   X = |cos(X)|
                        \
                        \ We now need to analyse the original angle argument A
                        \ (via bits 6 and 7 of the angle in H) to make sure we
                        \ return the correct result
                        \
                        \ Here's the angle system again:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of player
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ If our original angle argument A is the top-right
                        \ quadrant then the result above will be correct
                        \
                        \ If our original angle argument A is the bottom-right
                        \ quadrant then we can apply the following trigonometric
                        \ identities:
                        \
                        \   sin(A) = sin(X + PI/2)
                        \          = cos(X)
                        \
                        \   cos(A) = cos(X + PI/2)
                        \          = -sin(X)
                        \
                        \ So for the original argument A, we have:
                        \
                        \   |sin(A)| = |cos(X)|
                        \
                        \   |cos(A)| = |-sin(X)|
                        \            = |sin(X)|
                        \
                        \ So it follows that for this angle range, we need to
                        \ return the current value of X for the sine result and
                        \ the current value of A for the cosine result
                        \
                        \ If our original angle argument A is the bottom-left
                        \ quadrant then we can apply the following trigonometric
                        \ identities:
                        \
                        \   sin(A) = sin(X + PI)
                        \          = -sin(X)
                        \
                        \   cos(A) = cos(X + PI)
                        \          = -cos(X)
                        \
                        \ And given that we are returning the absolute value,
                        \ this means for this quadrant, the return values are
                        \ correct
                        \
                        \ If our original angle argument A is the top-left
                        \ quadrant then we can apply the following trigonometric
                        \ identities:
                        \
                        \   sin(A) = sin(X - PI/2)
                        \          = -cos(X)
                        \
                        \   cos(A) = cos(X - PI/2)
                        \          = sin(X)
                        \
                        \ So again we need to return the current value of X for
                        \ the sine result and the current value of A for the
                        \ cosine result
                        \
                        \ In terms of the original angle A, then, we have the
                        \ following:
                        \
                        \   * Top-right quadrant = results are correct
                        \
                        \   * Bottom-right quadrant = swap sin and cos
                        \
                        \   * Bottom-left quadrant = results are correct
                        \
                        \   * Top-left quadrant = swap sin and cos
                        \
                        \ In terms of bits 6 and 7 of H, we swapped the left two
                        \ quadrants, so this means:
                        \
                        \   * Top-right quadrant = both clear
                        \
                        \   * Bottom-right quadrant = bit 7 clear, bit 6 set
                        \
                        \   * Bottom-left quadrant = both set
                        \
                        \   * Top-left quadrant = bit 7 set, bit 6 clear
                        \
                        \ So the return values are correct when bits 6 and 7 are
                        \ either both clear or both set, and we need to swap the
                        \ sine and cosine results if one is set and the other is
                        \ clear

 BIT H                  \ If bit 7 of H is set, jump to scos4
 BMI scos4

                        \ If we get here then bit 7 of H is clear

 BVS scos5              \ If bit 6 of H is set, jump to scos5

.scos3


                        \ If we get here then one of these is true:
                        \
                        \   * Bit 7 of H is clear and bit 6 of H is clear
                        \
                        \   * Bit 7 of H is set and bit 6 of H is set
                        \
                        \ So the results we calculated above are correct:
                        \
                        \   A = |sin(X)|
                        \
                        \   X = |cos(X)|
                        \
                        \ and they will be the same for |sin(A)| and |cos(A)|
                        \ for the original argument A:

 STA sinA               \ Store A in sinA to return |sin(A)|

 STX cosA               \ Store X in cosA to return |cos(A)|

 RTS                    \ Return from the subroutine

.scos4

                        \ If we get here then bit 7 of H is set

 BVS scos3              \ If bit 6 of H is set, jump to scos3

.scos5

                        \ If we get here then one of these is true:
                        \
                        \   * Bit 7 of H is clear and bit 6 of H is set
                        \
                        \   * Bit 7 of H is set and bit 6 of H is clear
                        \
                        \ So the results we calculated above:
                        \
                        \   A = |sin(X)|
                        \
                        \   X = |cos(X)|
                        \
                        \ need to be swapped around to be correct for |sin(A)|
                        \ and |cos(A)| for the original argument A:
                        \
                        \   A = |cos(A)|
                        \
                        \   X = |sin(A)|

 STA cosA               \ Store A in cosA to return |cos(A)|

 STX sinA               \ Store X in sinA to return |sin(A)|

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: Multiply16x16
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Multiply a sign-magnitude 16-bit number and a signed 16-bit number
\
\ ------------------------------------------------------------------------------
\
\ This routine calculates:
\
\   (A T) = (QQ PP) * (SS RR) / 256^2
\
\ It uses the following algorithm:
\
\  (QQ PP) * (SS RR) = (QQ << 8 + PP) * (SS << 8 + RR)
\                    = (QQ << 8 * SS << 8) + (QQ << 8 * RR)
\                                          + (PP * SS << 8)
\                                          + (PP * RR)
\                    = (QQ * SS) << 16 + (QQ * RR) << 8
\                                      + (PP * SS) << 8
\                                      + (PP * RR)
\
\ Finally, it replaces the low byte multiplication in (PP * RR) with 128, as an
\ estimate, as it's a pain to multiply the low bytes of a signed integer with a
\ sign-magnitude number. So the final result that is returned in (A T) is as
\ follows:
\
\   (A T) = (QQ PP) * (SS RR) / 256^2
\         = ((QQ * SS) << 16 + (QQ * RR) << 8 + (PP * SS) << 8 + 128) / 256^2
\
\ which is the algorithm that is implemented in this routine.
\
\ This routine is from Revs, Geoff Crammond's previous game.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   (QQ PP)             16-bit signed integer
\
\   (SS RR)             16-bit sign-magnitude integer with the sign bit in bit 0
\                       of RR
\
\   H                   The sign to apply to the result (in bit 7)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   (A T)               (QQ PP) * (SS RR) * abs(H)
\
\ ******************************************************************************

.Multiply16x16

 LDA QQ                 \ If (QQ PP) is positive, jump to muls1 to skip the
 BPL muls1              \ following

 LDA #0                 \ (QQ PP) is negative, so we now negate (QQ PP) so it's
 SEC                    \ positive, starting with the low bytes
 SBC PP
 STA PP

 LDA #0                 \ And then the high bytes
 SBC QQ                 \
 STA QQ                 \ So we now have (QQ PP) = |QQ PP|

 LDA H                  \ Flip bit 7 of H, so when we set the result to the sign
 EOR #%10000000         \ of H below, this ensures the result is the correct
 STA H                  \ sign

.muls1

 LDA RR                 \ If bit 0 of RR is clear, then (SS RR) is positive, so
 AND #1                 \ jump to muls2
 BEQ muls2

 LDA H                  \ Flip bit 7 of H, so when we set the result to the sign
 EOR #%10000000         \ of H below, this ensures the result is the correct
 STA H                  \ sign

.muls2

 LDA QQ                 \ Set U = QQ
 STA U

 LDA RR                 \ Set A = RR

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = RR * QQ

 STA W                  \ Set (W T) = (A T)
                        \           = RR * QQ

 LDA T                  \ Set (W V) = (A T) + 128
 CLC                    \           = RR * QQ + 128
 ADC #128               \
 STA V                  \ starting with the low bytes

 BCC muls3              \ And then the high byte
 INC W

                        \ So we now have (W V) = RR * QQ + 128

.muls3

 LDA SS                 \ Set A = SS

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = SS * QQ

 STA G                  \ Set (G T) = (A T)
                        \           = SS * QQ

 LDA T                  \ Set (G W V) = (G T 0) + (W V)
 CLC                    \
 ADC W                  \ starting with the middle bytes (as the low bytes are
 STA W                  \ simply V = 0 + V with no carry)

 BCC muls4              \ And then the high byte
 INC G

                        \ So now we have:
                        \
                        \   (G W V) = (G T 0) + (W V)
                        \           = (SS * QQ << 8) + RR * QQ + 128

.muls4

 LDA PP                 \ Set U = PP
 STA U

 LDA SS                 \ Set A = SS

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = SS * PP

 STA U                  \ Set (U T) = (A T)
                        \           = SS * PP

 LDA T                  \ Set (G T ?) = (G W V) + (U T)
 CLC                    \
 ADC V                  \ starting with the low bytes (which we throw away)

 LDA U                  \ And then the high bytes
 ADC W
 STA T

 BCC muls5              \ And then the high byte
 INC G

                        \ So now we have:
                        \
                        \   (G T ?) = (G W V) + (U T)
                        \           = (SS * QQ << 8) + RR * QQ + 128 + SS * PP
                        \           = (QQ * SS) << 8 + (QQ * RR) + (PP * SS)
                        \              + 128
                        \           = (QQ PP) * (SS RR) / 256
                        \
                        \ So:
                        \
                        \   (G T) = (G T ?) / 256
                        \         = (QQ PP) * (SS RR) / 256^2
                        \
                        \ which is the result that we want

.muls5

 LDA G                  \ Set (A T) = (G T)

 BIT H                  \ We are about to fall through into Absolute16Bit, so
                        \ this ensures we set the sign of (A T) to the sign in
                        \ H, so we get:
                        \
                        \   (A T) = (A T) * abs(H)

\ ******************************************************************************
\
\       Name: Absolute16Bit
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Calculate the absolute value (modulus) of a 16-bit number
\
\ ------------------------------------------------------------------------------
\
\ This routine sets (A T) = |A T|.
\
\ It can also return (A T) * abs(n), where A is given the sign of n.
\
\ This routine is from Revs, Geoff Crammond's previous game.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   (A T)               The number to make positive
\
\   N flag              Controls the sign to be applied:
\
\                         * If we want to calculate |A T|, do an LDA or
\                           equivalent before calling the routine
\
\                         * If we want to calculate (A T) * abs(n), do a BIT n
\                           before calling the routine
\
\                         * If we want to set the sign of (A T), then call with:
\
\                           * N flag clear to calculate (A T) * 1
\
\                           * N flag set to calculate (A T) * -1
\
\ ******************************************************************************

.Absolute16Bit

 BPL MainTitleLoop-1    \ If the high byte in A is already positive, return from
                        \ the subroutine (as MainTitleLoop-1 contains an RTS)

                        \ Otherwise fall through into Negate16Bit to negate the
                        \ number in (A T), which will make it positive, so this
                        \ sets (A T) = |A T|

\ ******************************************************************************
\
\       Name: Negate16Bit
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Negate a 16-bit number
\
\ ------------------------------------------------------------------------------
\
\ This routine negates the 16-bit number (A T).
\
\ This routine is from Revs, Geoff Crammond's previous game.
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   Negate16Bit+2       Set (A T) = -(U T)
\
\ ******************************************************************************

.Negate16Bit

 STA U                  \ Set (U T) = (A T)

 LDA #0                 \ Set (A T) = 0 - (U T)
 SEC                    \           = -(A T)
 SBC T                  \
 STA T                  \ starting with the low bytes

 LDA #0                 \ And then the high bytes
 SBC U

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MainTitleLoop
\       Type: Subroutine
\   Category: Main title loop
\    Summary: The main title loop: display the title screen, fetch the landscape
\             number/code, preview the landscape and jump to the main game loop
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   MainTitleLoop-1     Contains an RTS
\
\   main1               The entry point for rejoining the main title loop after
\                       the player enters an incorrect secret code
\
\   main4               The entry point for restarting a landscape after dying,
\                       so the player doesn't have to enter the landscape's
\                       secret code again
\
\ ******************************************************************************

.MainTitleLoop

 LDX #&FF               \ Set the stack pointer to &01FF, which is the standard
 TXS                    \ location for the 6502 stack, so this instruction
                        \ effectively resets the stack
                        \
                        \ This means that the JSR GenerateLandscape instruction
                        \ below will put its return address onto the top of the
                        \ stack, so we can maniupulate the return address by
                        \ modifying (&01FE &01FF)
                        \
                        \ See the notes on the JSR GenerateLandscape instruction
                        \ below for more details

 LDA #4                 \ Set all four logical colours to physical colour 4
 JSR SetColourPalette   \ (blue), so this blanks the entire screen to blue

 JSR ResetVariables     \ Reset all the game's main variables

 LDA #0                 \ Call DrawTitleScreen with A = 0 to draw the title
 JSR DrawTitleScreen    \ screen

 LDX #0                 \ Print text token 0: Background colour blue, print
 JSR PrintTextToken     \ "PRESS ANY KEY" at (64, 100), set text background to
                        \ black

 LDA #&87               \ Set the palette to the second set of colours from the
 JSR SetColourPalette   \ colourPalettes table, which contains the fixed palette
                        \ for the title screens (blue, black, red, yellow)

 JSR ReadKeyboard       \ Enable the keyboard, flush the keyboard buffer and
                        \ read a character from it (so this waits for a key
                        \ press)

.main1

 JSR ResetVariables     \ Reset all the game's main variables

 LDX #1                 \ Print text token 1: Print 13 spaces at (64, 100),
 JSR PrintTextToken     \ print "LANDSCAPE NUMBER?" at (64, 768), switch to text
                        \ cursor, move text cursor to (5, 27)

 LDA #4                 \ Read a four-digit number from the keyboard into the
 JSR ReadNumber         \ input buffer, showing the key presses on-screen and
                        \ supporting the DELETE and RETURN keys

 JSR StringToNumber     \ Convert the string of four ASCII digits in the input
                        \ buffer into a BCD number in inputBuffer(1 0)

 LDY inputBuffer+1      \ Set (Y X) = inputBuffer(1 0)
 LDX inputBuffer        \
                        \ So (Y X) is the entered landscape number in BCD

 JSR InitialiseSeeds    \ Initialise the seed number generator to generate the
                        \ sequence of seed numbers for the landscape number in
                        \ (Y X) and set maxNumberOfEnemies and the landscapeZero
                        \ flag accordingly

 LDA landscapeZero      \ If the landscape number is not 0000, jump to main3
 BNE main3              \ to ask for the landscape's secret entry code

                        \ This is landscape 0000, so we don't ask for a secret
                        \ entry code, but instead we copy the landscape's secret
                        \ code from secretCode0000 into the input buffer, so
                        \ it's as if the player has typed in the code themselves

 LDX #3                 \ We are copying four bytes of secret code into the
                        \ input buffer, so set a byte index in X

.main2

 LDA secretCode0000,X   \ Copy the X-th byte of secretCode0000 to the X-th byte
 STA inputBuffer,X      \ of the input buffer

 DEX                    \ Decrement the byte index

 BPL main2              \ Loop back until we have copied all four bytes

 BMI main4              \ Jump to main4 to skip asking the player to enter the
                        \ code (this BMI is effectively a JMP as we just passed
                        \ through a BPL)

.main3

 LDX #2                 \ Print text token 2: Background colour blue, print
 JSR PrintTextToken     \ "SECRET ENTRY CODE?" at (64, 768), switch to text
                        \ cursor, move text cursor to (2, 27)

 LDA #8                 \ Read an eight-digit number from the keyboard into the
 JSR ReadNumber         \ input buffer, showing the key presses on-screen and
                        \ supporting the DELETE and RETURN keys

 JSR StringToNumber     \ Convert the string of eight ASCII digits in the input
                        \ buffer into a BCD number in inputBuffer(3 2 1 0)

.main4

                        \ The player has now chosen a landscape number and has
                        \ entered the secret code (or, in the case of landscape
                        \ 0000, we have entered the secret code for them)
                        \
                        \ We also jump here if we are restarting a landscape
                        \ after dying, so the player doesn't have to enter the
                        \ landscape's secret code again

 LDA #4                 \ Set all four logical colours to physical colour 4
 JSR SetColourPalette   \ (blue), so this blanks the entire screen to blue

 JSR GenerateLandscape  \ Call GenerateLandscape to generate the landscape and
                        \ play the game
                        \
                        \ Calling this subroutine puts a return address of
                        \ SecretCodeError on the stack (as that's the routine
                        \ that follows directly after this JSR instruction, so
                        \ performing a normal RTS at the end of the
                        \ GenerateLandscape routine will return to the following
                        \ code, which is what happens if the secret code entered
                        \ doesn't match the landscape's secret code
                        \
                        \ However, if the secret code does match the landscape,
                        \ then the SmoothTileData routine that is called from
                        \ GenerateLandscape alters the return address on the
                        \ stack, so instead of returning here, the RTS at the
                        \ end of the GenerateLandscape routine actually takes us
                        \ to the PreviewLandscape routine
                        \
                        \ Because we reset the stack with a YSX instruction at
                        \ the start of the MainTitleLoop routine, we know that
                        \ the JSR GenerateLandscape instruction will put its
                        \ return address onto the top of the stack, so we can
                        \ maniupulate the return address in the SmoothTileData
                        \ routine by modifying (&01FE &01FF)
                        \
                        \ See the SmoothTileData routine for more details

\ ******************************************************************************
\
\       Name: SecretCodeError
\       Type: Subroutine
\   Category: Main title loop
\    Summary: Display the "WRONG SECRET CODE" error, wait for a key press and
\             rejoin the main title loop
\
\ ******************************************************************************

.SecretCodeError

 JSR ResetVariables     \ Reset all the game's main variables

 LDA #0                 \ Call DrawTitleScreen with A = 0 to draw the title
 JSR DrawTitleScreen    \ screen

 LDA #&87               \ Set the palette to the second set of colours from the
 JSR SetColourPalette   \ colourPalettes table, which contains the fixed palette
                        \ for the title screens (blue, black, red, yellow)

 LDX #3                 \ Print text token 3: Background colour blue, print
 JSR PrintTextToken     \ "WRONG SECRET CODE" at (64, 768), print "PRESS ANY
                        \ KEY" at (64, 100), set text background to black

 JSR ReadKeyboard       \ Enable the keyboard, flush the keyboard buffer and
                        \ read a character from it (so this waits for a key
                        \ press)

 JMP main1              \ Loop back to main1 to restart the main title loop

\ ******************************************************************************
\
\       Name: secretCode0000
\       Type: Variable
\   Category: Landscape
\    Summary: The secret entry code for landscape 0000 (06045387)
\
\ ******************************************************************************

.secretCode0000

 EQUD &06045387

\ ******************************************************************************
\
\       Name: ClearScreen
\       Type: Subroutine
\   Category: Graphics
\    Summary: Clear the screen to a specified background
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   screenBackground    The type of screen background:
\
\                         * 0 = fill with alternating colour 0/1 (blue/black)
\                               pixel rows, for the sky during gameplay
\
\                         * 1 = fill with solid colour 0 (blue)
\
\                         * 2 = fill with dithered pixels in colour 0 (blue)
\                               and colour 3 (e.g. green in landscape 0000)
\                               by alternating colour 3/0/3/0 and 0/3/0/3
\                               pixel bytes
\
\                         * 3 = fill with solid colour 1 (black) and draw 240
\                               randomly positioned stars on the background
\
\ ******************************************************************************

.ClearScreen

 JSR ResetScreenAddress \ Reset the address of the start of screen memory

 JSR ClearIconsScanner  \ Clear the energy icon and scanner row at the top of
                        \ the screen

 LDA #0                 \ Set screen variables of some kind with A = 0 ???
 JSR ConfigureBuffer

 LDA #0                 \ Set A = 0 to pass to FillScreen, so we clear the
                        \ screen (as opposed to the screen buffer)

 LDY #24                \ Set Y = 24 to pass to FillScreen, so we clear all 24
                        \ character rows of the landscape view

 LDX #40                \ Set X = 16 to pass to FillScreen so we clear all 40
                        \ character columns of the landscape view

 JSR FillScreen         \ Call FillScreen to fill the entire screen with the
                        \ background specified in screenBackground

 LDA screenBackground   \ If the screen background is not 3, jump to clrs2 to
 CMP #3                 \ return from the subroutine
 BNE clrs2

                        \ If we get here then screenBackground = 3, so we now
                        \ draw three lots of 80 stars on the screen

 LDA #3                 \ Set a loop counter so we call the DrawStars routine
 STA loopCounter        \ three times in the following loop, giving a total of
                        \ 240 stars

.clrs1

 JSR DrawStars          \ Draw 80 randomly positioned stars on the screen in
                        \ colour 2 (white, yellow, cyan or red)

 DEC loopCounter        \ Decrement the loop counter

 BNE clrs1              \ Loop back until we have called DrawStars three times

.clrs2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PanLandscapeView
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Pan the landscape and update the landscape view
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   viewingObject       The number of the object that is viewing the landscape
\                       (this is always the player object for this routine)
\
\ ******************************************************************************

.PanLandscapeView

 LDY lastPanKeyPressed  \ Set Y to the direction of the last pan key that was
                        \ pressed (which may not still be held down)
                        \
                        \ So this contains the direction of any scrolling that
                        \ we need to apply to the landscape, as follows:
                        \
                        \   * 0 = pan right
                        \
                        \   * 1 = pan left
                        \
                        \   * 2 = pan up
                        \
                        \   * 3 = pan down
                        \
                        \ We use this as an index into various tables, to look
                        \ up the correct values for the direction in which we
                        \ want to scroll

 LDX viewingObject      \ Set X to the object number of the viewer, which we set
                        \ to the player object in MainGameLoop

 CPY #2                 \ If the panning direction in Y is up or down, jump to
 BCS lpan3              \ lpan3 to pan vertically

                        \ If we get here then Y is 0 or 1 and the panning
                        \ direction is right or left

 LDA objectYawAngle,X   \ Rotate the player's gaze so that when we draw the
 CLC                    \ updated view, the new part of the landscape that we
 ADC panAngleToUpdate,Y \ need to scroll in from the side goes into the screen
 STA objectYawAngle,X   \ buffer (as the screen buffer is mapped to the left
                        \ portion of the view that we are drawing)

 LDA #25                \ Set A = 25 to pass to FillScreen, so we fill the
                        \ screen buffer (as opposed to screen memory)

 LDY #24                \ Set Y = 24 to pass to FillScreen, so we fill 24
                        \ character rows of the screen buffer

 LDX #16                \ Set X = 16 to pass to FillScreen, so we fill 16
                        \ character columns in the screen buffer

 STX bufferColumns      \ Set bufferColumns to 16 so we can refer to the buffer
                        \ width during the drawing process

 JSR FillScreen         \ Call FillScreen to fill the screen buffer with the
                        \ background specified in screenBackground
                        \
                        \ screenBackground variable is zeroed in DrawTitleView
                        \ before the gameplay starts, so alll calls to the
                        \ FillScreen routine during gameplay fill the buffer
                        \ with alternating colour 0/1 (blue/black) pixel rows,
                        \ for the sky

 JSR UseColumnBuffer    \ Configure the column buffer for use so we draw the
                        \ updated part of the landscape view into the correct
                        \ buffer type for a left or right pan

 JSR DrawLandscapeView  \ Draw the landscape view into the screen buffer
                        \
                        \ If the player held down the panning key throughout the
                        \ drawing process and the whole landscape was drawn,
                        \ then the C flag will be clear, otherwise the C flag
                        \ will be set 

 LDX viewingObject      \ Set X to the object number of the viewer, which we set
                        \ to the player object in MainGameLoop

 LDY lastPanKeyPressed  \ Set Y to the direction of the last pan key that was
                        \ pressed (which may not still be held down)

 BCS lpan2              \ If the call to DrawLandscapeView set the C flag then
                        \ the landscape drawing process was aborted, so jump to
                        \ lpan2 to revert the change to the player's yaw angle
                        \ and return from the subroutine without updating the
                        \ on-screen landscape view

 BNE lpan1              \ If Y <> 0 then Y must be 1, in which case the pan
                        \ angle we fetched from the panAngleToUpdate table
                        \ doesn't need correcting, so jump to lpan1 to skip the
                        \ following

                        \ If we get here then Y = 0, so we added 20 to the
                        \ player's yaw angle so it would draw the new part of
                        \ the view into the screen buffer, so we now need to
                        \ subtract 12 from the player's yaw angle so they end up
                        \ looking in the correct direction, i.e. a net rotation
                        \ of +8 rather than +20 yaw angles

 LDA objectYawAngle,X   \ Subtract 12 from the player's yaw angle
 SEC
 SBC #12
 STA objectYawAngle,X

.lpan1

 LDA #16                \ We now need to scroll the contents of the screen
 JSR StartScrollingView \ buffer into the side of the on-screen landscape view,
                        \ so call StartScrollingView to configure a background
                        \ task to scroll 16 character columns from the screen
                        \ buffer onto the screen, using the interrupt routine
                        \ to do it in the background

 RTS                    \ Return from the subroutine

.lpan2

                        \ If we get here then the panning process was aborted
                        \ before the landscape was drawn

 LDA objectYawAngle,X   \ Reverse the rotation that we applied to the player's
 SEC                    \ yaw angle for the pan, so this puts it back to the
 SBC panAngleToUpdate,Y \ value it had before we started the panning process
 STA objectYawAngle,X

 RTS                    \ Return from the subroutine

.lpan3

                        \ If we get here then Y is 2 or 3 and the panning
                        \ direction is up or down

 LDA objectPitchAngle,X     \ If the player's pitch angle is equal to either
 CMP highestPitchAngle-2,Y  \ highestPitchAngle (if we are panning up) or
 BEQ lpan6                  \ lowestPitchAngle (if we are panning down) then the
                            \ player is already pitched as far back or down as
                            \ possible, so jump to lpan6 to return from the
                            \ subroutine without panning the landscape view, as
                            \ we can't pan any further

 CLC                    \ Rotate the player's gaze so that when we draw the
 ADC panAngleToUpdate,Y \ updated view, the new part of the landscape that we
 STA objectPitchAngle,X \ need to scroll in from above or below goes into the
                        \ screen buffer (as the screen buffer is mapped to the
                        \ top portion of the view that we are drawing)

 LDA #25                \ Set A = 25 to pass to FillScreen, so we fill the
                        \ screen buffer (as opposed to screen memory)

 LDY #8                 \ Set Y = 8 to pass to FillScreen, so we fill 8
                        \ character rows of the screen buffer

 LDX #40                \ Set X = 40 to pass to FillScreen, so we fill 40
                        \ character columns in the screen buffer

 STX bufferColumns      \ Set bufferColumns to 40 so we can refer to the buffer
                        \ width during the drawing process

 JSR FillScreen         \ Call FillScreen to fill the screen buffer with the
                        \ background specified in screenBackground
                        \
                        \ screenBackground variable is zeroed in DrawTitleView
                        \ before the gameplay starts, so alll calls to the
                        \ FillScreen routine during gameplay fill the buffer
                        \ with alternating colour 0/1 (blue/black) pixel rows,
                        \ for the sky

 JSR UseRowBuffer       \ Configure the row buffer for use so we draw the
                        \ updated part of the landscape view into the correct
                        \ buffer type for an up or down pan

 JSR DrawLandscapeView  \ Draw the landscape view into the screen buffer
                        \
                        \ If the player held down the panning key throughout the
                        \ drawing process and the whole landscape was drawn,
                        \ then the C flag will be clear, otherwise the C flag
                        \ will be set 

 LDX playerObject       \ Set X to the object number of the player
                        \
                        \ This should really be an LDX viewingObject instruction
                        \ to be consistent with the rest of the routine, but it
                        \ doesn't make any difference as they are the same at
                        \ this point
                        \
                        \ Perhaps at some point this routine allowed panning of
                        \ the view from viewing objects other than the player,
                        \ which would have been interesting...

 LDY lastPanKeyPressed  \ Set Y to the direction of the last pan key that was
                        \ pressed (which may not still be held down)

 BCS lpan7              \ If the call to DrawLandscapeView set the C flag then
                        \ the landscape drawing process was aborted, so jump to
                        \ lpan7 to revert the change to the player's pitch angle
                        \ and return from the subroutine without updating the
                        \ on-screen landscape view

 CPY #3                 \ If Y <> 3 then Y must be 2, in which case the pan
 BNE lpan4              \ angle we fetched from the panAngleToUpdate table
                        \ doesn't need correcting, so jump to lpan4 to skip the
                        \ following

                        \ If we get here then Y = 3, so we subtracted 12 from
                        \ the player's pitch angle so it would draw the new part
                        \ of the view into the screen buffer, so we now need to
                        \ add 8 to the player's pitch angle so they end up
                        \ looking in the correct direction, i.e. a net rotation
                        \ of -4 rather than -12 pitch angles

 LDA objectPitchAngle,X \ Add 8 to the player's pitch angle
 CLC
 ADC #8
 STA objectPitchAngle,X

.lpan4

 LDA #8                 \ We now need to scroll the contents of the screen
 JSR StartScrollingView \ buffer into the top or bottom of the on-screen
                        \ landscape view, so call StartScrollingView to
                        \ configure a background task to scroll 8 character rows
                        \ from the screen buffer onto the screen, using the
                        \ interrupt routine to do it in the background

.lpan5

 JSR SetColumnBufferMax \ Call SetColumnBufferMax to set the maximum and minimum
                        \ pitch angles for the column buffer

.lpan6

 RTS                    \ Return from the subroutine

.lpan7

                        \ If we get here then the panning process was aborted
                        \ before the landscape was drawn

 LDA objectPitchAngle,X \ Reverse the rotation that we applied to the player's
 SEC                    \ pitch angle for the pan, so this puts it back to the
 SBC panAngleToUpdate,Y \ value it had before we started the panning process
 STA objectPitchAngle,X

 JMP lpan5              \ Jump to SetColumnBufferMax via lpan5 to set the
                        \ maximum and minimum pitch angles for the column buffer
                        \ and return from the subroutine via a tail call

\ ******************************************************************************
\
\       Name: highestPitchAngle
\       Type: Variable
\   Category: Sights
\    Summary: The pitch angle of the highest point that the player can look at
\             with the sights
\
\ ******************************************************************************

.highestPitchAngle

 EQUB 53

\ ******************************************************************************
\
\       Name: lowestPitchAngle
\       Type: Variable
\    Summary: The pitch angle of the lowest point that the player can look at
\             with the sights
\
\ ******************************************************************************

.lowestPitchAngle

 EQUB -51

\ ******************************************************************************
\
\       Name: ResetVariables
\       Type: Subroutine
\   Category: Main title Loop
\    Summary: Reset all the game's main variables
\
\ ******************************************************************************

.ResetVariables

 SEC                    \ Set bit 7 of gameInProgress to indicate that a game is
 ROR gameInProgress     \ not currently in progress and that we are in the title
                        \ and preview screens (so the interrupt handler doesn't
                        \ update the game)

                        \ We now zero the following variable blocks:
                        \
                        \   * &0000 to &008F (Zero page workspace)
                        \
                        \   * &0100 to &01BF (Stack variables workspace)
                        \
                        \   * &0900 to &09EF (xObject)
                        \
                        \   * &0A00 to &0AEF (yObjectLo)
                        \
                        \   * &0C00 to &0CE3 (Main variable workspace)
                        \
                        \ and set the following variable block to %10000000:
                        \
                        \   * &0CE4 to &0CEF (Main variable workspace)

 LDX #0                 \ Set X to use as a byte counter to run from 0 to &EF

.rese1

 LDA #0                 \ Set A = 0 so we can zero the following variable blocks

 STA xObject,X          \ Zero the X-th byte of xObject

 STA yObjectLo,X        \ Zero the X-th byte of yObjectLo

 CPX #&90               \ If X >= &90 then skip the following instruction
 BCS rese2

 STA &0000,X            \ Zero the X-th byte of zero page

.rese2

 CPX #&C0               \ If X >= &C0 then skip the following instruction
 BCS rese3

 STA &0100,X            \ Zero the X-th byte of &0100

.rese3

 CPX #&E4               \ If X < &E4 then skip the following instruction,
 BCC rese4              \ leaving A = 0, so we zero &0C00 to &0CE3

 LDA #%10000000         \ If we get here then X >= &E4, so set A = %10000000 to
                        \ set bit 7 of &0CE4 to &0CEF

.rese4

 STA &0C00,X            \ Set the X-th byte of &0CE4 to A

 INX                    \ Increment the byte counter

 CPX #&F0               \ Loop back until we have processed X from &E4 to &EF
 BCC rese1              \ to set &0CE4 to &0CEF to &80

                        \ Fall through into ResetTilesObjects to reset the tile
                        \ visibility table and deallocate all object numbers

\ ******************************************************************************
\
\       Name: ResetTilesObjects
\       Type: Subroutine
\   Category: Main title Loop
\    Summary: Reset the tile visibility table and deallocate all object numbers
\
\ ******************************************************************************

.ResetTilesObjects

                        \ We now set the following variable block to %11111111
                        \ to indicate that all tiles are visible:
                        \
                        \   * tileVisibility to tileVisibility+127
                        \
                        \ and the following variable block to %10000000 to
                        \ deallocate all the object numbers:
                        \
                        \   * objectFlags to objectFlags+63

 LDX #63                \ Set X to use as a byte counter to run from 63 to 0,
                        \ so we can initialise the 64-byte objectFlags table and
                        \ the 128-byte tileVisibility table

.resv1

 LDA #%11111111         \ Set the X-th and X+64-th bytes of tileVisibility to
 STA tileVisibility,X   \ all set bits, to indicate visible tiles
 STA tileVisibility+64,X

 LDA #%10000000         \ Set bit 7 of the X-th byte of objectFlags, to denote
 STA objectFlags,X      \ that object #X is not allocated to an object

 DEX                    \ Decrement the byte counter

 BPL resv1              \ Loop back until we have processed X from &3F to 0

 INC seedNumberLFSR+2   \ Set bit 16 of the five-byte linear feedback shift
                        \ register in seedNumberLFSR(4 3 2 1 0), as we need a
                        \ non-zero element for the seed number generator to
                        \ work (as otherwise the EOR feedback will not affect
                        \ the contents of the shift register and it won't start
                        \ generating non-zero numbers)

 JSR SetColumnBufferMax \ Call SetColumnBufferMax to set the maximum and minimum
                        \ pitch angles for the column buffer

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CheckForKeyPresses
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Check for various game key presses and update the key logger and
\             relevant variables (during the interrupt routine)
\
\ ******************************************************************************

.CheckForKeyPresses

 LDA #%10000000         \ Set bit 7 of panKeyBeingPressed to indicate that no
 STA panKeyBeingPressed \ pan key is being pressed (we will update this below
                        \ if a pan key is being pressed)

 LDX #&8E               \ Scan the keyboard to see if function key f1 is being
 JSR ScanKeyboard       \ pressed ("Quit game")

 BNE ckey1              \ If function key f1 is not being pressed, jump to ckey1
                        \ to skip the following

 SEC                    \ Function key f1 is not being pressed, which quits the
 ROR quitGame           \ game, so set bit 7 of quitGame so that when we return
                        \ to the start of the main game loop it jumps to the
                        \ main title loop to restart the game

.ckey1

 LDX #&9D               \ Scan the keyboard to see if SPACE is being pressed
 JSR ScanKeyboard       \ ("Toggle sights on/off")

 BNE ckey4              \ If SPACE is not being pressed, jump to ckey4 to reset
                        \ the value of spaceKeyDebounce to flag that SPACE is
                        \ not being pressed

                        \ If we get here then SPACE is being pressed

 LDA spaceKeyDebounce   \ If spaceKeyDebounce is non-zero then we have already
 BNE ckey6              \ toggled the sights but the player is still holding
                        \ down SPACE, so jump to ckey6 to avoid toggling the
                        \ sights again

 LDA sightsAreVisible   \ Flip bit 7 of sightsAreVisible to toggle the sights on
 EOR #%10000000         \ and off
 STA sightsAreVisible

 BPL ckey2              \ If bit 7 is now clear then we just turned the sights
                        \ off, so jump to ckey2 to remove them from the screen

                        \ Otherwise bit 7 is now set, so we need to show the
                        \ sights

 JSR InitialiseSights   \ Initialise the variables used to manage the sights, so
                        \ the sights appear in the middle of the screen

 JSR DrawSights         \ Draw the sights on the screen

 JMP ckey3              \ Jump to ckey3 to skip the following

.ckey2

 JSR RemoveSights       \ Remove the sights from the screen

.ckey3

 LDA #%10000000         \ Set bit 7 of A to store in spaceKeyDebounce, to flag
                        \ that we have toggled the sights (so we can make sure
                        \ we don't keep toggling the sights if SPACE is being
                        \ held down)

 BNE ckey5              \ Jump to ckey5 to set spaceKeyDebounce to the value of
                        \ A in (this BNE is effectively a JMP as A is never
                        \ zero)

.ckey4

                        \ If we get here then SPACE is not being pressed

 LDA #0                 \ Clear bit 7 of spaceKeyDebounce to record that SPACE
                        \ is not being pressed

.ckey5

 STA spaceKeyDebounce   \ Set spaceKeyDebounce to the value of A, so we record
                        \ whether or not SPACE is being pressed to make sure
                        \ we don't keep toggling the sights if SPACE is held
                        \ down

.ckey6

 LDY #14                \ Scan the keyboard for all 14 game keys in the gameKeys
 JSR ScanForGameKeys    \ table

 BPL ckey7              \ ScanForGameKeys will clear bit 7 of the result if at
                        \ least one pan key is being pressed, in which case jump
                        \ to ckey7 to skip the following, so pan keys take
                        \ precedence over the other game keys (which are ignored
                        \ while panning is taking place)

                        \ If we get here then no pan keys are being pressed

 LDA #%01101011         \ Set a bit pattern in sightsInitialMoves to control the
 STA sightsInitialMoves \ initial movement of the sights when a pan key is
                        \ pressed and held down
                        \
                        \ Specifically, this value is shifted left once on each
                        \ call to this routine, with a zero shifted into bit 0,
                        \ and we only move the sights when a zero is shifted out
                        \ of bit 7
                        \
                        \ This means that when we start moving the sights, they
                        \ move like this, with each step happening on one call
                        \ of the interrupt handler:
                        \
                        \   0 = Move
                        \   1 = Pause
                        \   1 = Pause
                        \   0 = Move
                        \   1 = Pause
                        \   0 = Move
                        \   1 = Pause
                        \   1 = Pause
                        \
                        \ ...and then we move on every subsequent shift, as by
                        \ now all bits of sightsInitialMoves are clear
                        \
                        \ This means the sights move more slowly at the start,
                        \ with a slight judder, before speeding up fully after
                        \ eight steps (so this applies a bit of inertia to the
                        \ movement of the sights)

 LDA keyLogger+1        \ Set A to the key logger entry for "A", "Q", "R", "T",
                        \ "B", "H", or "U" (absorb, transfer, create robot,
                        \ create tree, create boulder, hyperspace, U-turn)

 BPL FocusOnKeyAction   \ If there is a key press in the key logger entry, jump
                        \ to FocusOnKeyAction to start focusing effort on
                        \ implementing the relevant action after returning from
                        \ the subroutine using a tail call

                        \ If we get here then the player is not pressing "A",
                        \ "Q", "R", "T", "B", "H", or "U" (absorb, transfer,
                        \ create robot, create tree, create boulder, hyperspace,
                        \ U-turn)

 LDA #%01000000         \ Set bit 6 of uTurnStatus so that when the "U" key is
 STA uTurnStatus        \ next pressed, this will trigger a U-turn in the
                        \ ProcessActionKeys routine
                        \
                        \ This implements debounce so that holding down "U" will
                        \ not continuously perform U-turns, and instead the
                        \ player has to release "U" before they can do a second
                        \ U-turn
                        \
                        \ A U-turn is only performed in ProcessActionKeys when
                        \ bit 6 of uTurnStatus is set, at which point bit 6 is
                        \ cleared, and this is the only place where bit 6 is
                        \ set, so this ensures only one U-turn is performed
                        \ until we get here again, when "U" has been released

 BNE focu1              \ Jump to focu1 to return from the subroutine (this BNE
                        \ is effectively a JMP as A is never zero)

.ckey7

                        \ If we get here then at least one pan key is being
                        \ pressed

 LDX sightsAreVisible   \ If bit 7 of sightsAreVisible is clear then the sights
 BPL ckey8              \ are not being shown, so jump to ckey8 to skip the
                        \ following, as we don't need to move the sights when
                        \ they aren't on-screen

                        \ If we get here then the sights are visible, so the pan
                        \ keys move the sights rather than panning the view

 ASL sightsInitialMoves \ Shift sightsInitialMoves to the left, so we pull the
                        \ next bit from the pattern that determines the initial
                        \ movement of the sights

 BCS focu1              \ If we shifted a 1 out of bit 7 of sightsInitialMoves,
                        \ jump to focu1 to return from the subroutine without
                        \ moving the sights, as a set bit indicates a pause in
                        \ the initial movement of the sights

 JSR MoveSights         \ Move the sights according to the pan key presses in
                        \ the key logger
                        \
                        \ If the player moves the sights off the edge of the
                        \ screen, this routine will set panKeyBeingPressed to
                        \ "press" the relevant pan key so that the screen
                        \ scrolls in the same direction to bring the sights
                        \ back into view

 JMP ckey10             \ Jump to ckey10 to process any pan "key press" from the
                        \ call to MoveSights

.ckey8

 LDA keyLogger          \ Set A to the key logger entry for "S" and "D" (pan
                        \ left, pan right), which are used to move the sights

 BPL ckey9              \ If there is a key press in the key logger entry, jump
                        \ to ckey9 to store this value in panKeyBeingPressed (so
                        \ panning left or right takes precedence over panning up
                        \ or down)

 LDA keyLogger+2        \ Set A to the key logger entry for "L" and "," (pan
                        \ up, pan down), which are used to move the sights

 BMI focu1              \ If there is no key press in the key logger entry then
                        \ no pan keys are being pressed, so jump to focu1 to
                        \ return from the subroutine without recording a pan key
                        \ press in panKeyBeingPressed

.ckey9

 STA panKeyBeingPressed \ Set panKeyBeingPressed to the key logger value of the
                        \ pan key that's being pressed, as follows:
                        \
                        \   * 0 = pan right
                        \
                        \   * 1 = pan left
                        \
                        \   * 2 = pan up
                        \
                        \   * 3 = pan down

.ckey10

 LDA panKeyBeingPressed \ If bit 7 of panKeyBeingPressed is set then no pan keys
 BMI focu1              \ are being pressed, so jump to focu1 to return from the
                        \ subroutine

 STA latestPanKeyPress  \ Set latestPanKeyPress to the key logger value of the
                        \ pan key that's being pressed, so it contains the most
                        \ recent pan key press (i.e. the current one)

                        \ Fall through into FocusOnKeyAction to start focusing
                        \ effort on the pan that the player wants us to do

\ ******************************************************************************
\
\       Name: FocusOnKeyAction
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Tell the game to start focusing effort on the action that has been
\             initiated, such as a pan of the landscape, absorb, transfer etc.
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   focu1               Store the current setting of focusOnKeyAction in the
\                       previousFocus variable so we can detect (in the
\                       ProcessGameplay routine) whether the player is still
\                       holding down a pan key after we finish scrolling the
\                       screen for the previous pan... and then return from the
\                       subroutine
\
\ ******************************************************************************

.FocusOnKeyAction

 LDA #%10000000         \ Set bit 7 of focusOnKeyAction to tell the game to
 STA focusOnKeyAction   \ focus effort on implementing the key action that has
                        \ just been initiated, such as a pan of the landscape
                        \ view, absorb, transfer and so on

 STA L0C1E              \ Set bit 7 of L0C1E to return early from the sub_C5E5F
                        \ subroutine ???

.focu1

 LDA focusOnKeyAction   \ Set previousFocus = focusOnKeyAction so we can detect
 STA previousFocus      \ whether the value of focusOnKeyAction changes
                        \
                        \ This is used by the ProcessGameplay routine to detect
                        \ whether the player is still holding the same pan key
                        \ down after we finish scrolling the screen for the pan

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CheckForSamePanKey
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Check to see whether the same pan key is being held down compared
\             to the last time we checked
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   Z flag              Determines whether the same pan key is being held down
\                       compared to the last time we checked:
\
\                         * Z flag will be set if the same pan key is being held
\                           down (so a BEQ branch will be taken)
\
\                         * Z flag will be clear otherwise (so a BNE branch will
\                           be taken)
\
\ ******************************************************************************

.CheckForSamePanKey

 SEI                    \ Disable interrupts so the key logger doesn't get
                        \ updated while we check it for pan key presses

 LDY #3                 \ Scan the keyboard for the first four game keys ("S",
 JSR ScanForGameKeys    \ "D", "L" and ",", for pan left, right up and down)

 LDA latestPanKeyPress  \ Set A to the key logger value of the latest pan key
                        \ press, which will either be a current key press or the
                        \ value from the last pan key press to be made

 CMP keyLogger          \ Compare with the key logger entry for "S" and "D"
                        \ (pan left and right)

 BEQ cpan1              \ If the key logger entry is unchanged from the previous
                        \ pan key press in latestPanKeyPress, then the same pan
                        \ key is being held down, so jump to cpan1 with the
                        \ Z flag set accordingly

 CMP keyLogger+2        \ Compare with the key logger entry for "L" and ","
                        \ (pan up and down), so the Z flag will be set if the
                        \ same pan key is being held down

.cpan1

 CLI                    \ Re-enable interrupts

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: spaceKeyDebounce
\       Type: Variable
\   Category: Leyboard
\    Summary: A variable to flag whether the SPACE key has been pressed, so we
\             can implement debounce
\
\ ******************************************************************************

.spaceKeyDebounce

 EQUB 0

 EQUB &00               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: PlaceObjectBelow
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Attempt to place the player object on a tile that is below the
\             maximum altitude specified in A
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The maximum desired altitude of the object (though we
\                       may end up placing the object higher than this)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   C flag              Status flag:
\
\                         * Clear if the object was successfully placed on a
\                           tile
\
\                         * Set if the object was not placed on a suitable tile
\
\ ******************************************************************************

.PlaceObjectBelow

 STA tileAltitude       \ Store the maximum altitude in tileAltitude

 LDA #0                 \ We now loop through the landscape tiles, trying to
 STA loopCounter        \ find a suitable location for the object, so set a
                        \ loop counter to count 255 iterations for each loop

.objb1

 DEC loopCounter        \ Decrement the loop counter

 BNE objb2              \ If we have not counted all 255 iterations yet, jump to
                        \ objb2 to skip the following

                        \ If we get here then we have tried 255 tiles at the
                        \ altitude in tileAltitude, but without success, so we
                        \ move to a higher altitude and try again

 INC tileAltitude       \ Increment the altitude in tileAltitude to move up by
                        \ one coordinate (where a tile-sized cube is one
                        \ coordinate across)

 LDA tileAltitude       \ If we just incremented tileAltitude to 12 then we have
 CMP #12                \ gone past the highest altitude possible, so jump to
 BCS objb3              \ objb3 to return from the subroutine with the C flag
                        \ set to indicate failure

                        \ Otherwise keep going to look for a suitable tile at
                        \ the new, higher altitude

.objb2

                        \ We now try to pick a tile in the landscape that might
                        \ be suitable for placing our object

 JSR GetNextSeed0To30   \ Set A to the next number from the landscape's sequence
                        \ of seed numbers, converted to the range 0 to 30

 STA xTile              \ Set xTile to this seed number, so it points to a
                        \ tile corner that anchors a tile (so the tile corner
                        \ isn't along the right edge of the landscape)

 JSR GetNextSeed0To30   \ Set A to the next number from the landscape's sequence
                        \ of seed numbers, converted to the range 0 to 30

 STA zTile              \ Set zTile to this seed number, so it points to a
                        \ tile corner that anchors a tile (so the tile corner
                        \ isn't along the far edge of the landscape)

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile), setting the C flag if the tile
                        \ contains an object

 BCS objb1              \ If the tile already contains an object, jump to objb1
                        \ to try another tile from the landscape's sequence of
                        \ seed numbers

 AND #%00001111         \ If the tile shape in the low nibble of the tile data
 BNE objb1              \ is non-zero, then the tile is not flat, so jump to
                        \ objb1 to try another tile from the landscape's
                        \ sequence of seed numbers

 LDA (tileDataPage),Y   \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 LSR A                  \ Set A to the tile altitude, which is in the top nibble
 LSR A                  \ of the tile data
 LSR A
 LSR A

 CMP tileAltitude       \ If the altitude of the chosen tile is equal to or
 BCS objb1              \ higher than the minimum altitude in tileAltitude, then
                        \ this tile is too high, so jump to objb1 to try another
                        \ tile from the landscape's sequence of seed numbers

                        \ If we get here then we have found a tile that is below
                        \ the altitude in tileAltitude and which doesn't already
                        \ contain an object, so we can use this for placing our
                        \ object

 JSR PlaceObjectOnTile  \ Place object #X on the tile anchored at (xTile, zTile)

 CLC                    \ Clear the C flag to indicate that we have successfully
                        \ placed the object on a tile

 RTS                    \ Return from the subroutine

.objb3

 SEC                    \ Set the C flag to indicate that we have failed to
                        \ place the object on a suitable tile

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetNextSeed0To30
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Set A to the next number from the landscape's sequence of seed
\             numbers, converted to the range 0 to 30
\
\ ******************************************************************************

.GetNextSeed0To30

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers

 AND #31                \ Convert A into a number into the range 0 to 31

 CMP #31                \ If A >= 31 or greater, repeat the process until we
 BCS GetNextSeed0To30   \ get a number in the range 0 to 30

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ProcessGameplay
\       Type: Subroutine
\   Category: Gameplay
\    Summary: A gameplay loop that processes all game key presses, returning to
\             the main game loop when the player moves, quits, loses or pans
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   C flag              Status flag on exit:
\
\                         * Clear if we have just finished processing a pan of
\                           the landscape view, and the player is still holding
\                           down a pan key
\
\                         * Set if any of the following are true:
\
\                           * The Sentinel has won
\
\                           * The player has moved to a new tile
\
\                           * The player has pressed the quit game key
\
\ ******************************************************************************

.ProcessGameplay

 LDA #0                 \ Clear bit 7 of focusOnKeyAction to tell the game to
 STA focusOnKeyAction   \ stop focusing effort on implementing any key actions
                        \ such as landscape pans, as we are now looking at the
                        \ gameplay

 STA uTurnStatus        \ Clear bits 6 and 7 of uTurnStatus to clear any record
                        \ of a U-turn being in progress, and to prevent the "U"
                        \ key from performing a U-turn, so that the "U" key has
                        \ to be released (if applicable) before a second U-turn
                        \ can be performed

.play1

 LDA focusOnKeyAction   \ If bit 7 of focusOnKeyAction is set then the game is
 BMI play5              \ focusing effort on a key action such as a landscape
                        \ pan, so jump to play5 to go straight to processing any
                        \ action key presses, skipping all the key press logic
                        \ below

                        \ We now check whether we have just finished processing
                        \ a landscape pan, and if so whether the player is still
                        \ holding down the same pan key

 LSR samePanKeyPress    \ Clear bit 7 of samePanKeyPress to record that the same
                        \ pan key is not being held down, which we will change
                        \ below if this is not the case

 LDA previousFocus      \ If bit 7 of previousFocus is clear then it matches
 BPL play2              \ the current value of focusOnKeyAction, so the value
                        \ of focusOnKeyAction has not changed since the last
                        \ time we were in the FocusOnKeyAction routine, and at
                        \ that point we were not focusing effort on implementing
                        \ a key action such as a landscape pan
                        \
                        \ So jump to play2 to skip the following check for pan
                        \ keys, as it isn't relevant

                        \ If we get here then bit 7 of focusOnKeyAction is
                        \ clear and bit 7 of previousFocus is set, so we must
                        \ have called the ProcessGameplay routine just after
                        \ implementing a key action such as a landscape pan
                        \
                        \ So let's check to see whether the same pan key is
                        \ still being held down from the pan we just finished

 JSR CheckForSamePanKey \ Check to see whether the same pan key is being
                        \ held down compared to the last time we checked

 BNE play2              \ If the same pan key is not being held down, jump to
                        \ play2 to skip the following

 SEC                    \ The same pan key is still being held down, so set bit
 ROR samePanKeyPress    \ 7 of samePanKeyPress to record this fact for use in
                        \ the sub_C1AF3 routine ???

.play2

 JSR sub_C16A8          \ Something to do with enemies ???

 LDA sentinelHasWon     \ If bit 7 of sentinelHasWon is clear then the player
 BEQ play4              \ has not been absorbed by the Sentinel, so jump to
                        \ play4 to progress the game

 LDA #30                \ The Sentinel has won, so display the game over screen
 JSR ShowGameOverScreen \ with A = 30, so we decay the screen to black with a
                        \ mass of 30 * 2400 = 72,000 randomly placed black dots

.play3

 JSR FocusOnKeyAction   \ Tell the game to start focusing effort on the key
                        \ action that has been initiated (be it a pan of the
                        \ landscape view or an action like absorb or transfer)

 SEC                    \ Set the C flag to indicate that one of the following
                        \ is true:
                        \
                        \   * The Sentinel has won
                        \
                        \   * The player has moved to a new tile
                        \
                        \   * The player has pressed the quit game key
                        \
                        \ so the main game loop can process this action

 RTS                    \ Return from the subroutine

.play4

 ASL playerHasMovedTile \ Shift bit 7 of playerHasMovedTile into the C flag so
                        \ we can check it in the next instruction, and clear bit
                        \ 7 to clear the flag as we are about to process any
                        \ tile move that has occurred

 BCS play3              \ If the C flag is set then bit 7 of playerHasMovedTile
                        \ was set before we cleared it, which indicates that the
                        \ player has moved to a new tile, so jump to play3 to
                        \ return from the subroutine with the C flag set

 BIT quitGame           \ If bit 7 of quitGame is set then the player has
 BMI play3              \ pressed function key f1 to quit the game, so jump to
                        \ play3 to return from the subroutine with the C flag
                        \ set

 JSR sub_C191A          \ Something to do with player and enemy objects ???

 JSR ProcessPauseKeys   \ Pause or unpause the game when COPY or DELETE are
                        \ pressed

 JSR ProcessSound       \ Process any sounds or music that are being made in the
                        \ background

 JSR ProcessVolumeKeys  \ Adjust the volume of the sound envelopes when the
                        \ volume keys are pressed

 JMP play1              \ Jump back to play1 to repeat the main game loop

.play5

 LDA panKeyBeingPressed \ If no pan key is currently being pressed, jump to
 BMI play6              \ play6 to process any action key presses

 CLC                    \ Clear the C flag to indicate that we just finished a
                        \ landscape pan and the player is still holding down a
                        \ pan key, so the main game loop can process a new pan

 RTS                    \ Return from the subroutine

.play6

 LDA keyLogger+1        \ Set A to the key logger entry for "A", "Q", "R", "T",
                        \ "B", "H", or "U" (absorb, transfer, create robot,
                        \ create tree, create boulder, hyperspace, U-turn)

 BMI play9              \ If there is no key press in the key logger entry, jump
                        \ back to the start of the routine via play9 to keep
                        \ checking for key presses

                        \ If we get here then the player is pressing "A", "Q",
                        \ "R", "T", "B", "H" or "U" (absorb, transfer, create
                        \ robot, create tree, create boulder, hyperspace,
                        \ U-turn), so the possible values for A are:
                        \
                        \   * 0  for key press "R" (Create robot)
                        \   * 2  for key press "T" (Create tree)
                        \   * 3  for key press "B" (Create boulder)
                        \   * 32 for key press "A" (Absorb)
                        \   * 33 for key press "Q" (Transfer)
                        \   * 34 for key press "H" (Hyperspace)
                        \   * 35 for key press "U" (U-turn)

 CMP #34                \ If A >= 34 then "H" (hyperspace) or "U" (U-turn) is
 BCS play7              \ being pressed, so jump to play7 to skip the following
                        \ check, as we can hyperspace and U-turn at any point,
                        \ irrespective of whether the sights are being shown

 BIT sightsAreVisible   \ If bit 7 of sightsAreVisible is clear then the sights
 BPL play9              \ are not being shown, so jump back to the start of the
                        \ routine via play9 to keep checking for key presses, as
                        \ we can only create, absorb and transfer when the
                        \ sights are visible

                        \ If we get here then the sights are being shown, so we
                        \ can process the key press

.play7

 STA keyPress           \ Record the value from the key logger in keyPress, so
                        \ we can refer to it in the call to ProcessActionKeys

 LSR activateSentinel   \ The player has pressed a key that expends or absorbs
                        \ energy, which activates the Sentinel at the very start
                        \ of each level (the Sentinel and Sentries are inactive
                        \ until this point, giving the player time to get their
                        \ bearings when they first start a landscape)
                        \
                        \ So clear bit 7 of activateSentinel to indicate that
                        \ the Sentinel is activated and the game has started

 JSR ProcessActionKeys  \ Process any key presses in key logger entry 1, which
                        \ is where action key presses are stored (absorb,
                        \ transfer, create, hyperspace, U-turn)

 BCS play8              \ If the call to ProcessActionKeys returned with the C
                        \ flag set, then it didn't add or remove any objects, so
                        \ jump to play8 to skip the following

                        \ If we get here then the call to ProcessActionKeys
                        \ added or removed an object, so we now need to make the
                        \ appropriate sound and ???

 JSR FlushSoundBuffer0  \ Flush the sound channel 0 buffer

 LDA #2                 \ Make sound #2 (create/absorb object white noise)
 JSR MakeSound

 LDA #%11000000         \ Set bit 6 and 7 of L0C6D ???
 STA L0C6D

 LSR L0C1E              \ Clear bit 7 of L0C1E ???

 JSR sub_C1F84          \ Something to do with objects, could be a redraw or
                        \ something as we have added/removed an object ???

 JSR FlushSoundBuffer0  \ Flush the sound channel 0 buffer

 JSR UpdateIconsScanner \ Update the icons in the top-left corner of the screen
                        \ to show the player's current energy level and redraw
                        \ the scanner box

.play8

 ASL playerHasMovedTile \ Shift bit 7 of playerHasMovedTile into the C flag so
                        \ we can check it in the next instruction, and clear bit
                        \ 7 to clear the flag as we are about to process any
                        \ tile move that has occurred

 BCC play9              \ If bit 7 of playerHasMovedTile was clear before we
                        \ cleared it, then the player has not moved to a new
                        \ tile, so jump back to the start of the routine via
                        \ play9 to continue processing the gameplay

                        \ If we get here then bit 7 of playerHasMovedTile was
                        \ set before we cleared it, which indicates that the
                        \ player has moved to a new tile, so return from the
                        \ subroutine with the C flag set

 RTS                    \ Return from the subroutine

.play9

 JMP ProcessGameplay    \ Jump back to the start of the ProcessGameplay routine
                        \ to keep processing the gameplay

\ ******************************************************************************
\
\       Name: sub_C12EE
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C12EE

 LDA L0C50
 BNE C1308
 LDX #&17

.P12F5

 LDA L0C20,X
 CMP #&02
 BCC C12FF
 DEC L0C20,X

.C12FF

 DEX
 BPL P12F5
 LDA #&02
 STA L0C50
 RTS

.C1308

 DEC L0C50
 RTS

\ ******************************************************************************
\
\       Name: ResetScreenAddress
\       Type: Subroutine
\   Category: Graphics
\    Summary: Reset the address of the start of screen memory
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the screen addresses as follows:
\
\   * Address of the start of screen memory in the 6845 CRTC registers = &7F80
\
\   * Address of the icon and scanner row at the top of the screen in
\     iconRowAddr(1 0) = &7F80
\
\   * Address of the player's scrolling landscape view in viewScreenAddr(1 0) =
\     &60C0
\
\ Note that &7F80 + 320 = &60C0, when the wrapping of screen memory is taken
\ into consideration, so the player's scrolling landscape view in memory is one
\ character line after the icon and scanner row at the top of the screen.
\
\ ******************************************************************************

.ResetScreenAddress

 SEI                    \ Disable interrupts so we can update the 6845 registers

 LDA #&C0               \ Set viewScreenAddr(1 0) = &60C0
 STA viewScreenAddr
 LDA #&60
 STA viewScreenAddr+1

 JSR GetIconRowAddress  \ Set iconRowAddr(1 0) to the address in screen memory
                        \ of the icon and scanner row at the top of the screen

                        \ We now set the address of screen memory to &7F80

 LDA #&0F               \ Store &0F on the stack to use as the value of R12 in
 PHA                    \ the following

 LDA #&F0               \ Set 6845 register R13 = &F0, for the low byte
 LDX #13                \
 STX SHEILA+&00         \ We do this by writing the register number (13) to
 STA SHEILA+&01         \ SHEILA &00, and then the value (&F0) to SHEILA &01

 DEX                    \ Set 6845 register R12 = &0F, for the high byte
 STX SHEILA+&00         \
 PLA                    \ We do this by writing the register number (12) to
 STA SHEILA+&01         \ SHEILA &00, and then the value (&0F) to SHEILA &01

                        \ This sets 6845 registers (R12 R13) = &0FF0 to point
                        \ to the start of screen memory in terms of character
                        \ rows. There are 8 pixel lines in each character row,
                        \ so to get the actual address of the start of screen
                        \ memory, we multiply by 8:
                        \
                        \   &0FF0 * 8 = &7F80
                        \
                        \ So this sets the start of screen memory to &7F80

 CLI                    \ Re-enable interrupts

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: InitialiseSights
\       Type: Subroutine
\   Category: Sights
\    Summary: Initialise the variables used to manage the sights, so the sights
\             appear in the middle of the screen
\
\ ******************************************************************************

.InitialiseSights

                        \ We start by calculating the screen address for the
                        \ sights when they are in the middle of the screen,
                        \ which is where we initialise them
                        \
                        \ The base screen address has already been set up in
                        \ viewScreenAddr(1 0), and we want to place the sights
                        \ halfway down and halfway across the screen
                        \
                        \ The custom screen mode 5 used by the game contains 25
                        \ character rows, each of which is eight pixels high
                        \
                        \ The top character row is used for the energy icon and
                        \ scanner, and viewScreenAddr(1 0) points to the start
                        \ of screen memory just below this top row, so the
                        \ player's view is 24 character rows high and row 12 is
                        \ halfway down the screen
                        \
                        \ Each character row in screen mode 5 takes up 320 bytes
                        \ (40 character blocks of eight bytes each), so the
                        \ offset within screen memory of the start of row 12 is
                        \ 12 * 320, and we can move halfway along that row by
                        \ adding a further 160, so that's an offset of:
                        \
                        \   12 * 320 + 160 = 4000
                        \
                        \ So the address of the sights in screen memory is:
                        \
                        \   viewScreenAddr(1 0) + 4000
                        \
                        \ which is what we calculate now

 LDA viewScreenAddr     \ Calculate the following:
 CLC                    \
 ADC #&A0               \   (A sightsScreenAddr) = viewScreenAddr(1 0) + &0FA0
 STA sightsScreenAddr   \                        = viewScreenAddr(1 0) + 4000
                        \
                        \ starting with the low bytes

 LDA viewScreenAddr+1   \ And then the high bytes
 ADC #&0F

 CMP #&80               \ If the high byte in A >= &80 then the new address is
 BCC sesi1              \ past the end of screen memory, so subtract &20 from
 SBC #&20               \ the high byte so the address wraps around within the
                        \ range of screen memory between &6000 and &8000

.sesi1

 STA sightsScreenAddr+1 \ Store the high byte of the result, so we now have:
                        \
                        \   sightsScreenAddr(1 0) = viewScreenAddr(1 0) + 4000

 LDA #80                \ Set the on-screen x-coordinate of the sights to 80,
 STA xSights            \ which is in the middle of the 160-pixel wide screen

 LDA #95                \ Set the on-screen y-coordinate of the sights to 95,
 STA ySights            \ which is in the middle of the 192-pixel high player's
                        \ view (which is the whole screen apart from the energy
                        \ icon and scanner row at the top)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ScanForGameKeys
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Scan for game key presses and update the key logger
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The offset within gameKeys where we start the scan, with
\                       the scan working towards the start of gameKeys
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   N flag              Determines whether a pan key is being pressed:
\
\                         * Bit 7 of A will be set if no pan keys are being
\                           pressed (so a BMI branch will be taken)
\
\                         * Bit 7 of A will be clear if at least one pan key is
\                           being pressed (so a BPL branch will be taken)
\
\ ******************************************************************************

.ScanForGameKeys

 LDX #3                 \ We start by resetting the key logger, so set a loop
                        \ counter in X for resetting all four entries

 LDA #%10000000         \ Set A = %10000000 to reset all four entries, as the
                        \ set bit 7 indicates an empty entry in the logger

.gkey1

 STA keyLogger,X        \ Reset the X-th entry in the key logger

 DEX                    \ Decrement the loop counter

 BPL gkey1              \ Loop back until we have reset all four entries

                        \ We now work our way backwards through the gameKey
                        \ table, starting at offset Y, and checking to see if
                        \ each key is being pressed and logging the results in
                        \ the key logger

.gkey2

 LDX gameKeys,Y         \ Set X to the internal key number for the Y-th key in
                        \ the gameKey table

 JSR ScanKeyboard       \ Scan the keyboard to see if this key is being pressed

 BNE gkey3              \ If the key in X is not being pressed, jump to gkey3 to
                        \ move on to the next key in the table

 LDA keyLoggerConfig,Y  \ Set X to the key logger entry where we should store
 AND #%00000011         \ this key press, which is in bits 0 and 1 of the
 TAX                    \ corresponding entry in the keyLoggerConfig table

 LDA keyLoggerConfig,Y  \ Set A to the value to store in the key logger for this
 LSR A                  \ key, which is in bits 2 to 7 of the corresponding
 LSR A                  \ entry in the keyLoggerConfig table

 STA keyLogger,X        \ Store the configured value in the configured entry
                        \ for this key press

.gkey3

 DEY                    \ Decrement the index in Y to move on to the next key
                        \ in the gameKey table

 BPL gkey2              \ Loop back until we have checked all the keys up to the
                        \ start of the gameKey table

 LDA keyLogger          \ Combine the key logger entry for "S" and "D" (pan left
 AND keyLogger+2        \ and right) with the key logger entry for "L" and ","
                        \ (pan left and right and set the status flags according
                        \ to the result
                        \
                        \ Specifically, if bit 7 is set in both entries, then no
                        \ pan keys are being pressed, so a BMI following the
                        \ call to ScanForGameKeys will be taken
                        \
                        \ If, however, bit 7 is clear in either entry, then at
                        \ least one pan key is being pressed, so a BPL following
                        \ the call to ScanForGameKeys will be taken

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: gameKeys
\       Type: Variable
\   Category: Keyboard
\    Summary: Negative inkey values for the game keys
\
\ ------------------------------------------------------------------------------
\
\ For a full list of negative inkey values, see Appendix C of the "Advanced User
\ Guide for the BBC Micro" by Bray, Dickens and Holmes.

\ ******************************************************************************

.gameKeys

 EQUB &AE               \ Negative inkey value for "S" (pan left)
 EQUB &CD               \ Negative inkey value for "D" (pan right)
 EQUB &A9               \ Negative inkey value for "L" (pan up)
 EQUB &99               \ Negative inkey value for "," (pan down)
 EQUB &BE               \ Negative inkey value for "A" (absorb)
 EQUB &EF               \ Negative inkey value for "Q" (transfer)
 EQUB &CC               \ Negative inkey value for "R" (create robot)
 EQUB &DC               \ Negative inkey value for "T" (create tree)
 EQUB &9B               \ Negative inkey value for "B" (create boulder)
 EQUB &AB               \ Negative inkey value for "H" (hyperspace)
 EQUB &DB               \ Negative inkey value for "7" (volume down)
 EQUB &EA               \ Negative inkey value for "8" (volume up)
 EQUB &96               \ Negative inkey value for COPY (pause)
 EQUB &A6               \ Negative inkey value for DELETE (unpause)
 EQUB &CA               \ Negative inkey value for "U" (U-turn)

\ ******************************************************************************
\
\       Name: keyLoggerConfig
\       Type: Variable
\   Category: Keyboard
\    Summary: The configuration table for storing keys the key logger
\
\ ------------------------------------------------------------------------------
\
\ Each game key has an entry in the keyLoggerConfig table that corresponds with
\ the internal key number in the gameKeys table.
\
\ Bits 0 and 1 determine the entry in the four-byte key logger where we should
\ record each key press (entry numbers are 0 to 3).
\
\ Bits 2 to 7 contain the value to store in the key logger at that entry.
\
\ The key logger entries fall into four categories:
\
\   * Entry 0 is for sideways movement keys (pan left, pan right)
\
\   * Entry 1 is for action keys (absorb, transfer, create, hyperspace, U-turn)
\
\   * Entry 2 is for vertical movement keys (pan up, pan down)
\
\   * Entry 3 is for utility keys (volume control, pause)
\
\ ******************************************************************************

.keyLoggerConfig

 EQUB 0 +  1 << 2       \ Put  1 in logger entry 0 for "S" (pan left)
 EQUB 0 +  0 << 2       \ Put  0 in logger entry 0 for "D" (pan right)

 EQUB 2 +  2 << 2       \ Put  2 in logger entry 2 for "L" (pan up)
 EQUB 2 +  3 << 2       \ Put  3 in logger entry 2 for "," (pan down)

 EQUB 1 + 32 << 2       \ Put 32 in logger entry 1 for "A" (absorb)
 EQUB 1 + 33 << 2       \ Put 33 in logger entry 1 for "Q" (transfer)
 EQUB 1 +  0 << 2       \ Put  0 in logger entry 1 for "R" (create robot)
 EQUB 1 +  2 << 2       \ Put  2 in logger entry 1 for "T" (create tree)
 EQUB 1 +  3 << 2       \ Put  3 in logger entry 1 for "B" (create boulder)
 EQUB 1 + 34 << 2       \ Put 34 in logger entry 1 for "H" (hyperspace)

 EQUB 3 +  0 << 2       \ Put  0 in logger entry 3 for "7" (volume down)
 EQUB 3 +  1 << 2       \ Put  1 in logger entry 3 for "8" (volume up)
 EQUB 3 +  2 << 2       \ Put  2 in logger entry 3 for COPY (pause)
 EQUB 3 +  3 << 2       \ Put  3 in logger entry 3 for DELETE (unpause)

 EQUB 1 + 35 << 2       \ Put 35 in logger entry 1 for "U" (U-turn)

\ ******************************************************************************
\
\       Name: DrawTitleView
\       Type: Subroutine
\   Category: Title screen
\    Summary: Draw the main title screen, the secret code screen or the
\             landscape preview
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The object to draw on the title screen:
\
\                         * 0 = draw a robot on the right of the screen for the
\                               secret code screen
\
\                         * 5 = draw the Sentinel on the right of the screen for
\                               the main title screen
\
\                         * &80 = draw the landscape preview
\
\   X                   The screen background:
\
\                         * 1 = fill with solid colour 0 (blue) for the main
\                               title screen
\
\                         * 3 = fill with solid colour 1 (black) and draw 240
\                               randomly positioned stars in colour 2 (white,
\                               yellow, cyan or red), for the secret code screen
\                               and landscape preview
\
\   Y                   The view type:
\
\                         * 0 = landscape preview
\
\                         * 1 = main title screen or secret code screen
\
\ ******************************************************************************

.DrawTitleView

 STA titleObjectToDraw  \ Set titleObjectToDraw to the object that we are
                        \ drawing so we can refer to it throughout the title
                        \ routines

 STX screenBackground   \ Set screenBackground to the type of background to draw
                        \ for the title screen or landscape preview

                        \ We start by setting the correct colour for any drop
                        \ shadow text on the title screen (i.e. text that uses
                        \ the standard font and which is printed twice with an
                        \ offset to give a drop-shadow effect, as opposed to the
                        \ large 3D text which is drawn as 3D objects)

 TXA                    \ Set A to the background type

 LDX #2                 \ Set X = 2 to use as the colour for the rear character
                        \ of a drop shadow (this is red on the title screens or
                        \ white/yellow/cyan/red in the landscape preview)

 EOR #3                 \ Update the VDU codes at vduShadowFront so the front
 STA vduShadowFront+1   \ character of the dropdown text is printed in colour
                        \ A EOR 3, so that's:
                        \
                        \   * Colour 2 (red) for the solid blue background
                        \
                        \   * Colour 0 (blue) for the star background

 BEQ tvew1              \ If we just set the colour of the front character to
                        \ blue, skip the following instruction

 INX                    \ Set X = 3 to use as the colour for the rear character
                        \ of a drop shadow (this is yellow on the title screens
                        \ green/red/yellow/cyan in the landscape preview)

.tvew1

 STX vduShadowRear+1    \ Update the VDU codes at vduShadowRear so the rear
                        \ character of the dropdown text is printed in colour X,
                        \ so that's:
                        \
                        \   * Colour 3 (yellow) for the solid blue background
                        \
                        \   * Colour 2 for the star background, which is red for
                        \     the secret code screen, or white/yellow/cyan/red
                        \     in the landscape preview)

 STY viewType           \ Set viewType to the view type so we can use it as an
                        \ index into the screen configuration tables to set up
                        \ the correct perspective depending on whether this is
                        \ a landscape preview (Y = 0) or a title screen (Y = 1)

                        \ We now set up object #16 to use as the viewing object
                        \ for the large 3D text blocks, using the values from
                        \ the configuration tables

 LDA yTextViewer,Y      \ Set the y-coordinate of the viewer in object #16
 STA yObjectHi+16

 LDA textViewerPitch,Y  \ Set the pitch angle of the viewer in object #16
 STA objectPitchAngle+16

 LDA xTextViewer,Y      \ Set the x-coordinate of the viewer in object #16
 STA xObject+16

 LDA zTextViewer,Y      \ Set the z-coordinate of the viewer in object #16
 STA zObject+16

 LDA textViewerYaw,Y    \ Set the yaw angle of the viewer in object #16
 STA objectYawAngle+16

 LDA titleOffset,Y      \ Store the title offset on the stack so we can retrieve
 PHA                    \ it below

 JSR ClearScreen        \ Clear the screen to the screen background specified in
                        \ screenBackground (so that's blue for the main title
                        \ screen or black with stars for the secret code screen
                        \ or landscape preview)

 LDA titleObjectToDraw  \ If bit 7 of titleObjectToDraw is set then we are
 BMI tvew2              \ drawing the landscape preview, so skip the following
                        \ instruction as there is no 3D object on the right of
                        \ the screen

 JSR DrawTitleObjects   \ Otherwise call DrawTitleObjects to draw an object of
                        \ type A (so that's 0 for a robot or 5 for the Sentinel)
                        \ standing on top of a tower on the right side of the
                        \ screen

.tvew2

 PLA                    \ Set xTitleOffset to the title offset, which will only
 STA xTitleOffset       \ be non-zero when we are drawing the large 3D text on
                        \ the main title screen or secret code screen

 LDX #16                \ Set the viewing object to object #16
 STX viewingObject

 JSR DrawLandscapeView  \ Draw the landscape view to display the large 3D text
                        \ (for the title screens) or draw the landscape preview

 LDA viewType           \ If viewType is non-zero then this is the main title
 BNE tvew4              \ screen or secret code screen, so jump to tvew4 to skip
                        \ the following

 LDX #127               \ We just drew the landscape preview, so we now reset
                        \ the tile visibilities so we're ready to play the game,
                        \ so set a byte counter in X to work through the 128
                        \ bytes in the tileVisibility table

 STX viewType           \ Set viewType to a non-zero value (it doesn't matter
                        \ what) so the GetObjectAngles routine will process
                        \ angles for the game's landscape from now on

.tvew3

 STA tileVisibility,X   \ Zero the X-th byte in the tileVisibility table

 DEX                    \ Decrement the byte counter

 BPL tvew3              \ Loop back until we have zeroed the whole
                        \ tileVisibility table

.tvew4

 LDA #0                 \ Set xTitleOffset = 0 to remove the x-coordinate offset
 STA xTitleOffset       \ that we used for the text, as is it not needed during
                        \ gameplay

 STA screenBackground   \ Set screenBackground = 0 so if we start the game after
                        \ showing this title screen, the FillScreen routine will
                        \ clear the screen buffers to the blue and black sky,
                        \ which is the only screen background we need during
                        \ gameplay

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: yTextViewer
\       Type: Variable
\   Category: Title screen
\    Summary: The y-coordinate of the viewer for the large 3D text on the title
\             screen
\
\ ******************************************************************************

.yTextViewer

 EQUB 33                \ Landscape preview

 EQUB 75                \ Title screen or secret code screen

\ ******************************************************************************
\
\       Name: textViewerPitch
\       Type: Variable
\   Category: Title screen
\    Summary: The pitch angle of the viewer for the large 3D text on the title
\             screen
\
\ ******************************************************************************

.textViewerPitch

 EQUB -22               \ Landscape preview

 EQUB -39               \ Title screen or secret code screen

\ ******************************************************************************
\
\       Name: xTextViewer
\       Type: Variable
\   Category: Title screen
\    Summary: The x-coordinate of the viewer for the large 3D text on the title
\             screen
\
\ ******************************************************************************

.xTextViewer

 EQUB 15                \ Landscape preview

 EQUB 0                 \ Title screen or secret code screen

\ ******************************************************************************
\
\       Name: titleOffset
\       Type: Variable
\   Category: Title screen
\    Summary: An offset to apply to the large 3D text for the title screen
\
\ ******************************************************************************

.titleOffset

 EQUB 0                 \ Landscape preview

 EQUB -17               \ Title screen or secret code screen

\ ******************************************************************************
\
\       Name: zTextViewer
\       Type: Variable
\   Category: Title screen
\    Summary: The z-coordinate of the viewer for the large 3D text on the title
\             screen
\
\ ******************************************************************************

.zTextViewer

 EQUB 194               \ Landscape preview

 EQUB 191               \ Title screen or secret code screen

\ ******************************************************************************
\
\       Name: textViewerYaw
\       Type: Variable
\   Category: Title screen
\    Summary: The yaw angle of the viewer for the large 3D text on the title
\             screen
\
\ ******************************************************************************

.textViewerYaw

 EQUB 0                 \ Landscape preview

 EQUB 18                \ Title screen or secret code screen

\ ******************************************************************************
\
\       Name: viewType
\       Type: Variable
\   Category: Title screen
\    Summary: Storage for the type of title view we are drawing in DrawTitleView
\             (title screen or landscape preview)
\
\ ******************************************************************************

.viewType

 EQUB 1

\ ******************************************************************************
\
\       Name: SpawnEnemies
\       Type: Subroutine
\   Category: Landscape
\    Summary: Calculate the number of enemies for this landscape, add them to
\             the landscape and set the palette accordingly
\
\ ******************************************************************************

.SpawnEnemies

 LDA landscapeZero      \ If this is not landscape 0000, jump to popu1 to
 BNE popu1              \ calculate the number of enemies to spawn

 LDA #1                 \ This is landscape 0000, so set A = 1 to use for the
                        \ total number of enemies

 BNE popu2              \ Jump to popu2 to set numberOfEnemies to the value of A

.popu1

 JSR GetEnemyCount      \ Set A to the enemy count for this landscape, which is
                        \ derived from the top digit of the landscape number and
                        \ the next number in the landscape's sequence of seed
                        \ numbers, so it is always the same value for the same
                        \ landscape number
                        \
                        \ At this point A is in the range 1 to 8, with higher
                        \ values for higher landscape numbers

 CMP maxNumberOfEnemies \ If A < maxNumberOfEnemies then skip the following
 BCC popu2              \ instruction

 LDA maxNumberOfEnemies \ Set A = maxNumberOfEnemies, so the number of enemies
                        \ does not exceed the value of maxNumberOfEnemies that
                        \ we set in the InitialiseSeeds routine
                        \
                        \ So landscapes 0000 to 0009 have a maximum enemy count
                        \ of 1, landscapes 0010 to 0019 have a maximum enemy
                        \ count of 2, and so on up to landscapes 0070 and up,
                        \ which have a maximum enemy count of 8

.popu2

 STA numberOfEnemies    \ Store the number of enemies for this landscape in
                        \ numberOfEnemies

 JSR AddEnemiesToTiles  \ Add the required number of enemies to the landscape,
                        \ starting from the highest altitude and working down,
                        \ with no more than one enemy on each contour

                        \ We now update colours 2 and 3 in the first palette in
                        \ colourPalettes according to the number of enemies

 LDA numberOfEnemies    \ Set X = (numberOfEnemies - 1) mod 8
 SEC                    \
 SBC #1                 \ The mod 8 is not strictly necessary as numberOfEnemies
 AND #7                 \ is in the range 1 to 8, but doing this ensures we can
 TAX                    \ safely use X as an index into the landscapeColour
                        \ tables

 LDA landscapeColour3,X \ Set colour 3 in the game palette to the X-th entry
 STA colourPalettes+3   \ from landscapeColour3

 LDA landscapeColour2,X \ Set colour 2 in the game palette to the X-th entry
 STA colourPalettes+2   \ from landscapeColour2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SpawnPlayer
\       Type: Subroutine
\   Category: Landscape
\    Summary: Add the player object to the landscape, ideally placing it below
\             all the enemies and in the bottom half of the landscape
\
\ ******************************************************************************

.SpawnPlayer

 LDA #0                 \ Spawn the player's robot (an object of type 0),
 JSR SpawnObject        \ returning the object number of the new object in X
                        \ and currentObject

 STX playerObject       \ Set playerObject to the object number of the newly
                        \ spawned object

 LDA #10                \ Set the player's energy level to 10
 STA playerEnergy

 LDA landscapeZero      \ If the landscape number is not 0000, jump to sply1
 BNE sply1

 LDA #8                 \ Set (xTile, zTile) = (8, 17)
 STA xTile              \
 LDA #17                \ So the player always starts on this tile in the first
 STA zTile              \ landscape

 JSR PlaceObjectOnTile  \ Place object #X on the tile anchored at (xTile, zTile)

 JMP SpawnTrees         \ Jump to SpawnTrees to add trees to the landscape and
                        \ move towards playing the game

.sply1

                        \ If we get here then this is not landscape 0000

 LDA minEnemyAltitude   \ Set A to the altitude of the lowest enemy on the
                        \ landscape

 CMP #6                 \ If A >= 6 then set A = 6
 BCC sply2              \
 LDA #6                 \ So A = min(6, minEnemyAltitude)

.sply2

                        \ By this point A contains an altitude that is no higher
                        \ than any enemies and is no greater than 6
                        \
                        \ We can use this as a cap on the player's starting
                        \ altitude to ensure that the player starts below all
                        \ the enemies, and in the bottom half of the landscape
                        \ (which ranges from altitude 1 to 11)

 JSR PlaceObjectBelow   \ Attempt to place the player object on a tile that is
                        \ below the maximum altitude specified in A (though we
                        \ may end up placing the object higher than this)

 BCS sply1              \ If the call to PlaceObjectBelow sets the C flag then
                        \ the object has not been successfully placed, so loop
                        \ back to sply1 to keep trying, working through the
                        \ landscape's sequence of seed numbers until we do
                        \ manage to place the player on a tile

                        \ Otherwise we have placed the player object on a tile,
                        \ so now we fall through into SpawnTrees to add trees to
                        \ the landscape

\ ******************************************************************************
\
\       Name: SpawnTrees
\       Type: Subroutine
\   Category: Landscape
\    Summary: Add trees to the landscape, ideally placing them below all the
\             enemies in the landscape
\
\ ******************************************************************************

.SpawnTrees

 LDA #48                \ Set U = 48 - 3 * numberOfEnemies
 SEC                    \
 SBC numberOfEnemies    \ We use this to cap the number of trees we add to the
 SBC numberOfEnemies    \ landscape (though it only affects higher levels)
 SBC numberOfEnemies
 STA U

 JSR GetNextSeed0To22   \ Set A to the next number from the landscape's sequence
                        \ of seed numbers, converted to the range 0 to 22

 CLC                    \ Set A to this number, converted to the range 10 to 32
 ADC #10

 CMP U                  \ If A >= U then set A = U
 BCC tree1              \
 LDA U                  \ So A = min(U, A)

.tree1

 STA treeCounter        \ By this point A contains a value in the range 10 to 32
                        \ that's no greater than 48 - 3 * numberOfEnemies
                        \
                        \ So when numberOfEnemies is six or more, this reduces
                        \ the value of A as follows:
                        \
                        \   * When numberOfEnemies = 6, range is 10 to 30
                        \   * When numberOfEnemies = 7, range is 10 to 27
                        \   * When numberOfEnemies = 8, range is 10 to 24
                        \
                        \ As the number of trees determines the total amount of
                        \ energy in the landscape, this makes the levels get
                        \ even more difficult when there are higher enemy counts
                        \
                        \ We now try to add this number of trees to the
                        \ landscape, so store the result in treeCounter to use
                        \ as a counter in the following loop

.tree2

 LDA #2                 \ Spawn a tree (an object of type 2), returning the
 JSR SpawnObject        \ object number of the new object in X and currentObject

 LDA minEnemyAltitude   \ Set A to the altitude of the lowest enemy on the
                        \ landscape, so we try to spawn all the trees at a lower
                        \ altitude to the enemies

 JSR PlaceObjectBelow   \ Attempt to place the player object on a tile that is
                        \ below the maximum altitude specified in A (though we
                        \ may end up placing the object higher than this)

 BCS tree3              \ If the call to PlaceObjectBelow sets the C flag then
                        \ the object has not been successfully placed, so jump
                        \ to tree3 to stop adding trees to the landscape

 DEC treeCounter        \ Decrement the tree counter

 BNE tree2              \ Loop back until we have spawned the number of trees
                        \ in treeCounter

.tree3

                        \ We have now placed all the objects on the landscape,
                        \ so now we fall through into CheckSecretCode to check
                        \ that the player entered the correct secret code for
                        \ this landscape

\ ******************************************************************************
\
\       Name: CheckSecretCode (Part 1 of 2)
\       Type: Subroutine
\   Category: Landscape
\    Summary: Generate the secret code for this landscape and optionally check
\             it against the entered code in the keyboard input buffer
\
\ ------------------------------------------------------------------------------
\
\ At this point we have generated the landscape and populated it with enemies,
\ the player and trees, all using the landscape's sequence of seed numbers. This
\ sequence will be different for each individual level, but will be exactly the
\ same sequence every time we generate a specific level.
\
\ We now keep generating the landscape's sequence of seed numbers to get the
\ landscape's secret code, as follows:
\
\   * Generate another 38 numbers from the sequence
\
\   * The next four numbers in the sequence form the secret code
\
\ To get a secret code of the form 12345678, we take the last four numbers and
\ convert them into binary coded decimal (BCD) by using the GetNextSeedAsBCD
\ routine. These four two-digit pairs then form the secret code, with each of
\ the four numbers producing a pair of digits, building up the secret code from
\ left to right (so in the order that they are written down).
\
\ If we are displaying the landscape number on-screen at the end of a level,
\ then the last four numbers are generated in the SpawnSecretCode3D routine, but
\ if we are checking the secret code entered by the player, then we generate the
\ last four numbers in this routine (plus one extra number that is ignored).
\ This behaviour is controlled by the doNotPlayLandscape variable.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   doNotPlayLandscape  Controls how we generate the secret code and how we
\                       return from the subroutine:
\
\                         * If bit 7 is set, return from part 1 of the routine
\                           after generating the secret code sequence up to, but
\                           not including, the last four BCD numbers (i.e. the
\                           secret code itself), so these can be generated and
\                           drawn by the SpawnSecretCode3D routine
\
\                         * If bit 7 is clear, jump to part 2 after generating
\                           the whole secret code sequence, plus one more code,
\                           checking the generated code against the code entered
\                           into the input buffer as we go
\
\                       The first one is used when displaying a landscape number
\                       for a completed level, while the second is used to check
\                       an entered secret code before playing the landscape
\
\ ******************************************************************************

.CheckSecretCode

 LDX #170               \ Set X = 170 to use as a loop counter for when we
                        \ calculate the secret code, so the following loop
                        \ counts down from 170 to 128 (inclusive, so that's a
                        \ total of 38 + 4 + 1 iterations)
                        \
                        \ This is the value for when bit 7 of doNotPlayLandscape
                        \ is clear, so that's when we are about to play the game
                        \ and we need to generate the secret code in the
                        \ following loop so we can check it against the code
                        \ entered by the player (which is still in the keyboard
                        \ input buffer from when they typed it in)

 LDY stashOffset-170,X  \ Set Y = stashOffset
                        \
                        \ The value of stashOffset is set in the SetSecretStash
                        \ routine during the landscape drawing process, where it
                        \ is set to a value that is unique and consistent for
                        \ each individual landscape
                        \
                        \ We use it as an offset into the secretCodeStash list
                        \ below, so the stash moves around in memory depending
                        \ on the landscape number, making this whole process
                        \ harder to follow (and therefore harder to crack)

 BIT doNotPlayLandscape \ If bit 7 of doNotPlayLandscape is clear then the next
 BPL srct1              \ step is to play the landscape, so skip the following
                        \ to leave X set to 170

 LDX #165               \ Set X = 165 to use as a loop counter for when we
                        \ calculate the secret code, so the following loop
                        \ counts down from 165 to 128 (inclusive, so that's a
                        \ total of 38 iterations)
                        \
                        \ This is the value for when bit 7 of doNotPlayLandscape
                        \ is set, so that's when we are not going to play the
                        \ game but are just generating the secret code, in which
                        \ case we stop iterating just before the secret code is
                        \ generated so the SpawnSecretCode3D can finish the job

                        \ We now loop through a number of iterations, counting
                        \ X down towards 128
                        \
                        \ On each iteration we do three things:
                        \
                        \   * We generate the next number from the landscape's
                        \     sequence of seed numbers, converted to BCD
                        \
                        \   * We test this against the contents of memory from
                        \     either &0D19 or &0D14 down to &0CEF and rotate the
                        \     result into bit 0 of secretCodeChecks (the result
                        \     is only relevant if we are checking the secret
                        \     code against an entered code)
                        \
                        \   * We add the objectFlags for the Sentinel (which is
                        \     simply a way of incorporating a known value, in
                        \     this case %01111111) and store the results in the
                        \     table at secretCodeStash, from the offset in Y
                        \     onwards, i.e. from offest stashOffset onwards
                        \
                        \ If we are checking the code against an entered code,
                        \ then the second step is the important part, and this
                        \ is how it works
                        \
                        \ The inputBuffer is at &0CF0, and it still holds the
                        \ code that the player entered in &0CF0 to &0CF3, with
                        \ the first two digits of the code in &0CF3 and the last
                        \ two digits in &0CF0
                        \
                        \ This means that when X = 170, the last five checks in
                        \ each iteration test against the four BCD numbers in
                        \ the entered code, in the correct order, with one extra
                        \ generation and check that is ignored (presumably to
                        \ make this whole process harder to follow)
                        \
                        \ So if bits 1 to 4 of secretCodeChecks are set by the
                        \ end of the process, the secret code in the keyboard
                        \ input buffer matches the secret code that we just
                        \ generated for this level
                        \
                        \ The third step is only relevant if we are going on to
                        \ play the game, as this feeds into a second secret code
                        \ check that is performed in the GetRowVisibility
                        \ routine, which is only run during gameplay

.srct1

 JSR GetNextSeedAsBCD   \ Set A to the next number from the landscape's sequence
                        \ of seed numbers, converted to a binary coded decimal
                        \ (BCD) number

                        \ We now compare this generated number with the contents
                        \ of memory, working our way down towards the keyboard
                        \ input buffer (towards the end of the iterations)
                        \
                        \ X counts down to 128, and for each iteration we check
                        \ the generated number against a location in memory
                        \
                        \ For the checks to work, we need the last five bytes
                        \ to be the four secret code numbers in inputBuffer,
                        \ plus one more, so:
                        \
                        \   * When X > 132, we are checking against memory that
                        \     comes after the inputBuffer, and we can safely
                        \     ignore the results
                        \
                        \   * When X = 132, 131, 130 and 129 we need to be
                        \     checking against the four numbers in inputBuffer
                        \
                        \   * When X = 128, we are doing the very last check,
                        \     which we can also ignore
                        \
                        \ The comparison is done by subtracting the contents of
                        \ the memory location we are checking from the BCD
                        \ number we just generated
                        \
                        \ This is done with a SBC byteToCheck,X instruction
                        \
                        \ To work out what byteToCheck should be, consider that:
                        \
                        \   * When X = 129, we check the byte at inputBuffer
                        \                   (i.e. the last 2 digits of the code
                        \                   when written down or typed in)
                        \
                        \   * When X = 130, we check the byte at inputBuffer+1
                        \
                        \   * When X = 131, we check the byte at inputBuffer+2
                        \
                        \   * When X = 132, we check the byte at inputBuffer+3
                        \                   (i.e. the first 2 digits of the code
                        \                   when written down or typed in)
                        \
                        \ To make this work, then, we need this instruction:
                        \
                        \   SBC inputBuffer-129,X
                        \
                        \ Note that for BeebAsm to parse this properly, we need
                        \ to wrap the inputBuffer-129 part in brackets, and we
                        \ have to use square brackets so it doesn't look like an
                        \ indirect address instruction

 SEC                        \ Subtract the byte from memory that we are checking
 SBC [inputBuffer-129],X    \ from the generated number

 BEQ srct2              \ If A = 0 then we have a match between the number in
                        \ memory and the generated number, so jump to srct2 to
                        \ keep the C flag set, so we can rotate this into
                        \ secretCodeChecks to indicate a success

 CLC                    \ Otherwise we do not have a match, so clear the C flag
                        \ and rotate this into secretCodeChecks to indicate a
                        \ failure

.srct2

 ROL secretCodeChecks   \ Rotate the C flag into bit 0 of secretCodeChecks, so
                        \ secretCodeChecks contains a record of the last eight
                        \ matches between memory and the generated sequence of
                        \ numbers
                        \
                        \ We only care about the last five comparisons, of which
                        \ we ignore the very last, as the preceding four results
                        \ are for the four BCD numbers in the keyboard input
                        \ buffer (i.e. the entered number)

                        \ We now move on to poulate the secret code stash, which
                        \ contains the result of each of the comparisons with
                        \ %01111111 added to them
                        \
                        \ The stash is checked in the GetRowVisibility routine
                        \ and will abort the game if the values aren't correct,
                        \ so this enables a second secret code check once the
                        \ game has started
                        \
                        \ The secret stash adds a known value into the mix, by
                        \ fetching the value of objectFlags, which contains the
                        \ object flags for object #0
                        \
                        \ Object #0 is always the Sentinel, and the Sentinel
                        \ is always placed on top of the Sentinel's tower, so
                        \ the object flags for the Sentinel are constructed as
                        \ follows:
                        \
                        \   * Bits 0-5 = the number of the object beneath this
                        \                one
                        \
                        \   * Bit 6 = set to indicate that this object is on top
                        \             of another object
                        \
                        \   * Bit 7 = clear to indicate that this object number
                        \             is allocated to an object
                        \
                        \ The Sentinel's tower is always the first object to be
                        \ spawned, and object numberss are allocated from 63 and
                        \ down, so this means the tower is always object #63, or
                        \ %111111
                        \
                        \ The Sentinel's object flags are therefore %01111111
                        \
                        \ See the PlaceObjectOnTile routine for details of how
                        \ the Sentinel's object flags are constructed

 CLC                    \ Set A = A + %01111111
 ADC objectFlags

 STA secretCodeStash,Y  \ Store A in the Y-th entry in the secretCodeStash list
                        \
                        \ The addition above means that an entry of %01111111 in
                        \ that stash indicates that A was zero before the
                        \ addition, which also indicates a match
                        \
                        \ If the entered code matches the generated sequence of
                        \ numbers (i.e. it matches the landscape's secret code)
                        \ then the four corresponding entries in secretCodeStash
                        \ will be %01111111
                        \
                        \ See the GetRowVisibility routine to see this in action

 INY                    \ Increment the index in Y so we build the stash upwards
                        \ in memory

 DEX                    \ Decrement the loop counter so the comparisons move
                        \ down in memory, towards inputBuffer

 BMI srct1              \ Look back to compare the next byte until we have
                        \ compared the bytes all the way down to X = 128

 ASL doNotPlayLandscape \ Set the C flag to bit 7 of doNotPlayLandscape and
                        \ clear bit 7 of doNotPlayLandscape, so from this point
                        \ on any calls to GenerateLandscape will preview and
                        \ play the game

 BCC srct4              \ If bit 7 of doNotPlayLandscape was clear then jump to
                        \ part 2 to check the secret code and either show the
                        \ "WRONG SECRET CODE" error or play the game

                        \ Otherwise bit 7 of doNotPlayLandscape was set, so we
                        \ return from the subroutine normally without playing
                        \ the game

.srct3

 RTS                    \ Return from the subroutine
                        \
                        \ We get to this point by calling the SpawnPlayer
                        \ routine from one of two places:
                        \
                        \   * PreviewLandscape
                        \
                        \   * FinishLandscape
                        \
                        \ and then either failing the secret code checks or
                        \ finishing the current landscape
                        \
                        \ If we got here from PreviewLandscape, then the next
                        \ instruction jumps to SecretCodeError to display the
                        \ "WRONG SECRET CODE" error, wait for a key press and
                        \ rejoin the main title loop
                        \
                        \ If we got here from FinishLandscape, then the next
                        \ instructions display the landscape's secret code on
                        \ completion of the level

\ ******************************************************************************
\
\       Name: landscapeColour3
\       Type: Variable
\   Category: Landscape
\    Summary: Physical colours for colour 3 in the game palette for the
\             different numbers of enemies
\
\ ******************************************************************************

.landscapeColour3

 EQUB 2                 \ Enemy count = 1: blue, black, white, green

 EQUB 1                 \ Enemy count = 2: blue, black, yellow, red

 EQUB 3                 \ Enemy count = 3: blue, black, cyan, yellow

 EQUB 6                 \ Enemy count = 4: blue, black, red, cyan

 EQUB 1                 \ Enemy count = 5: blue, black, white, red

 EQUB 6                 \ Enemy count = 6: blue, black, yellow, cyan

 EQUB 1                 \ Enemy count = 7: blue, black, cyan, red

 EQUB 3                 \ Enemy count = 8: blue, black, red, yellow

\ ******************************************************************************
\
\       Name: CheckSecretCode (Part 2 of 2)
\       Type: Subroutine
\   Category: Landscape
\    Summary: Check the results of the secret code matching process, and if the
\             secret codes match, jump to PlayGame to play the game
\
\ ******************************************************************************

.srct4

 LDA secretCodeChecks   \ If bits 1 to 4 of secretCodeChecks are not all set,
 AND #%00011110         \ then one or more of the four BCD bytes in the secret
 CMP #%00011110         \ code do not match, so jump to srct3 to return from the
 BNE srct3              \ subroutine normally, to display the "WRONG SECRET
                        \ CODE" error page

                        \ If get here then bits 1 to 4 of secretCodeChecks are
                        \ all set, so the entered secret entry code matches the
                        \ generated code, so we can now proceed to playing the
                        \ landscape
                        \
                        \ The following code simply jumps to the PlayGame
                        \ routine, but in an obfuscated way that changes the
                        \ return address on the stack to PlayGame-1, so the RTS
                        \ instruction will jump to PlayGame (as that's how the
                        \ RTS instruction works)

 PLA                    \ Remove the return address from the stack and discard
 PLA                    \ it

                        \ In the following we use the value in objectFlags,
                        \ which contains the object flags for the object #0
                        \
                        \ Object #0 is always the Sentinel, and the Sentinel
                        \ is always placed on top of the Sentinel's tower, so
                        \ the object flags for the Sentinel are constructed as
                        \ follows:
                        \
                        \   * Bits 0-5 = the number of the object beneath this
                        \                one
                        \
                        \   * Bit 6 = set to indicate that this object is on top
                        \             of another object
                        \
                        \   * Bit 7 = clear to indicate that this object number
                        \             is allocated to an object
                        \
                        \ The Sentinel's tower is always the first object to be
                        \ spawned, and object numberss are allocated from 63 and
                        \ down, so this means the tower is always object #63, or
                        \ %111111
                        \
                        \ The Sentinel's object flags are therefore %01111111
                        \
                        \ The following code uses this fact to push the address
                        \ of PlayGame-1 onto the stack, but in a totally
                        \ obfuscated manner
                        \
                        \ It calculates the high byte as follows:
                        \
                        \     objectFlags + HI(PlayGame-1) - %01111111
                        \   = %01111111 + HI(PlayGame-1) - %01111111
                        \   = HI(PlayGame-1)
                        \
                        \ and the low byte as follows:
                        \
                        \     high byte + LO(PlayGame-1) - HI(PlayGame-1)
                        \   = HI(PlayGame-1) + LO(PlayGame-1) - HI(PlayGame-1)
                        \   = LO(PlayGame-1)
                        \
                        \ For the first calculation, we need to apply a little
                        \ hack to the code to get around a limitation in BeebAsm
                        \ that rejects negative constants
                        \
                        \ HI(PlayGame-1) - %01111111 in the first calculation is
                        \ negative, so to persuade BeebAsm to accept it as a
                        \ constant, we can wrap it in LO() to convert it into
                        \ a two's complement value that BeebAsm will accept
                        \
                        \ The LO() part is effectively applying MOD 256 in a way
                        \ that works with negative arguments

 CLC                    \ Push PlayGame-1 onto the stack, high byte first
 LDA objectFlags
 ADC #LO(HI(PlayGame-1) - %01111111)
 PHA
 CLC
 ADC #LO(PlayGame-1) - HI(PlayGame-1)
 PHA

 RTS                    \ Return from the subroutine, which will take the
                        \ address off the stack, increment it and jump to that
                        \ address
                        \
                        \ So this jumps to PlayGame to play the actual game

\ ******************************************************************************
\
\       Name: landscapeColour2
\       Type: Variable
\   Category: Landscape
\    Summary: Physical colours for colour 2 in the game palette for the
\             different numbers of enemies
\
\ ******************************************************************************

.landscapeColour2

 EQUB 7                 \ Enemy count = 1: blue, black, white, green

 EQUB 3                 \ Enemy count = 2: blue, black, yellow, red

 EQUB 6                 \ Enemy count = 3: blue, black, cyan, yellow

 EQUB 1                 \ Enemy count = 4: blue, black, red, cyan

 EQUB 7                 \ Enemy count = 5: blue, black, white, red

 EQUB 3                 \ Enemy count = 6: blue, black, yellow, cyan

 EQUB 6                 \ Enemy count = 7: blue, black, cyan, red

 EQUB 1                 \ Enemy count = 8: blue, black, red, yellow

\ ******************************************************************************
\
\       Name: AddEnemiesToTiles
\       Type: Subroutine
\   Category: Landscape
\    Summary: Add the required number of enemies to the landscape, starting from
\             the highest altitude and working down, with one enemy per contour
\
\ ******************************************************************************

.AddEnemiesToTiles

 JSR GetHighestTiles    \ Calculate both the highest tiles in each 4x4 block of
                        \ tiles in the landscape and the altitude of the highest
                        \ tile, putting the results in the following variables:
                        \
                        \   * maxAltitude contains the altitude of the highest
                        \     tile in each 4x4 block in the landscape
                        \
                        \   * xTileMaxAltitude contains the tile x-coordinate of
                        \     the highest tile in each 4x4 block in the
                        \     landscape
                        \
                        \   * zTileMaxAltitude contains the tile z-coordinate of
                        \     the highest tile in each 4x4 block in the
                        \     landscape
                        \
                        \   * tileAltitude contains the altitude of the highest
                        \     tile in the entire landscape

 LDX #0                 \ We now loop through the number of enemies, adding one
                        \ enemy for each loop and iterating numberOfEnemies
                        \ times, so set an enemy counter in X to count the
                        \ enemies as we add them
                        \
                        \ If this is a level with only one enemy, then that
                        \ enemy must be the Sentinel, so when X = 0, we add the
                        \ Sentinel to the landscape, otherwise we add a sentry
                        \
                        \ Enemies are allocated object numbers from 0 to 7, with
                        \ the Sentinel in object #0, and sentries from object #1
                        \ to object #7 (if there are any)

.aden1

 STX enemyCounter       \ Set enemyCounter to the enemy counter in X, so we can
                        \ retrieve it later in the loop

 LDA #1                 \ Set the object type for object #X to type 1, which
 STA objectTypes,X      \ denotes a sentry, so we spawn sentries in objects #1
                        \ to #numberOfEnemies (this also sets the type for
                        \ object #0 to type 1, but this gets overridden when
                        \ the Sentinel is spawned as object #0 below)

                        \ We now work down the landscape, from the highest peaks
                        \ down to lower altitudes, looking for suitable tile
                        \ blocks to place an enemy
                        \
                        \ To do this we start with tile blocks that are at an
                        \ altitude of tileAltitude (which we set above to the
                        \ altitude of the highest tile in the landscape), and we
                        \ work down in steps of 16

.aden2

 JSR GetTilesAtAltitude \ Set tilesAtAltitude to a list of tile block numbers
                        \ whose highest tiles in the 4x4 block are at an
                        \ altitude of tileAltitude, returning the length of the
                        \ list in T and a bit mask in bitMask that has a
                        \ matching number of leading zeroes as T

 BCC aden3              \ If the call to GetTilesAtAltitude returns at least one
                        \ tile block at this altitude then the C flag will be
                        \ clear, so jump to aden3 to add an enemy to one of the
                        \ matched tile blocks

 LDA tileAltitude       \ Otherwise we didn't find any tile blocks at this
 SEC                    \ altitude, so subtract 1 from the high nibble of
 SBC #%00010000         \ tileAltitude to move down one level (we subtract from
 STA tileAltitude       \ the high nibble because tileAltitude contains tile
                        \ data, which has the tile altitude in the high nibble
                        \ and the tile shape in the low nibble)

 BNE aden2              \ Loop back to check for tile blocks at the lower
                        \ altitude until we have reached an altitude of zero

 STX numberOfEnemies    \ When the GetTilesAtAltitude routine returns with no
                        \ matching tile blocks, it also returns a value of &FF
                        \ in X, so this sets numberOfEnemies to -1

 JMP aden6              \ Jump to aden6 to set the value of minEnemyAltitude
                        \ and return from the subroutine

.aden3

                        \ If we get here then we have found at least one tile
                        \ block at the current altitude, so we now pick one of
                        \ them, using the next seed number to choose which one,
                        \ and we then add an enemy to the highest tile in the
                        \ block
                        \
                        \ We only pick one tile at this altitude so that the
                        \ enemies are spread out over various altitudes

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers

 AND bitMask            \ The call to GetTilesAtAltitude above sets bitMask to a
                        \ bit mask that has a matching number of leading zeroes
                        \ as the number of tile blocks at this altitude, so this
                        \ instruction converts A into a number with the same
                        \ range of non-zero bits as T

 CMP T                  \ If A >= T then jump back to fetch another seed number
 BCS aden3

                        \ When we get here, A is a seed number and A < T, so
                        \ A can be used as an offset into the list of tile
                        \ blocks in tilesAtAltitude (which contains T entries)

 TAY                    \ Set Y to the seed number in A so we can use it as an
                        \ index in the following instruction

 LDX tilesAtAltitude,Y  \ Set X to the Y-th tile block number in the list of
                        \ tile blocks at an altitude of tilesAtAltitude

                        \ We now zero the maximum tile altitudes for tile block
                        \ X and the eight surrounding tile blocks, so that
                        \ further calls to GetTilesAtAltitude won't match these
                        \ tiles, so we therefore won't put any enemies on those
                        \ blocks (this ensures we don't create enemies too close
                        \ to each other)

 LDA #0                 \ Set A = 0 so we can zero the maximum tile altitudes
                        \ for tile block X and the eight surrounding blocks

 STA maxAltitude-9,X    \ Zero the altitudes of the three tile blocks in the row
 STA maxAltitude-8,X    \ in front of tile block X
 STA maxAltitude-7,X

 STA maxAltitude-1,X    \ Zero the altitudes of tile block X and the two blocks
 STA maxAltitude,X      \ to the left and right
 STA maxAltitude+1,X

 STA maxAltitude+7,X    \ Zero the altitudes of the three tile blocks in the row
 STA maxAltitude+8,X    \ behind tile block X
 STA maxAltitude+9,X

 LDA xTileMaxAltitude,X \ Set (xTile, zTile) to the tile coordinates of the
 STA xTile              \ highest tile in the tile block, which is where we can
 LDA zTileMaxAltitude,X \ place an enemy
 STA zTile

 LDX enemyCounter       \ Set X to the loop counter that we stored above

 BNE aden4              \ If the loop number is non-zero then we are adding a
                        \ sentry, so jump to aden4

                        \ If we get here then the enemy counter is zero, so we
                        \ are adding the Sentinel and the Sentinel's tower

 STA zTileSentinel      \ Set (xTileSentinel, zTileSentinel) to the tile
 LDA xTile              \ coordinates of the highest tile in the tile block,
 STA xTileSentinel      \ which we put in (xTile, zTile) above, so this is the
                        \ tile coordinate where we now spawn the Sentinel

 LDA #5                 \ Set the object type for object #0 to type 5, which
 STA objectTypes        \ denotes the Sentinel (so the Sentinel is always
                        \ object #0, while other objects that are spawned are
                        \ allocated to object #63 and work down the bumbers)

 LDA #6                 \ Spawn the Sentinel's tower (an object of type 6),
 JSR SpawnObject        \ returning the object number of the new object in X
                        \ and currentObject

 JSR PlaceObjectOnTile  \ Place object #X on the tile anchored at (xTile, zTile)
                        \ to place the tower on the landscape

 LDA #0                 \ Set the tower object's objectYawAngle to 0, so it's
 STA objectYawAngle,X   \ facing forwards and into the screen

 LDX enemyCounter       \ Set X to the enemy counter, so X now contains the
                        \ object number of the Sentinel (which is always zero
                        \ as we only add the Sentinel on the first iteration of
                        \ the loop)
                        \
                        \ We now place the Sentinel object on the tile, which
                        \ therefore places the Sentinel on top of the tower

.aden4

 JSR PlaceObjectOnTile  \ Place object #X on the tile anchored at (xTile, zTile)
                        \ to place the Sentinel or sentry in the correct place
                        \ on the landscape

 JSR SetEnemyData       \ ???

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers

 LSR A                  \ Set the C flag to bit 7 of A (this also clears bit 7
                        \ of A but that doesn't matter as we are about to clear
                        \ it in the next instruction anyway)

 AND #63                \ Set A to a number in the range 5 to 63
 ORA #5

 STA objRotationTimer,X \ Set the object's entry in objRotationTimer to the
                        \ number in A, so this determines how often the object
                        \ rotates in iterations of the main game loop

 LDA #20                \ Set A to either 20 or 236, depending on the value that
 BCC aden5              \ we gave to the C flag above
 LDA #236

.aden5

 STA objRotationSpeed,X \ Set the object's entry in objRotationSpeed to the
                        \ value of A, which is either 20 or 236
                        \
                        \ The degree system in the Sentinel looks like this:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of object
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ The rotation speed is the size of the angle through
                        \ which the object yaws on each rotation, so this means
                        \ we are setting the rotation speed to +20 degrees (a
                        \ clockwise turn) or -20 degrees (an anticlockwise turn)

 INX                    \ Increment the enemy loop counter in X

 CPX numberOfEnemies    \ If we have added a total of numberOfEnemies enemies,
 BCS aden6              \ jump to aden6 to finish off

 JMP aden1              \ Otherwise loop back to add another enemy

.aden6

 LDA tileAltitude       \ Extract the altitude from tileAltitude, which is in
 LSR A                  \ the high nibble (as tileAltitude contains tile data,
 LSR A                  \ which has the tile altitude in the high nibble and
 LSR A                  \ the tile shape in the low nibble)
 LSR A

 STA minEnemyAltitude   \ Store the result in minEnemyAltitude, so it contains
                        \ the lowest altitude of the enemies we just added to
                        \ the landscape

 CLC                    \ Clear the C flag (though this has no effect as the C
                        \ flag is set as soon as we return to the SpawnEnemies
                        \ routine)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetTilesAtAltitude
\       Type: Subroutine
\   Category: Landscape
\    Summary: Return a list of tile blocks at a specified altitude
\
\ ------------------------------------------------------------------------------
\
\ Argument:
\
\   tileAltitude        The altitude to search for
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   C flag              Status flag:
\
\                         * Clear if at least one tile block is at an altitude
\                           of tileAltitude
\
\                         * Set if no tile blocks are at an altitude of
\                           tileAltitude, in which case X is set to &FF
\
\   tilesAtAltitude     A list of tile block numbers whose highest tiles match
\                       the altitude in tileAltitude
\
\   T                   The number of entries in the list at tilesAtAltitude
\
\   bitMask             A bit mask with a matching number of leading zeroes as T
\
\ ******************************************************************************

.GetTilesAtAltitude

                        \ We start by fetching all the 4x4 tile blocks from the
                        \ landscape whose altitude matches tileAltitude (so
                        \ that's all the 4x4 blocks whose highest tile is at an
                        \ altitude of tileAltitude)

 LDX #63                \ Set an index in X to work through all 4x4 tile blocks,
                        \ of which there are 64

 LDY #0                 \ Set Y = 0 to count the number of tile blocks whose
                        \ altitude matches tileAltitude

.galt1

 LDA maxAltitude,X      \ If the highest tile in the X-th tile block does not
 CMP tileAltitude       \ have an altitude of tileAltitude, jump to galt2 to
 BNE galt2              \ move on to the next tile block

 TXA                    \ Store the number of the tile block in the Y-th byte of
 STA tilesAtAltitude,Y  \ tilesAtAltitude, so we end up compiling a list of all
                        \ the tile blocks that have an altitude of tileAltitude

 INY                    \ Increment the counter in Y as we have just added a
                        \ block number to tilesAtAltitude

.galt2

 DEX                    \ Decrement the block counter in X

 BPL galt1              \ Loop back until we have checked the altitudes of all
                        \ the tile blocks

                        \ By this point we have all the tile blocks with an
                        \ altitude of tileAltitude in a list of length Y at
                        \ tilesAtAltitude

 TYA                    \ Set A to the length of the list at tilesAtAltitude

 BEQ galt4              \ If the list is empty then jump to galt4 return from
                        \ the subroutine with the C flag clear

 STA T                  \ Set T to the length of the list at tilesAtAltitude

                        \ We now set bitMask to a bit mask that covers all the
                        \ non-zero bits in the list length in A, so if A is of
                        \ the form %001xxxxx, for example, then bitMask will
                        \ contain %00111111, while A being like %000001xx will
                        \ give a bitMask of %00000111
                        \
                        \ To do this we count the number of continuous clear
                        \ bits at the top of A, and then use this as an index
                        \ into the leadingBitMask table
                        \
                        \ So we count zeroes from bit 7 down until we hit a 1,
                        \ and put the result into Y

 LDY #&FF               \ Set Y = -1 so the following loop counts the number of
                        \ zeroes correctly

.galt3

 ASL A                  \ Shift A to the left, moving the top bit into the C
                        \ flag

 INY                    \ Increment the zero counter in Y

 BCC galt3              \ Loop back to keep shifting and counting zeroes until
                        \ we shift a 1 out of bit 7, at which point Y contains
                        \ the length of the run of zeroes in bits 7 to 0 of the
                        \ length of the list at tilesAtAltitude

 LDA leadingBitMask,Y   \ Set bitMask to the Y-th entry from the leadingBitMask
 STA bitMask            \ table, which will give us a bit mask with a matching
                        \ number of leading zeroes as A

 CLC                    \ Clear the C flag to indicate that we have successfully
                        \ found at least one tile block that matches the
                        \ altitude in tileAltitude

 RTS                    \ Return from the subroutine

.galt4

 SEC                    \ If we get here then we have checked all 64 tile blocks
                        \ and none of them are at aan altitude of tileAltitude,
                        \ so set the C flag to indicate that the returned list
                        \ is empty

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: leadingBitMask
\       Type: Variable
\   Category: Landscape
\    Summary: A table for converting the number of leading clear bits in a
\             number into a bit mask with the same number of leading zeroes
\
\ ******************************************************************************

.leadingBitMask

 EQUB %11111111
 EQUB %01111111
 EQUB %00111111
 EQUB %00011111
 EQUB %00001111
 EQUB %00000111
 EQUB %00000011
 EQUB %00000001

\ ******************************************************************************
\
\       Name: GetHighestTiles
\       Type: Subroutine
\   Category: Landscape
\    Summary: Calculate both the highest tiles in each 4x4 block of tiles in the
\             landscape and the altitude of the highest tile in the landscape
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   maxAltitude         The altitude (i.e. y-coordinate) of the highest tile in
\                       each 4x4 block in the landscape
\
\   xTileMaxAltitude    The tile x-coordinate of the highest tile in each 4x4
\                       block in the landscape
\
\   zTileMaxAltitude    The tile z-coordinate of the highest tile in each 4x4
\                       block in the landscape
\
\   tileAltitude        The altitude of the highest tile in the landscape
\
\ ******************************************************************************

.GetHighestTiles

                        \ This routine works through the tile corners in the
                        \ landscape in 4x4 blocks and finds the highest flat
                        \ tile within each block, so we can consider putting an
                        \ enemy there
                        \
                        \ To do this we split the 32x32-corner landscape up into
                        \ 8x8 blocks of 4x4 tile corners each, iterating along
                        \ each row of 4x4 blocks from left to right, and then
                        \ moving back four rows to the next row of 4x4 blocks
                        \ behind
                        \
                        \ Because the tile corners along the right and back
                        \ edges of the landscape don't have tile altitudes
                        \ associated with them, we ignore those corners

 LDX #0                 \ Set X to loop from 0 to 63, to use as a block counter
                        \ while we work through the landscape in blocks of 4x4
                        \ tiles, of which there are 64 in total

 STX tileAltitude       \ Set tileAltitude = 0 so we can use it to store the
                        \ maximum tile altitude as we work through the landscape
                        \ (so that's the altitude of the landscape's highest
                        \ tile)

.high1

 TXA                    \ Set A = X mod 8
 AND #7                 \
                        \ The 32x32-tile landscape splits up into 8x8 blocks of
                        \ 4x4 tiles each, so this sets A to the number of the
                        \ block along the left-to-right x-axis row that we are
                        \ working along (so A goes from 0 to 7 and around again)

 ASL A                  \ Set xBlock = A * 4
 ASL A                  \
 STA xBlock             \ So xBlock is the tile x-coordinate of the tile in the
                        \ front-left corner of the 4x4 block we are analysing
                        \ (so xBlock goes 0, 4, 8 ... 24, 28)

 TXA                    \ Set A = X div 8
 AND #%00111000         \
                        \ X is in the range 0 to 64, so this instruction has the
                        \ same effect as AND #%11111000, which is equivalent to
                        \ a div 8 operation
                        \
                        \ The 32x32-tile landscape splits up into 8x8 blocks of
                        \ 4x4 tiles each, so this sets A to the number of the
                        \ row of 4x4 blocks along the front-to-back z-axis row
                        \ that we are working along (so A goes 0, 8, 16 ... 56)

 LSR A                  \ Set zBlock = A / 2
 STA zBlock             \
                        \ So zBlock is the tile z-coordinate of the tile in the
                        \ front-left corner of each of the 4x4 blocks in the row
                        \ that we are analysing (so zBlock goes 0, 4, 8 ... 24,
                        \ 28)

                        \ Essentially, by this point we have converted the loop
                        \ counter in X from the sequence 0 to 63 into an inner
                        \ loop of xBlock and an outer loop of zBlock, with both
                        \ variables counting 0, 4, 8 ... 24, 28
                        \
                        \ We can now use (xBlock, zBlock) as a tile coordinate
                        \ and we can store the highest tile altitude within each
                        \ 4x4 block using the index in X

 LDA #0                 \ Zero the X-th entry in the maxAltitude table, which
 STA maxAltitude,X      \ is where we will store the highest tile altitude
                        \ within block X

 LDA #4                 \ Set zCounter = 4 to iterate along the z-axis through
 STA zCounter           \ each tile in the 4x4 block we are analysing, so
                        \ zCounter iterates from 4 down to 1

 LDA zBlock             \ Set zTile = zBlock
 STA zTile              \
                        \ So we can use zTile as the tile z-coordinate of the
                        \ tile to analyse within the 4x4 block

 CMP #28                \ If zBlock < 28 then then we are not on the tile row at
 BCC high2              \ the back of the landscape, so jump to high2 to skip
                        \ the following instruction

 DEC zCounter           \ We are on the tile row at the back of the landscape,
                        \ so set zCounter = 3 so it iterates from 3 down to 1
                        \ for this block, because the blocks along the back row
                        \ are only three tiles deep (as the landscape is 31
                        \ tiles deep)

.high2

 LDA #4                 \ Set xCounter = 4 to iterate along the x-axis through
 STA xCounter           \ each tile in the 4x4 block we are analysing, so
                        \ xCounter iterates from 4 down to 1

 LDA xBlock             \ Set xTile = xBlock
 STA xTile              \
                        \ So we can use xTile as the tile x-coordinate of the
                        \ tile to analyse within the 4x4 block

 CMP #28                \ If xBlock < 28 then we are not at the right end of the
 BCC high3              \ tile row, so jump to high3 to skip the following
                        \ instruction

 DEC xCounter           \ We are at the right end of the tile row, so set
                        \ xCounter = 3 so it iterates from 3 down to 1 for this
                        \ block, because the last block on the row is only three
                        \ tiles across (as the landscape is 31 tiles across)

.high3

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)
                        \
                        \ This also sets the tile page in tileDataPage and the
                        \ tile number in Y, so tileDataPage+Y now points to the
                        \ tile data entry in the tileData table

 AND #%00001111         \ Set A to the tile shape for the tile, which is in the
                        \ bottom nibble of the tile data

 BNE high5              \ If the shape is non-zero then the tile is not flat, so
                        \ jump to high5 to move on to the next tile in the

 LDA (tileDataPage),Y   \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 AND #%11110000         \ Set A to the tile altitude, which is in the top nibble
                        \ of the tile data

 CMP maxAltitude,X      \ If the altitude of the tile we are analysing is lower
 BCC high5              \ than the altitude we have currently stored in the
                        \ maxAltitude table for this 4x4 tile block, jump to
                        \ high5 to move on to the next tile, as this one isn't
                        \ the highest in either this block or the landscape

 STA maxAltitude,X      \ If we get here then ths tile we are analysing is the
                        \ highest in the 4x4 block so far, so store the altitude
                        \ in the maxAltitude table forthis 4x4 tile block so
                        \ the table ends up recording the highest tile altitude
                        \ in each 4x4 block

 CMP tileAltitude       \ Set tileAltitude = max(tileAltitude, A)
 BCC high4              \
 STA tileAltitude       \ So tileAltitude contains the altitude of the highest
                        \ tile that we've analysed so far, which means that
                        \ tileAltitude ends up being set to the highest value
                        \ in the entire landscape, which is the altitude of the
                        \ highest tile of all

.high4

 LDA xTile              \ Store the x-coordinate of the highest tile corner in
 STA xTileMaxAltitude,X \ this block (so far) in the xTileMaxAltitude table
                        \ entry for this 4x4 block

 LDA zTile              \ Store the z-coordinate of the highest tile corner in
 STA zTileMaxAltitude,X \ this block (so far) in the zTileMaxAltitude table
                        \ entry for this 4x4 block

.high5

 INC xTile              \ Increment xTile to move on to the next tile to the
                        \ right, for the inner loop

 DEC xCounter           \ Decrement the x-axis counter within this 4x4 block

 BNE high3              \ Loop back until we have processed all the tiles in the
                        \ 4x4 block, working from left to right

 INC zTile              \ Increment zTile to move on to the next tile towards
                        \ the back, for the outer loop

 DEC zCounter           \ Decrement the z-axis counter within this 4x4 block

 BNE high2              \ Loop back until we have processed all the tile rows in
                        \ the 4x4 block, working from front to back

 INX                    \ Increment the block counter in X

 CPX #64                \ Loop back until we have processed all 63 4x4 blocks
 BCC high1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: UpdateScanner
\       Type: Subroutine
\   Category: Scanner and energy icons
\    Summary: Update the scanner, if required
\
\ ******************************************************************************

.UpdateScanner

 LDA scannerUpdate      \ If scannerUpdate is non-zero then the scanner is
 BNE UpdateScannerNow   \ configured to update, so jump to UpdateScannerNow to
                        \ do just that, returning from the subroutine using a
                        \ tail call

 CMP lastScannerState   \ If the scanner state has not changed since the last
 BEQ scan6              \ time we updated the scanner, jump to scan6 to return
                        \ from the subroutine without updating the scanner

                        \ Otherwise fall through into UpdateScannerNow to update
                        \ the scanner

\ ******************************************************************************
\
\       Name: UpdateScannerNow
\       Type: Subroutine
\   Category: Scanner and energy icons
\    Summary: Update the scanner to a new state
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The new state of the scanner:
\
\                         * 0 = fill scanner with black
\
\                         * 4 = fill the scanner with static in colour 3
\
\                         * 8 = fill scanner with green
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   scan6               Contains an RTS
\
\ ******************************************************************************

.UpdateScannerNow

 STA lastScannerState   \ Store the new state of the scanner in lastScannerState
                        \ so we can use this to check for when the scanner state
                        \ changes in the future

 STA scannerState       \ Store the new state of the scanner in scannerState so
                        \ we can refer to it (and possibly change it) during the
                        \ routine

                        \ We start by calculating the screen address of the
                        \ scanner, which is 79 bytes before the start of the
                        \ player's scrolling landscape view (79 bytes represents
                        \ ten character blocks of eight bytes each, less one
                        \ byte, so the scanner address is the second pixel row
                        \ in the character block that's ten blocks from the
                        \ right end of the energy icon and scanner row at the
                        \ top of the screen (the top pixel row contains the
                        \ scanner box border)
                        \
                        \ viewScreenAddr(1 0) contains the addtress of the
                        \ latter, so we can simply subtract 79

 LDA viewScreenAddr     \ Set (A screenAddr) = viewScreenAddr(1 0) - &004F
 SEC                    \                    = viewScreenAddr(1 0) - 79
 SBC #&4F
 STA screenAddr
 LDA viewScreenAddr+1
 SBC #&00

 CMP #&60               \ If the high byte in A < &60 then the new address is
 BCS scan1              \ before the start of screen memory, so add &20 to the
 ADC #&20               \ high byte so the address wraps around within the range
                        \ of screen memory between &6000 and &8000

.scan1

 STA screenAddr+1       \ Store the high byte of the result, so we now have:
                        \
                        \   screenAddr(1 0) = viewScreenAddr(1 0) - 79
                        \
                        \ with the address wrapped around as required

 LDA #8                 \ The inside portion of the scanner consists of eight
 STA scannerBlock       \ character blocks (the box edges on either side are
                        \ outside of these eight blocks), so set scannerBlock
                        \ to 8 so we can use it to count through the character
                        \ blocks as we draw the scanner
.scan2

                        \ Each character block contains one pixel row at the top
                        \ for the top scanner box edge, then four pixel rows of
                        \ scanner content, followed by another pixel row for the
                        \ bottom scanner box edge
                        \
                        \ We now draw the four pixel rows of scanner content,
                        \ avoiding drawing over the top and bottom edges

 LDY #3                 \ Set Y = 3 to use as a counter for drawing four pixel
                        \ rows in the drawing loop

 JSR GetRandomNumber    \ Set A to a random number to seed the drawing loop, of
                        \ which we use two bits for each of the four pixel bytes
                        \ we draw

 JMP scan4              \ Jump to scan4 to join the drawing loop

.scan3

 LDA scannerStatic      \ Shift the random number in scannerStatic to the right
 LSR A                  \ by two places
 LSR A

.scan4

 STA scannerStatic      \ Store the random number in scannerStatic (on the first
                        \ iteration this is the full random number, while on
                        \ subsequent iterations the number is shifted right by
                        \ two places on each loop)

 AND #%00000011         \ Extract bits 0 and 1 from the random number, so we
                        \ get two different random bits on each iteration and
                        \ a value of A in the range 0 to 3

 ORA scannerState       \ Add the scanner state to the two random bits to get
                        \ the following:
                        \
                        \   * If scannerState = 0 then this leaves A in the
                        \     range 0 to 3
                        \
                        \   * If scannerState = 4 then this sets A into the
                        \     range 4 to 7
                        \
                        \   * If scannerState = 8 then this sets A into the
                        \     range 8 to 11

 TAX                    \ Copy A into X so we can use it as an index into the
                        \ scannerPixelByte table

 LDA scannerPixelByte,X \ Set A to the X-th pixel byte from the relevant part of
                        \ the scannerPixelByte lookup table, which will return a
                        \ pixel byte containing black, random static or green,
                        \ according to the value of scannerState

 STA (screenAddr),Y     \ Draw the Y-th pixel row for this character block in
                        \ the scanner

 DEY                    \ Decrement the pixel row counter in Y

 BPL scan3              \ Loop back to scan3 to draw the next pixel row until we
                        \ have drawn all four pixel rows

                        \ We now move along the scanner to draw the next
                        \ character block to the right

 LDA screenAddr         \ Set (A screenAddr) = screenAddr(1 0) + 8
 CLC
 ADC #&08
 STA screenAddr
 LDA screenAddr+1
 ADC #&00

 CMP #&80               \ If the high byte in A >= &80 then the new address is
 BCC scan5              \ past the end of screen memory, so subtract &20 from
 SBC #&20               \ the high byte so the address wraps around within the
                        \ range of screen memory between &6000 and &8000

.scan5

 STA screenAddr+1       \ Store the high byte of the result, so we now have:
                        \
                        \   screenAddr(1 0) = screenAddr(1 0) + 8
                        \
                        \ with the address wrapped around as required
                        \
                        \ This updates screenAddr(1 0) to point to the next
                        \ character block to the right, so we move along the
                        \ scanner

 DEC scannerBlock       \ Decrement scannerBlock to move on to the next block
                        \ in the scanner

 BEQ scan6              \ If we have drawn all eight columns, jump to scan6 to
                        \ return 

 LDA scannerBlock       \ If scannerBlock <> 4 then loop back to scan2 to keep
 CMP #4                 \ drawing the scanner
 BNE scan2

                        \ If we get here then scannerBlock = 4, so we have drawn
                        \ the left half of the scanner

 LDA playerTileIsHidden \ If playerTileIsHidden <> 64 then the player's tile is
 CMP #64                \ not hidden from the Sentinel or sentry doing the scan,
 BNE scan2              \ so loop back to scan2 to keep drawing the scanner

 LDA #0                 \ If we get here then playerTileIsHidden = 64, so the
 STA scannerState       \ player's tile is hidden from the Sentinel or sentry
                        \ doing the scan
                        \
                        \ We represent this by only filling the left half of the
                        \ scanner and leaving the right half blank, so set
                        \ scannerState to zero so the rest of the fill routine
                        \ fills the right half with black

 BEQ scan2              \ Jump back to scan2 to keep drawing the scanner (this
                        \ BEQ is effectively a JMP as A is always zero)

.scan6

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: scannerStatic
\       Type: Variable
\   Category: Scanner and energy icons
\    Summary: Storage for a random number that's used to generate static in the
\             scanner
\
\ ******************************************************************************

.scannerStatic

 EQUB 0

\ ******************************************************************************
\
\       Name: scannerBlock
\       Type: Variable
\   Category: Scanner and energy icons
\    Summary: A counter for the eight character blocks that make up the scanner
\
\ ******************************************************************************

.scannerBlock

 EQUB 0

\ ******************************************************************************
\
\       Name: scannerState
\       Type: Variable
\   Category: Scanner and energy icons
\    Summary: The current state of the scanner (black, static or green)
\
\ ******************************************************************************

.scannerState

 EQUB 0                 \ The current state of the scanner:
                        \
                        \   * 0 = fill scanner with black
                        \
                        \   * 4 = fill the scanner with static in colour 3
                        \
                        \   * 8 = fill scanner with green

\ ******************************************************************************
\
\       Name: scannerPixelByte
\       Type: Variable
\   Category: Scanner and energy icons
\    Summary: Pixel bytes for the three states of the scanner (black, static and
\             green)
\
\ ******************************************************************************

.scannerPixelByte

 EQUB %00001111         \ Four bytes of colour 1 (black) for scanner state 0
 EQUB %00001111
 EQUB %00001111
 EQUB %00001111

 EQUB %10001111         \ Four bytes of static in colour 3 on a background of
 EQUB %01001111         \ colour 1 (black)
 EQUB %00101111
 EQUB %00011111

 EQUB %11111111         \ Four bytes of colour 3 (green) for scanner state 8
 EQUB %11111111
 EQUB %11111111
 EQUB %11111111

\ ******************************************************************************
\
\       Name: sub_C16A8
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C16A8

 TSX                    \ Store the stack pointer in gameplayStack so we can
 STX gameplayStack      \ restore the stack to this point in time (i.e. just
                        \ after we call sub_C16A8 from the ProcessGameplay
                        \ routine, so the return address at this point on the
                        \ stack will take us back to ProcessGameplay when we
                        \ next execute an RTS instruction)

 LDX enemyObject
 LDA objectTypes,X
 CMP #&01
 BEQ C16B9
 CMP #&05
 BNE sub_C16C9

.C16B9

 STA titleObjectToDraw

 LDA objectFlags,X      \ Set A to the object flags for object #X

 BPL C16D9
 JSR sub_C1A54
 BCS sub_C16C9
 JMP C1871

\ ******************************************************************************
\
\       Name: sub_C16C9
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C16C9

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers

 DEC enemyObject        \ ??? This is the only place enemyObject is updated, it
 BPL C16D4              \ seems to contain an enemy object number, 0 to 7
 LDA #&07
 STA enemyObject

.C16D4

 LDA playerObject       \ Set viewingObject to the object number of the player
 STA viewingObject

 RTS

.C16D9

 LDA objRotationTimer,X
 CMP #&02
 BCS sub_C16C9
 LDA #&04
 STA objRotationTimer,X
 LDA #&14
 STA L0C68
 LDA enemyData5,X
 BPL C16F2
 JMP C176A

.C16F2

 STA viewingObject
 LDY enemyData6,X
 LDA objectFlags,Y
 BMI C174F
 LDA #0
 JSR sub_C1882
 LDA objectViewYawHi
 CMP #&14
 BCS C171B
 CPY playerObject
 BNE C174F
 LDA L0014
 BEQ C1754

 JSR PerformHyperspace  \ Hyperspace the player to a brand new tile

 LDA #4
 STA titleObjectToDraw

 JMP sub_C16C9

.C171B

 LDA #&08
 BIT objectViewYawHi
 BPL C1724
 LDA #&F8

.C1724

 STA L0C0E
 LDY enemyObject
 LDX enemyData5,Y
 TXA
 JSR sub_C1AE7
 LDA objectYawAngle,X
 CLC
 ADC L0C0E
 STA objectYawAngle,X
 LDA #&0A
 STA objRotationTimer,Y
 TXA
 PHA
 LDX #&03
 LDY #&46

 LDA #1                 \ Make sound #1 (???) with the pitch in X and Y
 JSR MakeSound-6

 PLA
 TAX
 JMP C1876

.C174F

 LDA #0
 STA L0C20,X

.C1754

 LDY enemyObject
 LDX enemyData5,Y
 TXA
 JSR sub_C1AE7
 LDA #&80
 STA enemyData5,Y
 LDA #&02
 STA objectTypes,X
 JMP C1871

.C176A

 STX viewingObject
 JSR sub_C1A54
 BCS C1774
 JMP C1871

.C1774

 LDX enemyObject
 LDA enemyData8,X
 BPL C178C
 JSR sub_C1AA7
 LDX enemyObject
 BCS C1789
 LDA #&40
 STA enemyData1,X
 BNE C17E1

.C1789

 LSR enemyData8,X

.C178C

 LDA L0C20,X
 BEQ C17A3
 LDY enemyData6,X
 LDA #0
 JSR sub_C1882
 LDA L0014
 BEQ C17A0
 JMP C1820

.C17A0

 STA L0C20,X

.C17A3

 LDA #&80
 STA L000F
 LDY #&3F

.P17A9

 LDA #0
 JSR sub_C1882
 LDA L0C76
 AND #&40
 BNE C17C1
 LDA L0014
 BEQ C17C1
 BMI C1820
 CPY playerObject
 BNE C17C1
 STY L000F

.C17C1

 DEY
 BPL P17A9
 LDY L000F
 BMI C17D7
 TYA
 CMP enemyData3,X
 BEQ C17D7
 JSR SetEnemyData
 LDA #&40
 STA L0014
 BNE C1820

.C17D7

 LDA #0
 STA L0C20,X
 JSR sub_C1AA7
 BCS C17F0

.C17E1

 JSR DrainObjectEnergy
 BCS C17F9
 LDY enemyObject
 LDA #&1E
 STA objRotationTimer,Y
 JMP C1871

.C17F0

 LDX enemyObject
 LDA L0C28,X
 CMP #&02
 BCC C17FC

.C17F9

 JMP sub_C16C9

.C17FC

 TXA
 JSR sub_C1AE7
 LDA objectYawAngle,X
 CLC
 ADC objRotationSpeed,X
 STA objectYawAngle,X
 LDA #&C8
 STA L0C28,X
 JSR SetEnemyData
 LDX #&07
 LDY #&78

 LDA #0                 \ Make sound #0 (???) with the pitch in X and Y
 JSR MakeSound-6

 LDX enemyObject
 JMP C1876

.C1820

 TYA
 STA enemyData6,X
 LDA L0014
 STA enemyData7,X
 LDA L0C20,X
 CMP #&01
 BCS C1838
 LDA #&78
 STA L0C20,X

.P1835

 JMP sub_C16C9

.C1838

 BNE P1835
 LDA L0014
 BPL C184D
 JSR DrainObjectEnergy
 LDY enemyObject
 LDA #&1E
 STA objRotationTimer,Y
 BCS C187F
 JMP C1871

.C184D

 JSR sub_C197D
 LDY enemyObject
 BCC C1869
 LDA enemyData4,Y
 CMP #&02
 BCS C1862
 LDA #&80
 STA enemyData8,Y
 BNE C187F

.C1862

 LDA #0
 STA L0C20,Y
 BEQ C187F

.C1869

 LDA #&32
 STA objRotationTimer,Y
 LDX enemyData5,Y

.C1871

 LDA #&40
 STA L0C6D

.C1876

 STX currentObject

 LDA playerObject       \ Set viewingObject to the object number of the player
 STA viewingObject

 JSR sub_C1F84

.C187F

 JMP sub_C16C9

\ ******************************************************************************
\
\       Name: sub_C1882 (Part 1 of 2)
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C1882

 STA T
 STX L1919
 STY targetObject
 LDA #0
 STA L0014
 LDA objectFlags,Y
 BMI C1911
 LDA objectTypes,Y
 CMP T
 BNE C1911
 JSR GetObjectAngles

                        \ We now have a very short interlude to set up some of
                        \ the anti-cracker code before continuing in part 2

\ ******************************************************************************
\
\       Name: AlterCrackerSeed
\       Type: Subroutine
\   Category: Cracker protection
\    Summary: Create an altered version of the anti-cracker seed-related data,
\             as part of the anti-cracker code
\
\ ******************************************************************************

.AlterCrackerSeed

 LDX #7                 \ Set X = 7, to add to the cracker seed when its last
                        \ digit is 9, so we effectively add 700 to the
                        \ landscape number

 LDA CrackerSeed+1-7,X  \ Set T to the contents of CrackerSeed+1, which we set
 STA T                  \ in the SetCrackerSeed routine to the high byte of the
                        \ binary coded decimal (BCD) landscape number
                        \
                        \ So if the landscape number 0123, T contains 01 in BCD
                        \ format

 AND #%00001111         \ Set A to the second digit in the BCD landscape number

 CMP #9                 \ If the second digit in the BCD number is 9, skip the
 BEQ alts1              \ following instruction so that X stays set to 7

 LDX #1                 \ Otherwise set X = 1, for when the second digit is in
                        \ the range 0 to 8, so we effectively add 100 to the
                        \ landscape number

.alts1

 TXA                    \ Set alteredSeed = T + X
 CLC                    \
 ADC T                  \ Note that this addition is not done in BCD mode, so we
 STA alteredSeed        \ know that the following is true:
                        \
                        \   alteredSeed > T
                        \
                        \ so:
                        \
                        \   alteredSeed > CrackerSeed+1
                        \
                        \ as the largest possible value of T is &99 when the
                        \ value of X is the largest possible at 7, and:
                        \
                        \   &99 + 7 = &A0
                        \
                        \ so the addition never overflows and the result in
                        \ alteredSeed is greater than the original high byte in
                        \ CrackerSeed+1
                        \
                        \ This fact is used in the CheckCrackerSeed routine to
                        \ ensure that this part of the anti-cracker code has
                        \ been run correctly

                        \ Fall through into part 2 of sub_C1882 to continue with
                        \ the ???

\ ******************************************************************************
\
\       Name: sub_C1882 (Part 2 of 2)
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

 LDA L0C68
 LSR A
 STA T
 LDA objectViewYawHi
 SEC
 SBC #&0A
 CLC
 ADC T
 CMP L0C68
 BCS C1912
 LDA angleLo
 STA vectorYawAngleLo
 LDA angleHi
 STA vectorYawAngleHi
 LDA #&02
 STA L001E
 LDA objTypeToAnalyse
 BNE C18FF

 SEC                    \ Set bit 7 of L0C6E ???
 ROR L0C6E

 LDA yDeltaLo
 STA xDeltaLo
 LDA yDeltaHi

.C18E1

 JSR GetPitchAngleDelta
 LDA angleLo
 STA vectorPitchAngleLo
 STA T
 LDA angleHi
 STA vectorPitchAngleHi
 JSR GetVectorForAngles
 JSR FollowGazeVector
 ROL targetOnTile
 ROR L0014
 ROL gazeCanSeeTree
 ROR L0C76

.C18FF

 LSR L0C6E              \ Clear bit 7 of L0C6E ???

 LDA yDeltaLo
 SEC
 SBC #&E0
 STA xDeltaLo
 LDA yDeltaHi
 SBC #&00
 DEC L001E
 BNE C18E1

.C1911

 CLC

.C1912

 LDX L1919
 LDY targetObject
 RTS

\ ******************************************************************************
\
\       Name: L1919
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L1919

 EQUB &00

\ ******************************************************************************
\
\       Name: sub_C191A
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C191A

 LDY #0
 STY T
 LDX #&07

.C1920

 LDA objectFlags,X      \ Set A to the object flags for object #X

 BMI C1945

 LDA objectTypes,X

 CMP #&01
 BEQ C1930
 CMP #&05
 BNE C1945

.C1930

 LDA enemyData6,X
 CMP playerObject
 BNE C1945
 LDA L0C20,X
 BEQ C1945
 LDY #&04
 LDA enemyData7,X
 STA T
 BMI C1948

.C1945

 DEX
 BPL C1920

.C1948

 STY scannerUpdate
 LDA T
 STA playerTileIsHidden
 LDA soundEffect
 CPY soundEffect
 STY soundEffect
 BEQ CRE08
 LDY #&12
 STY soundData+16       \ First parameter of sound block #2 (channel)
 CMP #&03
 BEQ CRE08
 LDX #&06
 JSR FlushBuffer

.CRE08

 RTS

\ ******************************************************************************
\
\       Name: SetEnemyData
\       Type: Subroutine
\   Category: Gameplay
\    Summary: ???
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The object number of the enemy being added
\
\ ******************************************************************************

.SetEnemyData

 LDA #%10000000         \ Set bit 7 of enemyData5 for object #X ???
 STA enemyData5,X

 STA enemyData3,X       \ Set bit 7 of enemyData3 for object #X ???

 LDA #0                 \ Zero enemyData4 for object #X ???
 STA enemyData4,X

 LDA #%01000000         \ Clear bit 7 and set bit 6 of enemyData1 for object #X
 STA enemyData1,X       \ ???

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C197D
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C197D

 LDA #&28
 STA L0C68
 LDX enemyObject
 STX viewingObject

.C1986

 LDX enemyObject
 LDY enemyData1,X
 BNE C1998
 INC enemyData4,X
 LDA enemyData6,X
 STA enemyData3,X
 SEC
 RTS

.C1998

 DEC enemyData1,X
 DEY
 LDA objectFlags,Y
 BMI C1986
 LDA objectTypes,Y
 CMP #&02
 BNE C1986
 LDA enemyData6,X
 TAX
 LDA xObject,X
 SEC
 SBC xObject,Y
 BPL C19BA
 EOR #&FF
 CLC
 ADC #&01

.C19BA

 CMP #&0A
 BCS C1986
 LDA zObject,X
 SEC
 SBC zObject,Y
 BPL C19CC
 EOR #&FF
 CLC
 ADC #&01

.C19CC

 CMP #&0A
 BCS C1986
 LDA #&02
 JSR sub_C1882
 LDA L0014
 BPL C1986
 LDX enemyObject
 TYA
 JSR sub_C1AF3
 BCC C19F1
 TYA
 STA enemyData5,X
 LDA #&04
 STA objectTypes,Y
 LDA #&68
 STA L0CD4
 CLC
 RTS

.C19F1

 INC enemyData1,X

 JMP sub_C1AEC          \ Jump to sub_C16C9 via sub_C1AEC to ???

\ ******************************************************************************
\
\       Name: DrainObjectEnergy
\       Type: Subroutine
\   Category: Gameplay
\    Summary: Drain energy from an object, transforming it into an object with
\             an energy level of one unit less (if applicable)
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   targetObject        The number of the object being drained of energy
\
\   enemyObject         The number of the object doing the draining
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   C flag              Result flag:
\
\                         * Set if the player object is being drained and they
\                           still have a positive energy level after the
\                           draining
\
\                         * Clear if one of the following is true:
\
\                           * The player object is being drained and they now
\                             have a negative energy level, so the Sentinel has
\                             won
\
\                           * The player object is not being drained
\
\ ******************************************************************************

.dobj1

                        \ If we jump here from below here then the player has
                        \ run out of energy

 LDA #%10000000         \ Set bit 7 of sentinelHasWon to indicate that the
 STA sentinelHasWon     \ player has run out of energy and the Sentinel has won

 JMP sub_C1AEC          \ Jump to sub_C16C9 via sub_C1AEC to ???

.DrainObjectEnergy

 LDX targetObject       \ Set X to the object number that is being drained of
                        \ energy

 CPX playerObject       \ If this is not the player object, jump to dobj2 to
 BNE dobj2              \ drain energy from object #X rather than the player

                        \ If we get here then this is the player object, so we
                        \ now drain energy from the player

 LDA playerEnergy       \ If the player has no energy then draining more energy
 BEQ dobj1              \ will kill them, so jump to dobj1 to process this

 SEC                    \ Subtract 1 from the player's energy
 SBC #1
 STA playerEnergy

 JSR UpdateIconsScanner \ Update the icons in the top-left corner of the screen
                        \ to show the player's current energy level and redraw
                        \ the scanner box

 LDA #5                 \ Make sound #5 (ping)
 JSR MakeSound

 SEC                    \ Set the C flag to indicate that the player still has a
                        \ non-zero energy level

 JMP dobj7              \ Jump to dobj7 to finish up and return from the
                        \ subroutine

.dobj2

                        \ If we get here then we need to drain energy from
                        \ object #X

 TXA                    \ Call sub_C1AE7 with the object number in A ???
 JSR sub_C1AE7

 LDA objectTypes,X      \ Set A to the type of object #X

 BNE dobj3              \ If object #X is not a robot (i.e. not an object of
                        \ type 0), jump to dobj3

                        \ If we get here then we are draining energy from a
                        \ robot in object #X

 LDY enemyObject        \ Set L0C20 for the enemy object to zero ???
 LDA #0
 STA L0C20,Y

 LDA #3                 \ Set A = 3 so the robot loses one energy unit and
                        \ changes into a boulder (i.e. an object of type 3)

 BNE dobj5              \ Jump to dobj5 to set the new object type of object #X
                        \ to the value in A, so the robot turns into a boulder

.dobj3

 CMP #2                 \ If object #X is not a tree (i.e. not an object of
 BNE dobj4              \ type 2), jump to dobj4

                        \ If we get here then we are draining energy from a
                        \ tree in object #X

 JSR DeleteObject       \ Delete object #X and remove it from the landscape,
                        \ as trees only have one energy unit, so draining one
                        \ unit from a tree removes it altogether

 JMP dobj6              \ Jump to dobj6 to skip updating the energy for object
                        \ #X, as we just deleted it

.dobj4

                        \ If we get here then we must be draining energy from a
                        \ boulder in object #X

 LDA #116               \ Set L0CD4 = 116 ???
 STA L0CD4

 LDA #2                 \ Set A = 2 so the boulder loses one energy unit and
                        \ changes into a tree (i.e. an object of type 2)

.dobj5

 STA objectTypes,X      \ Set the object type of object #X to the new type in A

.dobj6

 CLC                    \ Clear the C flag to return from the subroutine

.dobj7

 PHP                    \ Store the C flag on the stack so we can retrieve it
                        \ below to return from the subroutine

 LDY enemyObject        \ Increment the energy level for the enemy object by one
 LDA enemyEnergy,Y      \ unit, as the enemy just absorbed one unit from the
 CLC                    \ target object
 ADC #1
 STA enemyEnergy,Y

 PLP                    \ Retrieve the C flag from the stack to return from the
                        \ subroutine

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sub_C1A54
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C1A54

 LDX enemyObject

 SEC

 LDA enemyEnergy,X
 BEQ CRE09

 LDA #2                 \ Spawn a tree (an object of type 2), returning the
 JSR SpawnObject        \ object number of the new object in X and currentObject

 LDA minEnemyAltitude

 JSR PlaceObjectBelow   \ Attempt to place the object on a tile that is
                        \ below the maximum altitude specified in A (though we
                        \ may end up placing the object higher than this)

 BCS CRE09              \ If the call to PlaceObjectBelow sets the C flag then
                        \ the object has not been successfully placed, so jump
                        \ to CRE09 to return from the subroutine with the C flag
                        \ set

 TXA
 JSR sub_C1AF3

 BCC C1A78

 LDX enemyObject
 DEC enemyEnergy,X

 LDX currentObject

 CLC

.CRE09

 RTS

.C1A78

 JSR DeleteObject       \ Delete object #X and remove it from the landscape

 JMP sub_C1AEC          \ Jump to sub_C16C9 via sub_C1AEC to ???

\ ******************************************************************************
\
\       Name: FinishLandscape
\       Type: Subroutine
\   Category: Main game loop
\    Summary: Add the player's energy to the landscape number to get the number
\             of the next landscape and display that landscape's secret code
\
\ ******************************************************************************

.FinishLandscape

 SED                    \ Set the D flag to switch arithmetic to binary coded
                        \ decimal (BCD), so the call to GetPlayerEnergyBCD and
                        \ the following addition are all done in BCD

 JSR GetPlayerEnergyBCD \ Set A to the player's energy in BCD

 CLC                    \ Set (Y X) = (landscapeNumberHi landscapeNumberLo) + A
 ADC landscapeNumberLo  \
 TAX                    \ This addition is done in BCD so the result is a new
 LDA landscapeNumberHi  \ landscape number that's also in BCD (which we need to
 ADC #0                 \ do as landscape numbers are in BCD)
 TAY

 CLD                    \ Clear the D flag to switch arithmetic to normal

 JSR InitialiseSeeds    \ Initialise the seed number generator to generate the
                        \ sequence of seed numbers for the landscape number in
                        \ (Y X) and set maxNumberOfEnemies and the landscapeZero
                        \ flag accordingly

                        \ We set bit 7 of doNotPlayLandscape when the landscape
                        \ was completed in the PerformHyperspace routine, so the
                        \ following calls to GenerateLandscape and SpawnPlayer
                        \ return normally, without previewing the landscape
                        \ (GenerateLandscape) or starting the game (SpawnPlayer)

 JSR GenerateLandscape  \ Call GenerateLandscape to generate the landscape

 JSR SpawnEnemies       \ Calculate the number of enemies for this landscape,
                        \ add them to the landscape and set the palette
                        \ accordingly

 JSR SpawnPlayer        \ Add the player and trees to the landscape

 LDA #&80               \ Call DrawTitleScreen with A = &80 to draw the screen
 JSR DrawTitleScreen    \ showing the landscape's secret code

 LDX #5                 \ Print text token 5: Print "SECRET ENTRY CODE" at
 JSR PrintTextToken     \ (64, 768), "LANDSCAPE" at (192, 704), move cursor
                        \ right

 JMP PrintLandscapeNum  \ Print the four-digit landscape (0000 to 9999) and
                        \ return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: sub_C1AA7
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C1AA7

 LDX #&3F

.C1AA9

 LDA objectFlags,X      \ Set A to the object flags for object #X

 BMI C1AE2

 CMP #&40
 BCS C1AB9
 LDA objectTypes,X
 CMP #&03
 BNE C1AE2

.C1AB9

 LDA xObject,X          \ Set (xTile, zTile) to the tile coordinates of the
 STA xTile              \ tile containing object #X
 LDA zObject,X
 STA zTile

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile), setting the C flag if the tile
                        \ contains an object

 BCC C1AE2
 AND #&3F
 TAY
 LDA objectTypes,Y
 CMP #&02
 BEQ C1AD6
 CMP #&03
 BNE C1AE2

.C1AD6

 JSR sub_C1882
 LDA L0014
 BPL C1AE2
 STY targetObject
 CLC
 RTS

.C1AE2

 DEX
 BPL C1AA9
 SEC
 RTS

\ ******************************************************************************
\
\       Name: sub_C1AE7
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C1AE7

 JSR sub_C1AF3
 BCS CRE10

\ ******************************************************************************
\
\       Name: sub_C1AEC
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C1AEC

 LDX gameplayStack      \ Restore the stack pointer to the position it was in
 TXS                    \ when we called sub_C16A8 from ProcessGameplay, so the
                        \ return address at this point on the stack will take
                        \ us back to ProcessGameplay when we next execute an RTS
                        \ instruction

 JMP sub_C16C9          \ Jump to sub_C16C9 to ???

\ ******************************************************************************
\
\       Name: sub_C1AF3
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C1AF3

 SEC

 BIT samePanKeyPress    \ If bit 6 of samePanKeyPress is clear then the player
 BPL CRE10              \ if not holding down the same pan key following the
                        \ completion of a landscape pan, so jump to CRE10 to
                        \ return from the subroutine

                        \ If we get here then we have just completed a pan of
                        \ the landscape view and the player is still holding
                        \ down the same pan key

 STA currentObject

 LDA playerObject       \ Set viewingObject to the object number of the player
 STA viewingObject

 TXA
 PHA
 TYA
 PHA
 JSR sub_C2096
 PLA
 TAY
 PLA
 TAX

.CRE10

 RTS

\ ******************************************************************************
\
\       Name: ProcessActionKeys (Part 1 of 2)
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Process an action key press from key logger entry 1 (absorb,
\             transfer, create, hyperspace, U-turn)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   C flag              Status flag:
\
\                         * Clear if we have added or removed an object:
\
\                           * Player has absorbed (and therefore removed) an
\                             object
\
\                           * Player has created an object
\
\                         * Set if we have not added or removed any objects:
\
\                           * Player has hyperspaced
\
\                           * Player has done a U-turn
\
\                           * Player has transferred to a new tile
\
\                           * Player has tried to do something that results in
\                             an error sound and no action (such as trying to
\                             transfer to an empty tile or into an object that
\                             isn't a robot, for example)
\
\ ******************************************************************************

.ProcessActionKeys

 LDA keyPress           \ Set A to the value from the key logger for the key
                        \ press we want to process, which we know contains a
                        \ valid key press as we only call this routine when
                        \ bit 7 of the key logger value is clear
                        \
                        \ The possible values for key logger entry 1 are:
                        \
                        \   * 0  for key press "R" (Create robot)
                        \   * 2  for key press "T" (Create tree)
                        \   * 3  for key press "B" (Create boulder)
                        \   * 32 for key press "A" (Absorb)
                        \   * 33 for key press "Q" (Transfer)
                        \   * 34 for key press "H" (Hyperspace)
                        \   * 35 for key press "U" (U-turn)
                        \
                        \ So now we perform the correct action for the key press
                        \ in A

 CMP #34                \ If A <> 34 then the "H" key (hyperspace) is not being
 BNE pkey2              \ pressed, so jump to pkey2 to move on to the next check

                        \ If we get here then "H" (hyperspace) is being pressed

 JSR PerformHyperspace  \ Hyperspace the player to a brand new tile

 LDA #0                 \ Set titleObjectToDraw to the object type for a robot,
 STA titleObjectToDraw  \ so if the hyperspace fails because the player doesn't
                        \ have enough energy, then the game over screen will
                        \ show a robot to indicate that the player was
                        \ responsible for their own demise

.pkey1

 SEC                    \ Set the C flag to denote that no object has been added
                        \ or removed by the routine

 RTS                    \ Return from the subroutine

.pkey2

 LDX viewingObject      \ Set X to the object number of the viewer, which we set
                        \ to the player object in MainGameLoop before getting
                        \ here via the ProcessGameplay routine

 CMP #35                \ If A <> 35 then the "U" key (U-turn) is not being
 BNE pkey3              \ pressed, so jump to pkey3 to move on to the next check

                        \ If we get here then "U" (U-turn) is being pressed

                        \ If we get here with bit 6 of uTurnStatus set, then
                        \ this is the first time we have reached this point
                        \ since the key was pressed (as we are about to clear
                        \ bit 6), so we can perform the requested U-turn
                        \
                        \ If we get here with bit 6 of uTurnStatus clear, then
                        \ this isn't the first time we've reached this point
                        \ since the key was pressed, so in this case we don't
                        \ do another U-turn, as we're already done one

 ASL uTurnStatus        \ Clear bit 6 uTurnStatus to prevent the "U" key from
                        \ performing a U-turn, so that the "U" key has to be
                        \ released before a second U-turn can be performed

 BPL pkey1              \ If bit 7 of uTurnStatus is now clear, then that means
                        \ that bit 6 was clear before the above shift, which
                        \ means we are currently ignoring the "U" key to prevent
                        \ doing a second U-turn, so jump to pkey1 to skip doing
                        \ another U-turn and instead return from the subroutine
                        \ with the C flag set

                        \ If we get here then "U" is being pressed and bit 6 of
                        \ uTurnStatus was set before being cleared above, so we
                        \ now perform a U-turn

 LDA objectYawAngle,X   \ Rotate the player's yaw angle through 180 degrees by
 EOR #%10000000         \ flipping bit 7, which turns the player around
 STA objectYawAngle,X

 LDA #40                \ Set A = 40 to pass to the PlayMusic routine after we
                        \ jump to pkey4, so it plays the music for a U-turn

 BNE pkey4              \ Jump to pkey4 to play the U-turn music and return from
                        \ the subroutine with the C flag set (this BNE is
                        \ effectively a JMP as A is never zero)

.pkey3

                        \ If we get here then the key press is either create,
                        \ absorb or transfer

 LSR L0C6E              \ Clear bit 7 of L0C6E ???

 JSR GetSightsVector    \ Calculate the vector from the player's eyes to the
                        \ sights, returning it in both angle format:
                        \
                        \   (vectorYawAngleHi vectorYawAngleLo)
                        \
                        \   (vectorPitchAngleHi vectorPitchAngleLo)
                        \
                        \ and as a cartesian vector:
                        \
                        \   [ (xVectorLo xVectorBot) ]
                        \   [ (yVectorLo yVectorBot) ]
                        \   [ (zVectorLo zVectorBot) ]
                        \
                        \ This vector is the vector from the player's eyes to
                        \ the sights, divided by 16 by the GetVectorForAngles
                        \ routine that GetSightsVector uses
                        \
                        \ The "divided by 16" part is important, as we want to
                        \ divide the vector from the player to the sights into
                        \ small steps, so we can move along the vector
                        \ sequentially, checking on each step whether the
                        \ vector is passing through a flat tile or platform

 JSR FollowGazeVector   \ Follow the gaze vector from a viewing object to
                        \ determine whether the player's sights can see a flat
                        \ tile or platform (i.e. boulder or tower)
                        \
                        \ If it does hit a tile or platform, it sets xCoordHi
                        \ and zCoordHi to the tile coorsinates of the tile,
                        \ which we use below for creating or removing objects
                        \ on the tile in the sights

 BCS pkey7              \ If the C flag is set then this means the player can't
                        \ see a tile or platform through the sights, so jump to
                        \ pkey7 to make an error sound and return from the
                        \ subroutine as we can't see a suitable surface for the
                        \ create, absorb or transfer action

 LDA keyPress           \ If bit 5 of keypress is clear then A is not 32 or 33,
 AND #%00100000         \ so A must be 0, 2 or 3 (one of the create keys), so
 BEQ pkey8              \ jump to pkey8 to spawn a robot, tree or boulder

                        \ If we get here then A must be 32 or 33, so the key
                        \ press is either absorb or transfer

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile), setting the C flag if the tile
                        \ contains an object

 BCC pkey7              \ The tile does not contain an object, so jump to pkey7
                        \ to make an error sound and return from the subroutine
                        \ as we can't absorb or transfer to an empty tile

 AND #%00111111         \ Because the tile has an object on it, the tile data
 TAX                    \ contains the number of the top object on the tile in
                        \ bits 0 to 5, so extract the object number into X

 LDA keyPress           \ If bit 0 of keypress is clear then A must be 32, which
 LSR A                  \ is absorb, so jump to pkey5 to absorb the object on
 BCC pkey5              \ the tile anchored at (xTile, zTile)

                        \ If we get here then A must be 33, so the key press is
                        \ transfer and the player is trying to transfer to the
                        \ tile anchored at (xTile, zTile), which contains
                        \ object #X

 LDY objectTypes,X      \ Set Y to the type of object #X

 BNE pkey7              \ If object #X is not a robot (i.e. not an object of
                        \ type 0), jump to pkey7 to make an error sound and
                        \ return from the subroutine as the player can only
                        \ transfer into other robots

 JSR FocusOnKeyAction   \ Tell the game to start focusing effort on the key
                        \ action that has been initiated (i.e. the transfer)

 STX playerObject       \ Set the player's object number to that of the robot
                        \ on the tile anchored at (xTile, zTile), so this
                        \ effectively performs the transfer across to the new
                        \ robot

                        \ We now take a short interlude to set the value of
                        \ playerIsOnTower, as part of the game's anti-cracker
                        \ code, and we pick up the robot transfer code in part 2

\ ******************************************************************************
\
\       Name: SetPlayerIsOnTower
\       Type: Subroutine
\   Category: Cracker protection
\    Summary: Set up the playerIsOnTower value for checking the game is won, as
\             part of the anti-cracker code
\
\ ******************************************************************************

.SetPlayerIsOnTower

                        \ We now work out whether the player just transferred
                        \ into a robot on the Sentinel's tower
                        \
                        \ We do this by starting at object #X, which is the
                        \ robot that the player just transferred into, and if
                        \ it's on top of another object or stack of objects, we
                        \ work our way down the stack, checking to see if the
                        \ stack contains the Sentinel's tower
                        \
                        \ The Sentinel's tower is always the first object to be
                        \ spawned, and object numbers are allocated from 63 and
                        \ down, so this means the tower is always object #63, or
                        \ %111111, so that's what we look for while working
                        \ through the object stack
                        \
                        \ This forms part of the code to protect the game from
                        \ crackers, as all we do with this information is to set
                        \ playerIsOnTower to the object type of the tower (which
                        \ is 6). This value is then used to generate the secret
                        \ code for the completed landscape, so if crackers have
                        \ jumped straight to the end of the level without
                        \ setting playerIsOnTower to 6, then the wrong code will
                        \ be generated in the SpawnSecretCode3D routine

.ptow1

 LDA objectFlags,X      \ Set A to the object flags for object #X

 CMP #%01000000         \ If both bits 6 and 7 of the object flags for object #X
 BCC ptow2              \ are clear then object #X is not stacked on top of
                        \ another object (so if we have looped back here from
                        \ below, we have reached the bottom of the stack), so
                        \ jump to ptow2 to stop looping through the object stack
                        \ and go back to the ProcessActionKeys routine

                        \ If we get here then object #X is stacked on top of
                        \ another object, and the number of the object below
                        \ object #X is in bits 0 to 5 of the object flags for
                        \ object #X, which is currently in A

 AND #%00111111         \ Extract bits 0 to 5 of the object flags into A and X,
 TAX                    \ so X now contains the object number of the next object
                        \ down in the stack

 EOR #%00111111         \ If the object number in A is not the Sentinel's tower
 BNE ptow1              \ (i.e. it is not 63, or %111111), then loop back to
                        \ check the next object down in the stack

                        \ If we get here then the player has just transferred
                        \ into a robot on the Sentinel's tower

 LDA objectTypes,X      \ Set playerIsOnTower = 6 (which is the object type of
 STA playerIsOnTower    \ the Sentinel's tower, whose object number is in X)

.ptow2

                        \ Fall through into part 2 of ProcessActionKeys to
                        \ continue with the robot transfer

\ ******************************************************************************
\
\       Name: ProcessActionKeys (Part 2 of 2)
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Process an action key press from key logger entry 1 (absorb,
\             transfer, create, hyperspace, U-turn)
\
\ ******************************************************************************

                        \ If we get here then the player has just transferred
                        \ into a robot

 LDA #25                \ Set A = 25 to pass to the PlayMusic routine so it
                        \ plays the music for when the player transfers into a
                        \ new robot

.pkey4

 JSR PlayMusic          \ Call PlayMusic to play the music specified in A (so
                        \ that's either the music for transferring into a new
                        \ robot or the music for a U-turn)

 LDA #%10000000         \ Set bit 7 of playerHasMovedTile to indicate that the
 STA playerHasMovedTile \ player has moved to a new tile

 SEC                    \ Set the C flag to denote that no object has been added
                        \ or removed by the routine

 RTS                    \ Return from the subroutine

.pkey5

                        \ If we get here then we are absorbing an object of type
                        \ X from the tile anchored at (xTile, zTile)

 LDA objectFlags        \ The Sentinel is always object #0, so this checks
 BMI pkey7              \ whether bit 7 of the Sentinel's object is set, which
                        \ indicates that the Sentinel's object number is not
                        \ allocated
                        \
                        \ This means that the Sentinel no longer exists and has
                        \ been absorbed by the player, at which point the player
                        \ is no longer allowed to absorb other objects, so jump
                        \ to pkey7 to make an error sound and return from the
                        \ subroutine

 LDA objectTypes,X      \ If the player is trying to absorb a meanie (an object
 CMP #4                 \ of type 4), jump to pkey11 to implement this
 BEQ pkey11

 CMP #6                 \ If the player is trying to absorb the Sentinel's tower
 BEQ pkey7              \ (an object of type 6), jump to pkey7 to make an error
                        \ sound and return from the subroutine

.pkey6

 JSR DeleteObject       \ Delete object #X and remove it from the landscape

 STX currentObject      \ Set currentObject to the number of the deleted object

 CLC                    \ Call UpdatePlayerEnergy with the C flag clear to add
 JSR UpdatePlayerEnergy \ the amount of energy in the now-deleted object #X to
                        \ the player's energy

 CLC                    \ Clear the C flag to denote that an object has been
                        \ removed by the routine

 RTS                    \ Return from the subroutine

.pkey7

                        \ If we get here then the player has tried to:
                        \
                        \   * Absorb or transfer to an empty tile
                        \
                        \   * Create, absorb or transfer to a tile or platform
                        \     that they see directly
                        \
                        \   * Transfer to an object that is not a robot
                        \
                        \   * Absorb an object after the Sentinel has been
                        \     absorbed
                        \
                        \   * Absorb the Sentinel's tower
                        \
                        \   * Create an object when there are no unallocated
                        \     object numbers
                        \
                        \   * Create an object that takes their energy level
                        \     below zero
                        \
                        \   * Create an object that can't be added to the tile
                        \     (if the tile is occupied by an object that is not
                        \     a boulder or tower, for example)
                        \
                        \ In each case we make an error sound and return from
                        \ the subroutine

 LDA #170               \ Set the third parameter of sound data block #3 (the
 STA soundData+28       \ pitch) to 170

 LDA #5                 \ Make sound #5 (ping)
 JSR MakeSound

 LDA #144               \ Set the third parameter of sound data block #3 (the
 STA soundData+28       \ pitch) to 144

 SEC                    \ Set the C flag to denote that no object has been added
                        \ or removed by the routine

 RTS                    \ Return from the subroutine

.pkey8

                        \ If we get here then the player is trying to create an
                        \ object of the type given in keyPress

 JSR SpawnObject+3      \ Spawn an object of type keyPress, returning the object
                        \ number of the new object in X and currentObject

 BCS pkey7              \ If there are no free object numbers then the call to
                        \ SpawnObject will return with the C flag set and the
                        \ object will not have been created, so jump to pkey7 to
                        \ make an error sound and return from the subroutine

 SEC                    \ Call UpdatePlayerEnergy with the C flag set to
 JSR UpdatePlayerEnergy \ subtract the amount of energy in object #X from the
                        \ player's energy, so this subtracts the energy required
                        \ to create the object from the player

 BCS pkey7              \ If the creation of object #X reduces the player's
                        \ energy below zero, then the call to UpdatePlayerEnergy
                        \ will return with the C flag set, so jump to pkey7 to
                        \ make an error sound and return from the subroutine

 LDX currentObject      \ Set X to the object number of the object we just
                        \ created

 LDA xCoordHi           \ Set (xTile, zTile) to the tile coordinates of the tile
 STA xTile              \ in the sights, which we set in part 1 with the call to
 LDA zCoordHi           \ FollowGazeVector
 STA zTile

 JSR PlaceObjectOnTile  \ Place object #X on the tile anchored at (xTile, zTile)

 BCC pkey9              \ If the object was successfully placed on the tile then
                        \ the call to PlaceObjectOnTile will return with the C
                        \ flag clear, so jump to pkey9 to keep going

 CLC                    \ Otherwise we failed to add the object to the tile, so
 JSR UpdatePlayerEnergy \ call UpdatePlayerEnergy with the C flag clear to
                        \ refund the energy that we used to create the object
                        \ back to the player

 JMP pkey7              \ We failed to place the object on the tile, so jump to
                        \ pkey7 to make an error sound and return from the
                        \ subroutine

.pkey9

                        \ If we get here then a new object has been successfully
                        \ created and added to a tile, as object #X

 LDA objectTypes,X      \ If the type of object that was added is not a robot
 BNE pkey10             \ (type 0), jump to pkey10 to return from the subroutine
                        \ with the C flag clear

                        \ We just created a robot, so we now rotate it so that
                        \ it faces the player

 LDY playerObject       \ Set A to the yaw angle of the player object
 LDA objectYawAngle,Y

 EOR #%10000000         \ Flip bit 7 to rotate the angle through 180 degrees
                        \
                        \ The degree system in the Sentinel looks like this:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of object
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ Flipping bit 7 changes 0 into 128, +32 into -96, +64
                        \ into -64 and so on, so it's the same as rotating by
                        \ 180 degrees

 STA objectYawAngle,X   \ Set the yaw angle for the newly created robot to the
                        \ player's yaw angle rotated through 180 degrees, so the
                        \ new robot faces the player

.pkey10

 CLC                    \ Clear the C flag to denote that an object has been
                        \ added by the routine

 RTS                    \ Return from the subroutine

.pkey11

                        \ If we get here then the player is trying to absorb a
                        \ meanie in object #X

                        \ We now loop through all the enemy objects, of which
                        \ there are up to eight, looking for the object whose
                        \ enemyData5 entry is X (i.e. the object number of the
                        \ meanie) ???

 LDY #7                 \ The enemies have object numbers 0 (for the Sentinel)
                        \ or 1 to 7 (for any sentries in the landscape), so set
                        \ a counter in Y to work through the enemy object
                        \ numbers

.pkey12

 LDA objectFlags,Y      \ If bit 7 is set for object #Y then this object number
 BMI pkey14             \ is not allocated to an object, so jump to pkey14 to
                        \ move on to the next enemy object

 LDA objectTypes,Y      \ Set A to the object type for object #Y

 CMP #1                 \ If object #Y is a sentry (object type 1), jump to
 BEQ pkey13             \ pkey13

 CMP #5                 \ If object #Y is not the Sentinel, jump to pkey14 to
 BNE pkey14             \ move on to the next enemy object


.pkey13

                        \ If we get here then object #Y is the Sentinel or a
                        \ sentry

 TXA                    \ Set A to the object number of the meanie that the
                        \ player is trying to absorb

 CMP enemyData5,Y       \ If A <> enemyData5 for object #Y, jump to pkey14 to
 BNE pkey14             \ move on to the next enemy object ???

 LDA #%10000000         \ Set bit 7 of enemyData5 for object #Y (the sentry or
 STA enemyData5,Y       \ Sentinel) ???

 BNE pkey6              \ Jump to pkey6 to delete the meanie in object #X, add
                        \ the meanie's energy to the player's energy, and return
                        \ from the subroutine with the C flag clear (this BNE is
                        \ effectively a JMP as A is never zero)

.pkey14

 DEY                    \ Decrement the counter in Y to move on to the next
                        \ enemy object number

 BPL pkey12             \ Loop back until we have processed all eight possible
                        \ enemy objects

 BMI pkey6              \ Jump to pkey6 to delete the meanie in object #X, add
                        \ the meanie's energy to the player's energy, and return
                        \ from the subroutine with the C flag clear

\ ******************************************************************************
\
\       Name: GetSightsVector
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the angles of the vector from the player's eyes to the
\             sights
\
\ ------------------------------------------------------------------------------
\
\ The vector from the player's eyes to the sights is calculated as follows:
\
\   vectorYawAngle = (xSights * 32) + (objectYawAngle,X 0) - (10 0)
\
\   vectorPitchAngle = (ySights - 5) * 16 + (objectPitchAngle,X 0) + (3 32)
\
\ The (10 0) element in the yaw angle calculation represents half a screen
\ width, as the screen is 20 yaw angles wide, so subtracting (10 0) from the
\ object's yaw angle makes it to the left edge of the screen, and then we add
\ the x-coordinate of the sights on-screen to get the vector's yaw angle.
\
\ The -5 in the pitch angle calculation caters for the energy icon and scanner
\ row at the top of the screen, and the (3 32) element represents ???
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   This is always set to the object number of the player
\                       (it is set in ProcessActionKeys before it calls this
\                       routine)
\
\ ******************************************************************************

.GetSightsVector

 LDA xSights            \ Set (U A) = xSights * 256
 STA U
 LDA #0

 LSR U                  \ Set (U A) = (U A) / 8
 ROR A                  \           = xSights * 32
 LSR U
 ROR A
 LSR U
 ROR A
                        \ We now calculate the following:
                        \
                        \   (U A) + (objectYawAngle,X 0) - (10 0)
                        \
                        \ and store it in (vectorYawAngleHi vectorYawAngleLo)

 CLC                    \ Clear the C flag for the following

 STA vectorYawAngleLo   \ Store the low byte of the calculation (which we know
                        \ will be A) in vectorYawAngleLo

 LDA U                  \ Calculate the high byte of the calculation as
 ADC objectYawAngle,X   \ follows:
 SEC                    \
 SBC #10                \   U + objectYawAngle,X - 10
 STA vectorYawAngleHi   \
                        \ and store it in vectorYawAngleHi

                        \ So (vectorYawAngleHi vectorYawAngleLo) is now equal to
                        \ the following:
                        \
                        \   (xSights * 32) + (objectYawAngle,X 0) - (10 0)

 LDA ySights            \ Set (U A) = (ySights - 5) * 256
 SEC
 SBC #5
 STA U
 LDA #0

 LSR U                  \ Set (U A) = (U A) / 16
 ROR A                  \           = (ySights - 5) * 16
 LSR U
 ROR A
 LSR U
 ROR A
 LSR U
 ROR A

                        \ We now calculate the following:
                        \
                        \   (U A) + (objectPitchAngle,X 0) + (3 32)
                        \
                        \ and store it in both (A T) and in
                        \ (vectorPitchAngleHi vectorPitchAngleLo)

 CLC                    \ Calculate the low byte and store it in both T and
 ADC #32                \ vectorPitchAngleLo
 STA vectorPitchAngleLo
 STA T

 LDA U                  \ Calculate the high byte, keep it in A and store it in
 ADC objectPitchAngle,X \ vectorPitchAngleHi
 CLC
 ADC #3
 STA vectorPitchAngleHi

                        \ So by this point we have the following:
                        \
                        \   (vectorYawAngleHi vectorYawAngleLo)
                        \   = (xSights * 32) + (objectYawAngle,X 0) - (10 0)
                        \
                        \   (vectorPitchAngleHi vectorPitchAngleLo)
                        \   = (ySights-5) * 16 + (objectPitchAngle,X 0) + (3 32)
                        \
                        \ We now fall through into GetVectorForAngles to convert
                        \ these two angles into a cartesian vector:
                        \
                        \   [ (xVectorLo xVectorBot) ]
                        \   [ (yVectorLo yVectorBot) ]
                        \   [ (zVectorLo zVectorBot) ]

\ ******************************************************************************
\
\       Name: GetVectorForAngles
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Convert a vector from pitch and yaw angles into a 3D cartesian
\             vector
\
\ ------------------------------------------------------------------------------
\
\ This routine uses the rotation matrix routine from Revs to convert a vector
\ from a pair of pitch and yaw angles into a cartesian [x y z] vector.
\
\ The pitch and yaw angles are 16-bit numbers as follows:
\
\   (vectorPitchAngleHi vectorPitchAngleLo)
\
\   (vectorYawAngleHi vectorYawAngleLo)
\
\ The same vector, but expressed as a cartesian vector, is calculated as
\ follows:
\
\   [ (xVectorLo xVectorBot) ]
\   [ (yVectorLo yVectorBot) ]
\   [ (zVectorLo zVectorBot) ]
\
\ The calculation is this:
\
\   yVector = sinVectorPitchAngle / 16
\
\   zVector = cosVectorPitchAngle * cosVectorYawAngle / 16
\
\   xVector = cosVectorPitchAngle * sinVectorYawAngle / 16
\
\ ******************************************************************************

.GetVectorForAngles

                        \ In the following commentary I am talking about the
                        \ vector from the player's eyes to the sights, as that
                        \ makes it easier to describe the various points, but
                        \ this routine can convert any vector into angles using
                        \ the same process

                        \ We start by converting the pitch angle of the vector
                        \ from the player's eyes to the sights into a cartesian
                        \ y-coordinate in the global 3D coordinate system, where
                        \ the y-axis is the up-down axis
                        \
                        \ We store the resulting y-coordinate in the 16-bit
                        \ variable (yVectorLo yVectorBot)
                        \
                        \ We calculate yVector by considering a triangle with
                        \ the sights vector as the hypotenuse, and we drop the
                        \ end point down onto the y = 0 plane (i.e. onto the
                        \ ground)
                        \
                        \ Consider the case where the player is looking up at an
                        \ angle of vectorPitchAngle, so the vector from the
                        \ player's eye to the sights is from the bottom-left to
                        \ the top-right in the following triangle:
                        \
                        \                                   sights
                        \                               _.-+             ^
                        \                           _.-   |             |
                        \              vector   _.-       |         y-axis (up)
                        \                   _.-           |
                        \               _.-               |  y
                        \           _.-                   |
                        \        .- vectorPitchAngle      |
                        \   eye +--------------------------+
                        \                   p
                        \
                        \ To make the calculations easier, let's say the length
                        \ of the vector is 1
                        \
                        \ Trigonometry gives us the following:
                        \
                        \   sin(vectorPitchAngle) = opposite / hypotenuse
                        \                         = y / 1
                        \
                        \ So the y-coordinate is given by:
                        \
                        \   y = sin(vectorPitchAngle)
                        \
                        \ which is what we calculate now
                        \
                        \ Incidentally, the adjacent side p, which is the length
                        \ of the vector projected down onto the y = 0 plane, is
                        \ calculated in a similar way:
                        \
                        \   cos(vectorPitchAngle) = adjacent / hypotenuse
                        \                         = p / 1
                        \
                        \ So p = cos(vectorPitchAngle), which we will use to
                        \ calculate the x- and z-coordinates of the vector later

 JSR GetRotationMatrix  \ This routine is taken from Revs, where it calculates a
                        \ rotation matrix from an angle
                        \
                        \ We don't need a full rotation matrix here, but the
                        \ Revs routine calculates the values that we do need
                        \ here, specifically:
                        \
                        \   cosVectorPitchAngle = cos(vectorPitchAngle)
                        \
                        \   sinVectorPitchAngle = sin(vectorPitchAngle)
                        \
                        \ These calculations return 16-bit sign-magnitude
                        \ numbers with the sign in bit 0, which the DivideBy16
                        \ routine converts into normal 16-bit signed numbers
                        \
                        \ Note that because GetRotationMatrix is copied from
                        \ Revs, where we only ever rotate through the yaw angle,
                        \ the matrix values are actually returned in the various
                        \ yawAngle variables, but for simplicity let's pretend
                        \ they are returned as above

 LDY #1                 \ Set (A X) = cosVectorPitchAngle / 16
 JSR DivideBy16

 STA cosVectorPitchHi   \ Set (cosVectorPitchHi cosVectorPitchLo)
 STX cosVectorPitchLo   \                             = cosVectorPitchAngle / 16

 LDY #0                 \ Set (A X) = sinVectorPitchAngle / 16
 JSR DivideBy16

 STA yVectorLo          \ Set (yVectorLo yVectorBot) = sinVectorPitchAngle / 16
 STX yVectorBot         \                           
                        \ So we now have the y-coordinate of the sights vector
                        \ as follows:
                        \
                        \   y = sin(vectorPitchAngle)

                        \ Now we convert the yaw angle of the sights vector
                        \ into cartesian x- and z-coordinates, where the x-axis
                        \ is the left-right axis and the z-axis goes into the
                        \ screen
                        \
                        \ We store the resulting x-coordinate in the 16-bit
                        \ variable (xVectorLo yxVectorBot) and the z-coordinate
                        \ in (zVectorLo zxVectorBot)
                        \
                        \ We calculate xVector and zVector by considering a
                        \ triangle on the y = 0 plane, so that's a triangle on
                        \ the ground
                        \
                        \ The hypotenuse of this triangle is side p from the
                        \ first calculation, which is the sights vector
                        \ projected down onto the ground - the shadow from a
                        \ light source directly above, if you like
                        \
                        \ The opposite and adjacent sides of this tringle will
                        \ give us the x- and z-coordinates of the vector
                        \
                        \ To see this, consider the same vector as before, with
                        \ p as the vector projected down onto the ground, and
                        \ where the player is looking sideways at a yaw angle of
                        \ vectorYawAngle
                        \
                        \ This gives us a triangle like this, when viewed from
                        \ above, so it's as if we are the light source directly
                        \ above the sights vector, projecting the vector down
                        \ onto p, and with the vector going from the top-left to
                        \ the bottom-right, and the sights end of the vector
                        \ higher than the eye end:
                        \
                        \                   z
                        \   eye +--------------------------+       z-axis -->
                        \        `-._ vectorYawAngle       |       into screen
                        \            `-._                  |
                        \                `-._              | x
                        \                 p  `-._          |
                        \                        `-._      |        x-axis left
                        \                            `-._  |          to right
                        \                                `-+             |
                        \                                    sights      v
                        \
                        \ Again, simple trigonometry gives us the following:
                        \
                        \   sin(vectorYawAngle) = opposite / hypotenuse
                        \                       = x / p
                        \
                        \ So:
                        \
                        \   x = p * sin(vectorYawAngle)
                        \
                        \ And:
                        \
                        \   cos(vectorYawAngle) = adjacent / hypotenuse
                        \                       = z / p
                        \
                        \ So:
                        \
                        \   z = p * cos(vectorYawAngle)
                        \
                        \ We calculated above that:
                        \
                        \   p = cos(vectorPitchAngle)
                        \
                        \ So substituting that into our result gives us:
                        \
                        \   x = p * sin(vectorYawAngle)
                        \     = cos(vectorPitchAngle) * sin(vectorYawAngle)
                        \
                        \   z = p * cos(vectorYawAngle)
                        \     = cos(vectorPitchAngle) * cos(vectorYawAngle)
                        \
                        \ which is what we calculate now

 LDA vectorYawAngleLo   \ Set (A T) = (vectorYawAngleHi vectorYawAngleLo)
 STA T
 LDA vectorYawAngleHi

 JSR GetRotationMatrix  \ Calculate the following:
                        \
                        \   cosVectorYawAngle = cos(vectorYawAngle)
                        \
                        \   sinVectorYawAngle = sin(vectorYawAngle)
                        \
                        \ Again these are returned as 16-bit sign-magnitude
                        \ numbers with the sign in bit 0, which the
                        \ MultiplyCoords converts into normal 16-bit signed
                        \ numbers

 LDY #1                 \ Call MultiplyCoords with Y = 1 and X = 2 to calculate
 LDX #2                 \ the following:
 JSR MultiplyCoords     \
                        \   (zVectorLo zVectorBot)
                        \       = cosVectorPitchAngle * cosVectorYawAngle / 16

 LDY #0                 \ Zero X and Y and fall through into MultiplyCoords to
 LDX #0                 \ calculate the following:
                        \
                        \   (xVectorLo xVectorBot)
                        \        = cosVectorPitchAngle * sinVectorYawAngle / 16
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: MultiplyCoords
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Multiply a 16-bit signed number and a 16-bit sign-magnitude value
\
\ ------------------------------------------------------------------------------
\
\ This routine multiplies two 16-bit values and stores the result according to
\ the arguments, as follows.
\
\ When Y = 0, it calculates:
\
\   (cosVectorPitchHi cosVectorPitchLo) * (sinAngleHi sinAngleLo)
\
\ i.e. cosVectorPitch * sinAngle
\
\ When Y = 1, it calculates:
\
\   (cosVectorPitchHi cosVectorPitchLo) * (cosAngleHi cosAngleLo)
\
\ i.e. cosVectorPitch * cosAngle
\
\ When X = 0, store the result in (xVectorLo xVectorBot).
\
\ When X = 2, store the result in (zVectorLo zVectorBot).
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   cosVectorPitchHi    The 16-bit signed number to multiply (high byte)
\
\   cosVectorPitchLo    The 16-bit signed number to multiply (low byte)
\
\   Y                   Offset of the 16-bit sign-magnitude value to multiply:
\
\                         * 0 = sinAngle
\
\                         * 1 = cosAngle
\
\   X                   Offset of the variable to store the result in:
\
\                         * 0 = (xVectorLo xVectorBot)
\
\                         * 2 = (zVectorLo zVectorBot)
\
\ ******************************************************************************

.MultiplyCoords

 LDA #0                 \ Set H to sign to apply to the result of Multiply16x16
 STA H                  \ (in bit 7), so setting H  0 ensures that that the
                        \ result is positive

 LDA cosVectorPitchLo   \ Set (QQ PP) = (cosVectorPitchHi cosVectorPitchLo)
 STA PP                 \
 LDA cosVectorPitchHi   \ where (QQ PP) is a 16-bit signed number
 STA QQ

 LDA sinAngleLo,Y       \ Set (SS RR) to the 16-bit sign-magnitude number
 STA RR                 \ pointed to by Y
 LDA sinAngleHi,Y
 STA SS

 JSR Multiply16x16      \ Set (A T) = (QQ PP) * (SS RR)
                        \
                        \ And apply the sign from bit 7 of H to ensure the
                        \ result is positive

 STA xVectorLo,X        \ Store the result in:
 LDA T                  \
 STA xVectorBot,X       \   * (xVectorLo xVectorBot) when X = 0
                        \
                        \   * (zVectorLo zVectorBot) when X = 2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DivideBy16
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Divide a 16-bit sign-magnitude number by 16
\
\ ------------------------------------------------------------------------------
\
\ This routine divides a 16-bit sign-magnitude number by 16 and returns the
\ result as a signed 16-bit number.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   Offset of the 16-bit sign-magnitude number to divide:
\
\                         * 0 = sinAngle
\
\                         * 1 = cosAngle
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   (A X)               The 16-bit signed number containing the result

\ ******************************************************************************

.DivideBy16

 LDA sinAngleLo,Y       \ Set (A T) to the 16-bit sign-magnitude number pointed
 STA T                  \ to by Y
 LDA sinAngleHi,Y

 LSR A                  \ Set (A T) = (A T) / 16
 ROR T                  \
 PHP                    \ We store bit 0 of the original 16-bit sign-magnitude
 LSR A                  \ number on the stack in the C flag (as it gets rotated
 ROR T                  \ out from bit 0 on the first ROR T)
 LSR A
 ROR T
 LSR A
 ROR T

 PLP                    \ We stored the sign bit from the original 16-bit
                        \ sign-magnitude number on the stack, so fetch it into
                        \ the C flag

 BCC divi1              \ If the sign bit was 0 then the original number was
                        \ positivem so skip the following

 JSR Negate16Bit        \ The original 16-bit sign-magnitude number was negative
                        \ so call Negate16Bit to negate the result as follows:
                        \
                        \   (A T) = -(A T)

.divi1

 LDX T                  \ Set (A X) = (A T)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: AddVectorToCoord
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Add a vector to a coordinate
\
\ ------------------------------------------------------------------------------
\
\ This routine adds a vector to a coordinate:
\
\   [ xCoord ]   [ xCoord ]   [ xVector ]
\   [ yCoord ] = [ yCoord ] + [ yVector ]
\   [ zCoord ]   [ zCoord ]   [ zVector ]
\
\ where the coordinate consists of 24-bit signed numbers:
\
\   [ xCoord ]   [ (xCoordHi xCoordLo xCoordBot) ]
\   [ yCoord ] = [ (yCoordHi yCoordLo yCoordBot) ]
\   [ zCoord ]   [ (zCoordHi zCoordLo zCoordBot) ]
\
\ and the vector consists of 16-bit signed numbers:
\
\   [ xVector ]   [ (xVectorLo xVectorBot) ]
\   [ yVector ] = [ (yVectorLo yVectorBot) ]
\   [ zVector ]   [ (zVectorLo zVectorBot) ]
\
\ ******************************************************************************

.AddVectorToCoord

 LDX #2                 \ We now work through all three axes in turn, so set an
                        \ axis counter in X to iterate through 2, 1 and 0 (for
                        \ the z-axis, y-axis and x-axis respectively)
                        \
                        \ The comments in the following loop will concentrate on
                        \ the x-axis to keep things simple

.addv1

                        \ We now perform the following addition of a 24-bit
                        \ coordinate and a 16-bit vector:
                        \
                        \   xCoord = xCoord + xVector
                        \
                        \ where:
                        \
                        \   * xCoord is (xCoordHi xCoordLo xCoordBot)
                        \
                        \   * xVector is (xVectorLo xVectorBot)
                        \
                        \ We do this for each axis in turn, but let's talk about
                        \ the x-axis

 LDA #0                 \ Set T = 0
 STA T                  \
                        \ We use T as the high byte of xVector, which we either
                        \ set to 0 (if xVector is positive) or &FF (if xVector
                        \ is negative)
                        \
                        \ We set T for positive numbers here, and change it to
                        \ &FF during the addition if xVector turns out to be
                        \ negative
                        \
                        \ The addition therefore supports signed numbers

 LDA xCoordBot,X        \ Add the bottom bytes of the calculation
 CLC
 ADC xVectorBot,X
 STA xCoordBot,X

 LDA xVectorLo,X        \ Set A to xVectorLo so we can check its sign

 BPL addv2              \ If xVectorLo is negative, set T = &FF so we can use it
 DEC T                  \ as the high byte in the negative 24-bit number, like
                        \ this:
                        \
                        \   (&FF xVectorLo xVectorBot)

.addv2

 ADC xCoordLo,X         \ Now add the low bytes of the calculation
 STA xCoordLo,X

 LDA xCoordHi,X         \ And then add the high bytes, incorporating the high
 ADC T                  \ byte of xVector that we set in T
 STA xCoordHi,X

 DEX                    \ Decrement the axis counter in X to move on to the next
                        \ axis

 BPL addv1              \ Loop back until we have processed all three axes

 RTS                    \ Return from the subroutine

 EQUB &00               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: FollowGazeVector (Part 1 of 5)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Follow a gaze vector from a viewing object to determine whether
\             the viewer can see a flat tile or platform (i.e. boulder or tower)
\
\ ------------------------------------------------------------------------------
\
\ This routine follows the gaze of a viewing object to see if it hits a tile or
\ a platform (where a platform is a boulder or the Sentinel's tower)
\
\ The gaze is defined by the following vector:
\
\   [ xVector ]   [ (xVectorLo xVectorBot) ]
\   [ yVector ] = [ (yVectorLo yVectorBot) ]
\   [ zVector ]   [ (zVectorLo zVectorBot) ]
\
\ This contains the gaze vector, scaled down to be very small, so we can trace
\ the line of the gaze by repeatedly adding this vector to the coordinates of
\ the viewing object to step along the line of the gaze. At each step we check
\ to see whether the gaze has hit a tile, repeatiung this until we either hit a
\ tile or fall off the edge of the landscape.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   viewingObject       The number of the object that is performing the gaze
\
\   xVectorLo           The x-coordinate of the scaled-down gaze vector (low
\                       byte)
\
\   xVectorBot          The x-coordinate of the scaled-down gaze vector (bottom
\                       byte)
\
\   yVectorLo           The y-coordinate of the scaled-down gaze vector (low
\                       byte)
\
\   yVectorBot          The y-coordinate of the scaled-down gaze vector (bottom
\                       byte)
\
\   zVectorLo           The z-coordinate of the scaled-down gaze vector (low
\                       byte)
\
\   zVectorBot          The z-coordinate of the scaled-down gaze vector (bottom
\                       byte)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   C flag              Status flag:
\
\                         * Clear if the viewing object can see a tile along
\                           the gaze vector
\
\                         * Set if the viewing object can't see a tile along
\                           the gaze vector
\
\   targetOnTile        Records whether the gaze vector can see a tile
\                       containing the target object whose number is in
\                       targetObject:
\
\                         * Bit 7 clear = gaze vector cannot see the target
\                                         object
\
\                         * Bit 7 set = gaze vector can see the target object
\
\   gazeCanSeeTree      Records whether the gaze vector can see a tree:
\
\                         * Bit 7 clear = gaze vector cannot see a tree
\
\                         * Bit 7 set = gaze vector can see a tree
\
\   xCoordHi            The tile x-coordinate of the tile that can be seen
\
\   zCoordHi            The tile z-coordinate of the tile that can be seen
\
\ ******************************************************************************

.FollowGazeVector

 LDX viewingObject      \ Set X to the number of the object that is performing
                        \ the gaze (i.e. doing the looking or scanning)

 LSR targetOnTile       \ Clear bit 7 of targetOnTile so it can be set if the
                        \ tile contains the target object whose number is in
                        \ targetObject

 LSR gazeCanSeeTree     \ Clear bit 7 of gazeCanSeeTree so it can be set if
                        \ there is tree on the tile that can be seen by the
                        \ gaze vector

 JSR GetObjectCoords    \ Fetch the cartesian coordinates of the viewing object
                        \ as three 24-bit numbers, as follows:
                        \
                        \   (xCoordHi xCoordLo xCoordBot)
                        \
                        \   (yCoordHi yCoordLo yCoordBot)
                        \
                        \   (zCoordHi zCoordLo zCoordBot)
                        \
                        \ We now repeatedly add the scaled-down gaze vector to
                        \ this coordinate to step along the gaze from the
                        \ viewing object and see if it hits anything

.gaze1

 JSR AddVectorToCoord   \ Add the coordinates and the vector as follows:
                        \
                        \   [ xCoord ]   [ xCoord ]   [ xVector ]
                        \   [ yCoord ] = [ yCoord ] + [ yVector ]
                        \   [ zCoord ]   [ zCoord ]   [ zVector ]
                        \
                        \ where:
                        \
                        \   [ xCoord ]   [ (xCoordHi xCoordLo xCoordBot) ]
                        \   [ yCoord ] = [ (yCoordHi yCoordLo yCoordBot) ]
                        \   [ zCoord ]   [ (zCoordHi zCoordLo zCoordBot) ]
                        \
                        \ and:
                        \
                        \   [ xVector ]   [ (xVectorLo xVectorBot) ]
                        \   [ yVector ] = [ (yVectorLo yVectorBot) ]
                        \   [ zVector ]   [ (zVectorLo zVectorBot) ]
                        \
                        \ This adds the scaled-down gaze vector to the
                        \ coordinate to perform a step along the object's gaze

 LDA xCoordHi           \ Set xTile to the high byte of the result (i.e. the
 STA xTile              \ tile x-coordinate below our current position along the
                        \ viewer's gaze)

 CMP #31                \ If we just stepped beyond the right edge of the
 BCS gaze4              \ landscape then the gaze does not land upon a tile, so
                        \ jump to gaze4 to return from the subroutine with the
                        \ C flag set to indicate that the viewer is not looking
                        \ at a tile

 LDA zCoordHi           \ Set zTile to the high byte of the result (i.e. the
 STA zTile              \ tile z-coordinate below our current position along the
                        \ viewer's gaze)

 CMP #31                \ If we just stepped beyond the rear edge of the
 BCS gaze4              \ landscape then the gaze does not land upon a tile, so
                        \ jump to gaze4 to return from the subroutine with the
                        \ C flag set to indicate that the viewer is not looking
                        \ at a tile

 LDA #%10000000         \ Set bit 7 and clear bit 6 of considerObjects so the
 STA considerObjects    \ following call GetTileAltitude will include objects in
                        \ its calculations ???

 STA L000C              \ Set bit 7 of L000C ???

 LDA #0                 \ Set platformAltitudeLo = 0, so if the tile doesn't
 STA platformAltitudeLo \ contain a platform, platformAltitudeLo will be zero

 STA boulderOnTile      \ Clear bit 7 of boulderOnTile to denote that the tile
                        \ does not contain a boulder, so GetTileAltitude can
                        \ set bit 7 if it does contain a boulder

 JSR GetTileAltitude    \ Call GetTileAltitude with bit 7 of considerObjects
                        \ set to extract the following tile data:
                        \
                        \   * (A platformAltitudeLo) = if the tile contains a
                        \     boulder or the Sentinel's tower, then this is set
                        \     to the altitude of the platform object, +32 for
                        \     the tower or +96 for the boulder
                        \
                        \   * A = if the tile contains a non-platform object
                        \         then this is set to the high byte of the
                        \         tile's altitude, which is the same as the high
                        \         byte of the object's altitude
                        \
                        \   * A = if the tile is not flat then this is set to
                        \         the tile altitude from the tile data
                        \
                        \   * C flag = the tile's shape, clear if the tile is
                        \              flat or set if the tile is not flat
                        \
                        \   * boulderOnTile has bit 7 set if the tile contains a
                        \     boulder

 BCS gaze5              \ If the tile is not flat, jump to gaze5 to calculate
                        \ the gaze vector's interaction with the tile slopes

                        \ If we get here then the tile is flat and may contain
                        \ an object

 TAX                    \ Set (X A) to the altitude of the platform (if there is
 LDA platformAltitudeLo \ one) or the altitude of the tile (is there isn't)

 SEC                    \ Set the following:
 SBC yCoordLo           \
 STA platformAltitudeLo \   (A platformAltitudeLo) = (X A) - (yCoordHi yCoordLo)
 TXA                    \
 SBC yCoordHi           \ So this contains the relative altitude of the tile or
                        \ platform compared to our current position along the
                        \ viewer's gaze (as we are subtracting the altitude of
                        \ the gaze from the altitude of the tile/platform)

 BMI gaze1              \ If the high byte of the result is negative then the
                        \ gaze is passing through the y-coordinate above the
                        \ tile or platform, in terms of whole numbers (so it is
                        \ essentially more than one "tile cube" above the tile)
                        \
                        \ This means it hasn't hit the tile and is still passing
                        \ through empty space above the landscape, so loop back
                        \ to gaze1 to move along the gaze vector and restart the
                        \ checks

 BNE gaze4              \ If the high byte of the result is non-zero and
                        \ positive, then the the gaze is passing through the
                        \ y-coordinate below the tile or platform, in terms of
                        \ whole numbers (so it is essentially in the "tile cube"
                        \ beneath the tile)
                        \
                        \ This means the gaze must have passed through a slope
                        \ and "into" the ground beneath the tile, so jump to
                        \ gaze4 to return from the subroutine with the C flag
                        \ set to indicate that the viewer is not looking at a
                        \ tile

                        \ If we get here then the gaze is currently sitting
                        \ within the "tile cube" above the tile

 LDA platformAltitudeLo \ If platformAltitudeLo >= L000C, then the platform is
 CMP L000C              \ too high, so jump to gaze4 to return from the
 BCS gaze4              \ subroutine with the C flag set to indicate that the
                        \ viewer is not looking at a tile ???

 BIT considerObjects    \ If bit 6 of considerObjects is set then jump to gaze4
 BVS gaze4              \ to return from the subroutine with the C flag set to
                        \ indicate that the viewer is not looking at a tile ???

 LDA L0C6E              \ If bit 7 is set in either of L0C6E and boulderOnTile,
 ORA boulderOnTile      \ skip the following test, as the tile contains either a
 BMI gaze2              \ ??? or a boulder

                        \ If we get here then bit 7 is clear in both L0C6E and
                        \ boulderOnTile, so the tile does not contain a ??? or a
                        \ boulder

 LDA yVectorLo          \ If the low byte (i.e. the fractional part) of the gaze
 BPL gaze4              \ vector's y-coordinate is positive, then the viewer is
                        \ looking upwards and ???, so jump to gaze4 to return
                        \ from the subroutine with the C flag set to indicate
                        \ that the viewer is not looking at a tile

.gaze2

                        \ If we get here then the viewer's gaze has landed on a
                        \ tile, so the final check is to make sure the viewer is
                        \ not looking at their own tile

 LDX viewingObject      \ Set X to the number of the object that is performing
                        \ the gaze (i.e. doing the looking or scanning)

 LDA xTile              \ If the x-coordinate of the viewing object is not the
 CMP xObject,X          \ same as the x-coordinate of the tile that the gaze has
 BNE gaze3              \ hit, jump to gaze3 to return from the subroutine with
                        \ the C flag clear, to indicate that the viewer is
                        \ looking at a tile

                        \ If we get here then the x-coordinates match, so we now
                        \ need to check the z-coordinates

 LDA zTile              \ If the z-coordinate of the viewing object is the same
 CMP zObject,X          \ as the x-coordinate, then the viewer is looking at
 BEQ gaze1              \ their own tile, so loop back to gaze1 to move along
                        \ the gaze vector and restart the checks

                        \ If we get here then the z-coordinates do not match, so
                        \ we can now return from the subroutine with the C flag
                        \ clear, to indicate that the viewer is looking at a
                        \ tile

.gaze3

 CLC                    \ Set the C flag to indicate that the gaze hit
                        \ something, so the viewing object is looking at
                        \ something

 RTS                    \ Return from the subroutine

.gaze4

 SEC                    \ Set the C flag to indicate that the gaze didn't hit
                        \ anything, so the viewing object isn't looking at
                        \ anything

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FollowGazeVector (Part 2 of 5)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the altitudes of the four corners in a non-flat tile
\
\ ******************************************************************************

.gaze5

                        \ If we get here then the tile is not flat and A is set
                        \ to the tile altitude from the tile data

 STA S                  \ Set S to the tile altitude

 STA W                  \ Set W to the tile altitude
                        \
                        \ This ensures that when we access the altitudes of the
                        \ four tile corners in part 5 using variables S, T, U
                        \ and V, the list wraps around in memory into variable W
                        \ to support corner pairs for all four edges - see part
                        \ 5 for details

 LSR considerObjects    \ Clear bit 7 of considerObjects so GetTileAltitude will
                        \ only extract the altitude and flatness of the tiles
                        \ when we call it below, ignoring any objects on the
                        \ landscape

 INC xTile              \ Move along the x-axis to fetch the next tile to the
                        \ right

 JSR GetTileAltitude    \ Call GetTileAltitude with bit 7 of considerObjects
                        \ clear to extract the following tile data:
                        \
                        \   * A = the high byte of the tile's altitude (which
                        \         is also the altitude of the tile corner)
                        \
                        \   * C flag = the tile's shape, clear if the tile is
                        \              flat or set if the tile is not flat

 STA V                  \ Set V to the altitude of the tile to the right

 INC zTile              \ Move along the x-axis to fetch the next tile into the
                        \ screen

 JSR GetTileAltitude    \ Call GetTileAltitude with bit 7 of considerObjects
                        \ clear to extract the following tile data:
                        \
                        \   * A = the high byte of the tile's altitude (which
                        \         is also the altitude of the tile corner)
                        \
                        \   * C flag = the tile's shape, clear if the tile is
                        \              flat or set if the tile is not flat

 STA U                  \ Set U to the altitude of the tile behind

 DEC xTile              \ Move back along the x-axis to fetch the next tile to
                        \ the left

 JSR GetTileAltitude    \ Call GetTileAltitude with bit 7 of considerObjects
                        \ clear to extract the following tile data:
                        \
                        \   * A = the high byte of the tile's altitude (which
                        \         is also the altitude of the tile corner)
                        \
                        \   * C flag = the tile's shape, clear if the tile is
                        \              flat or set if the tile is not flat

 STA T                  \ Set V to the altitude of the tile to the left

 DEC zTile              \ Move out of the screen, back along the z-axis to take
                        \ us back to the tile we are processing

                        \ So at this point we have the altitudes of four tile
                        \ corners, as follows, with the view from above:
                        \
                        \      ^           [T]  [U]
                        \      |
                        \      |           [S]  [V]
                        \   z-axis
                        \    into
                        \   screen      x-axis from left to right --->
                        \
                        \ S is the altitude of the tile corner that anchors the
                        \ tile below the current position along the viewer's
                        \ gaze, and T, U and V are the altitudes of the tile's
                        \ other three corners, so now we can analyse how the
                        \ gaze interacts with the shape of the tile

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 AND #%00001111         \ The tile shape is in the low nibble of the tile data,
                        \ so extract the tile shape into A

 CMP #4                 \ If the tile shape is 4 then jump to gaze6
 BEQ gaze6

 CMP #12                \ If the tile shape is 12 then keep going, otherwise
 BNE gaze8              \ jump to gaze8

.gaze6

                        \ The tile shape is 4 or 12, so fall through into part 3
                        \ to process this shape

\ ******************************************************************************
\
\       Name: FollowGazeVector (Part 3 of 5)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate whether the viewing object's gaze is obstructed by a
\             tile of shape 4 or 12 (i.e. a tile with one horizontal edge)
\
\ ******************************************************************************

                        \ If we get here then the tile shape is 4 or 12, so the
                        \ tile has one horizontal edge with the other two points
                        \ being arbitrary (but not at the same height as the
                        \ horizontal edge)

 LDA yCoordHi           \ If yCoordHi is higher than any of the four tile
 CMP S                  \ corners, then the current position along the viewer's
 BCS gaze7              \ gaze is above the tile surface, so jump to gaze1 via
 CMP T                  \ gaze7 to move along the gaze vector and restart the
 BCS gaze7              \ checks
 CMP U
 BCS gaze7
 CMP V
 BCS gaze7

 JMP gaze4              \ Otherwise the current position along the viewer's
                        \ gaze is below the height of at least one tile corner,
                        \ so we consider this to be enough interference to be
                        \ blocking the viewer's gaze of any tiles that might be
                        \ partially visible beyond (which might be possible if
                        \ the slope is from left to right, for example)
                        \
                        \ So jump to gaze4 to return from the subroutine with
                        \ the C flag set to indicate that the viewer is not
                        \ looking at a tile

.gaze7

 JMP gaze1              \ Jump to gaze1 to move along the gaze vector and
                        \ restart the checks (this jump point is for use by
                        \ branching instructions)

\ ******************************************************************************
\
\       Name: FollowGazeVector (Part 4 of 5)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: For non-flat tiles with two horizontal edges, work out which tile
\             edge to use when checking for obstruction of the gaze vector
\
\ ******************************************************************************

.gaze8

                        \ If we get here then the tile shape in A is not 4 or 12
                        \
                        \ It also isn't 0, as the tile is not flat, and it isn't
                        \ 8 either, as that shape number isn't used
                        \
                        \ The tile shape is therefore one of the following:
                        \
                        \   1, 2, 3, 5, 6, 7, 9, 10, 11, 13, 14, 15
                        \
                        \ All of these shapes have two horizontal edges and two
                        \ sloping edges, so we now work out which of the sloping
                        \ edges we should use to check against the gaze vector
                        \ to see if the slope is obstructing the gaze
                        \
                        \ We pass this information to part 5 as a single tile
                        \ corner number in A, which tells part 5 to use the edge
                        \ from corner A to corner A + 1 in the calculation
                        \
                        \ To recap, we set the tile altitudes in part 2 like
                        \ this:
                        \
                        \      ^           [T]  [U]
                        \      |
                        \      |           [S]  [V]
                        \   z-axis
                        \    into
                        \   screen      x-axis from left to right --->
                        \
                        \ We can also number these corners so we can pass a
                        \ corner number to part 5, so let's number them like
                        \ this:
                        \
                        \      [T]  [U]          [1]  [2]
                        \                   =
                        \      [S]  [V]          [0]  [3]
                        \
                        \ As mentioned above, when we pass a corner number in A
                        \ to part 5, this tells part 5 to use the edge from
                        \ corner A to corner A + 1 in the calculation, so if we
                        \ pass A = 0 to part 5, that will tell it to use the
                        \ left edge (from 0 to 1) in the calculation, while
                        \ passing A = 2 will make it use the right edge (from 2
                        \ to 3)
                        \
                        \ This part is therefore all about setting A to the
                        \ correct corner number for the edge that we want to use
                        \ in the gaze vector calculation
                        \
                        \ We start by working out which two edges in the tile
                        \ shape are the sloping edges

 LSR A                  \ If bit 0 of the shape number is clear, jump to gaze10
 BCC gaze10

                        \ If we get here then the tile shape is one of the
                        \ following (i.e. %xxxxxxx1 in binary):
                        \
                        \   1, 3, 5, 7, 9, 11, 13, 15
                        \
                        \ and A contains the shape >> 1

 LSR A                  \ If bit 1 of the shape number is set, jump to gaze9
 BCS gaze9

                        \ If we get here then the tile shape is one of the
                        \ following (i.e. %xxxxxx01 in binary):
                        \
                        \   1, 5, 9, 13
                        \
                        \ and A contains the shape >> 2 to give:
                        \
                        \   0, 1, 2, 3

 AND #1                 \ Set A to bit 0 of A, which is bit 2 of the original
                        \ shape number, so:
                        \
                        \   * A = 0 if the tile shape is 1 or 9
                        \           (i.e. %xxxxx001 in binary)
                        \
                        \   * A = 1 if the tile shape is 5 or 13
                        \           (i.e. %xxxxx101 in binary)

                        \ At this point we have a suitable value of A to pass
                        \ to part 5, as we have:
                        \
                        \   * A = 0 to denote the left edge for shapes 1 and 9
                        \
                        \                          0 0   or   1 1
                        \                          1 1        0 0
                        \
                        \   * A = 1 to denote the top edge for shapes 5 and 13
                        \
                        \                          1 0   or   0 1
                        \                          1 0        0 1
                        \
                        \ As the sloping edges in these shapes have the exact
                        \ same slope gradient, either of them can be used in the
                        \ calculation

 JMP gaze13             \ Jump to gaze13 in part 5 to check the gaze vector
                        \ against the edge specified in A

.gaze9

                        \ If we get here then the tile shape is one of the
                        \ following (i.e. %xxxxxx11 in binary):
                        \
                        \   3, 7, 11, 15
                        \
                        \ and A contains the shape >> 2 to give:
                        \
                        \   0, 1, 2, 3
                        \
                        \ and the C flag is set

 ADC #1                 \ Set A = (A + 2) mod 4, to give:
 AND #3                 \
                        \   2, 3, 0, 1
                        \
                        \ The addition adds 2 because the C flag is set

 JMP gaze11             \ Jump to gaze11 to analyse this shape

.gaze10

                        \ If we get here then the tile shape is one of the
                        \ following (i.e. %xxxxxxx0 in binary):
                        \
                        \   2, 6, 10, 14
                        \
                        \ and A contains the shape >> 1

 LSR A                  \ Shift A right by one place, so the tile shape is one
                        \ of the following:
                        \
                        \   2, 6, 10, 14
                        \
                        \ and A contains the shape >> 2 to give:
                        \
                        \   0, 1, 2, 3

.gaze11

                        \ If we get here then the tile shape is one of:
                        \
                        \   2, 3, 6, 7, 10, 11, 14, 15
                        \
                        \ and A contains a number that tells us which two edges
                        \ are the sloping edges:
                        \
                        \   * If A = 0, the bottom and left edges slope
                        \
                        \   * If A = 1, the top and left edges slope
                        \
                        \   * If A = 2, the top and right edges slope
                        \
                        \   * If A = 3, the bottom and right edges slope
                        \
                        \ We either jump here with:
                        \
                        \   * A = 0 if the tile shape is 11     0 0     Bottom
                        \                                       1 0     Left
                        \
                        \   * A = 1 if the tile shape is 15     0 1     Top
                        \                                       1 1     Left
                        \
                        \   * A = 2 if the tile shape is 3      1 0     Top
                        \                                       1 1     Right
                        \
                        \   * A = 3 if the tile shape is 7      1 1     Bottom
                        \                                       1 0     Right
                        \
                        \ or we fall through from above with:
                        \
                        \   * A = 0 if the tile shape is 2      1 1     Bottom
                        \                                       0 1     Left
                        \
                        \   * A = 1 if the tile shape is 6      1 0     Top
                        \                                       0 0     Left
                        \
                        \   * A = 2 if the tile shape is 10     0 1     Top
                        \                                       0 0     Right
                        \
                        \   * A = 3 if the tile shape is 14     0 0     Bottom
                        \                                       0 1     Right

                        \ The next step is to choose which of these sloping
                        \ edges is the closest to the current position along
                        \ the gaze vector
                        \
                        \ The tileEdges table helps us do this
                        \
                        \ It is made up of two numbers for each pair of edges
                        \ represented by A; these are the corner numbers at the
                        \ start of each of the two edges in the pair, so for
                        \ each value of A, we need to choose one of the corner
                        \ numbers from the pair to pass to part 5
                        \
                        \ We choose the correct value according to whether the
                        \ gaze vector is closer to the edge along the x-axis
                        \ or the z-axis
                        \
                        \ For example, consider tile shape 11, for which we will
                        \ will have A = 0 to denote that the bottom and left
                        \ edges are the sloping edges in this shape:
                        \
                        \   0 0
                        \   1 0
                        \
                        \ The tileEdges table contains 0 and 3 for this shape
                        \ (to denote the left and bottom edges respectively)
                        \
                        \ Zooming in on the tile, we have the following, where
                        \ [x] is the current position along the gaze vector when
                        \ looking at the tile from above:
                        \
                        \   [1]                 [2]
                        \    | xCoordLo
                        \    |<--------> [x]
                        \    |            ^
                        \    |            |
                        \    |            |  zCoordLo
                        \    |            v
                        \   [0] --------------- [3]
                        \
                        \ The calculation below clears the C flag so we compare
                        \ xCoordLo and zCoordLo, so the calcuation is:
                        \
                        \   * If xCoordLo < zCoordLo, we pick the first entry
                        \     from tileEdges, i.e. 0, which is the left edge
                        \     (because the gaze point in [x] is closer to the
                        \     left edge than the bottom edge)
                        \
                        \   * If xCoordLo >= zCoordLo, we pick the second entry
                        \     from tileEdges, i.e. 3, which is the bottom edge
                        \     (because the gaze point in [x] is closer to the
                        \     bottom edge than the left edge)
                        \
                        \ The comparison is flipped around for tiles where the
                        \ slopes are along the top/left or bottom/right edges,
                        \ so we compare ~xCoordLo instead, like this example
                        \ when the slopes are along the bottom and right edges:
                        \
                        \   [1]                 [2]
                        \              ~xCoordLo |
                        \         [x] <--------> |
                        \                  ^     |
                        \                  |     |
                        \        zCoordLo  |     |
                        \                  v     |
                        \   [0] --------------- [3]

 STA G                  \ Store the value of A in G so we can retrieve it below

 LSR A                  \ Set the C flag to bit 0 of A, so it is:
                        \
                        \   * 0 if G = 0 or 2 (bottom/left or top/right)
                        \
                        \   * 1 if G = 1 or 3 (top/left or bottom/right)
                        \
                        \ So we compare against ~xCoordLo in the following for
                        \ the top/left or bottom/right edge pairs

 LDA xCoordLo           \ Set A to xCoordLo when C = 0 or ~xCoordLo when C = 1
 BCC gaze12             \
 EOR #%11111111         \ This ensures that the correct x-axis distance is used
                        \ in the comparison

.gaze12

 CMP zCoordLo           \ Set the C flag as follows:
                        \
                        \   * 0 if xCoordLo < zCoordLo (i.e. gaze vector is
                        \          closer to the left or right edge)
                        \
                        \   * 1 if xCoordLo >= zCoordLo i.e. gaze vector is
                        \          closer to the top or bottom edge)
                        \
                        \ So we choose the first entry from tileEdges when the
                        \ gaze vector iscloser to the left or right edge, or the
                        \ second entry when the gaze vector is closer to the top
                        \ or bottom edge

 LDA G                  \ Set Y = (G * 2) + C
 ROL A                  \
 TAY                    \ So Y can be used as an index into the tileEdges table
                        \ that points to the entry in pair number G as specified
                        \ by the C flag

 LDA tileEdges,Y        \ Set A to the edge number that we should test against
                        \ the gaze vector

                        \ Fall into part 5 to check whether the gaze vector is
                        \ obscured by the the edge we just chose

\ ******************************************************************************
\
\       Name: FollowGazeVector (Part 5 of 5)
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: For non-flat tiles with two horizontal edges, work out whether the
\             tile edge obstructs the gaze vector
\
\ ******************************************************************************

.gaze13

                        \ We jump here with A set to the number of the tile edge
                        \ that we can test against the gaze vector (where the
                        \ edge goes from corner A to corner A + 1)

 TAX                    \ Copy A into X so we can use it as an index into the
                        \ corner height variables we set up above

                        \ By this point the value of X (and, currently, of A)
                        \ is in the range 0 to 3, and it represents the first
                        \ corner of the edge within the tile we are analysing
                        \
                        \ Here are the tile's corner heights that we set in the
                        \ S, T, U and V variables above:
                        \
                        \      ^           [T]  [U]
                        \      |
                        \      |           [S]  [V]
                        \   z-axis
                        \    into
                        \   screen      x-axis from left to right --->
                        \
                        \ The variables S, T, U and V are consecutive in memory,
                        \ so LDA S,X can be used to select corner altitudes for
                        \ values of X, like this:
                        \
                        \      [T]  [U]          [1]  [2]
                        \                   =
                        \      [S]  [V]          [0]  [3]
                        \
                        \ Similarly, LDA T,X will select the altitude for tile
                        \ corner X + 1
                        \
                        \ Note that back in part 2, we set W to the same value
                        \ as S, so this approach will still work if X = 3, as
                        \ LDA T,X will fetch the value of W, which is the tile
                        \ altitude of corner 0, just like S
                        \
                        \ So X (and A) represent the starting corner, and we now
                        \ calculate the coordinates and gradient of the tile
                        \ edge from corner X to corner X + 1, so we can work out
                        \ whether the gaze passes above or below the edge
                        \
                        \ We start by calculating the distance along the tile
                        \ edge that corresponds to the current position of the
                        \ gaze vector
                        \
                        \ To see how this works, consider the axes of the tile
                        \ corners:
                        \
                        \      ^           [1]  [2]
                        \      |
                        \      |           [0]  [3]
                        \   z-axis
                        \    into
                        \   screen      x-axis from left to right --->
                        \
                        \ The low bytes of the current gaze vector in xCoordLo
                        \ and zCoordLo give us the fractional part of the
                        \ coordinate of the current position along the gaze, and
                        \ the fractional part gives us the position of the
                        \ coordinate within the tile (as the tile corners are on
                        \ the integer coordinates)
                        \
                        \ Zooming in on the tile, we have the following, where
                        \ [x] is the current position along the gaze vector when
                        \ looking at the tile from above:
                        \
                        \   [1]                 [2]
                        \     xCoordLo
                        \   <----------> [x]
                        \                 ^
                        \                 |
                        \                 |  zCoordLo
                        \                 |
                        \   [0]           v     [3]
                        \
                        \ We now set edgeGazeDistance to the corner-relative
                        \ coordinate of the gaze vector along the edge that we
                        \ are considering (so if we are examining the edge from
                        \ corner X to corner X + 1, we're looking for the
                        \ distance between corner X and the [x] of the gaze
                        \ vector)
                        \
                        \ For example, if we are considering the left edge from
                        \ 0 to 1, the distance of the [x] relative to corner 0
                        \ and along the edge is zCoordLo, while on the top edge
                        \ from 1 to 2, the distance of the [x] relative to
                        \ corner 1 and along the edge is xCoordLo
                        \
                        \ The other two edges are similar but the distances are
                        \ in the opposite direction to the axes
                        \
                        \ So if we we are considering the bottom edge from 3 to
                        \ 0, the distance is ~xCoordLo, because:
                        \
                        \   xCoordLo + ~xCoordLo = 1
                        \
                        \ So adding xCoordLo and ~xCoordLo together gives us the
                        \ distance between the tile corners (which is 1), so it
                        \ follows that ~xCoordLo is the distance from corner 3
                        \ to the gaze point, as xCoordLo is the distance from
                        \ corner 0 to the gaze point
                        \
                        \ We now set edgeGazeDistance to the correct value

 LSR A                  \ Set Y as follows:
 LDY xCoordLo           \
 BCS gaze14             \   * xCoordLo if A = 1 or 3 (i.e. bit 0 of A is 1)
 LDY zCoordLo           \
                        \   * zCoordLo if A = 0 or 2 (i.e. bit 0 of A is 1)

.gaze14

 LSR A                  \ Set A as follows:
 TYA                    \
 BCC gaze15             \   * A = Y if A = 0 or 1 (i.e. bit 1 of A is 0)
 EOR #%11111111         \
                        \   * A = ~Y if A = 2 or 3 (i.e. bit 1 of A is 1)

.gaze15

 STA edgeGazeDistance   \ Set edgeGazeDistance to the result in A, so we set it
                        \ as follows:
                        \
                        \   * edgeGazeDistance = zCoordLo if A = 0
                        \
                        \   * edgeGazeDistance = xCoordLo if A = 1
                        \
                        \   * edgeGazeDistance = ~zCoordLo if A = 2
                        \
                        \   * edgeGazeDistance = ~xCoordLo if A = 3
                        \
                        \ We use edgeGazeDistance below to calculate where the
                        \ gaze vector crosses the edge

                        \ We now calculate the gradient of the tile edge

 LDA S,X                \ Set G to the altitude of corner X, which we use in the
 STA G                  \ calculation at the end of the routine

 LDA T,X                \ Set A to the altitude of corner X + 1 minus the
 SEC                    \ altitude of corner X
 SBC S,X                \
                        \ So this is the gradient of the edge between corner
                        \ X and corner X + 1

 PHP                    \ Store the flags of the result on the stack, so we can
                        \ retrieve the sign below

 BPL gaze16             \ If the result is negative then negate it to make it
 EOR #%11111111         \ positive, so A now contains the absolute value of the
 CLC                    \ edge gradient
 ADC #1

.gaze16

 STA U                  \ Set U to the absolute gradient of the edge

 LDA edgeGazeDistance   \ Set A to the fractional distance along the edge that
                        \ corresponds to the current position along the gaze
                        \ vector

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = fractional distance * |gradient|


 PLP                    \ Restore the sign of the gradient which we stored on
                        \ the stack above, so the N flag reflects the sign of
                        \ the gradient

 JSR Absolute16Bit      \ Set the sign of (A T) to match the gradient, so A is
                        \ now the correct sign for the calculation and we have
                        \ the following:
                        \
                        \   (A T) = fractional distance * gradient
                        \
                        \ The fractional distance is a fractional value that
                        \ represents how far along the edge we would need to go
                        \ in order to be at the corresponding coordinate as the
                        \ current position along the gaze vector
                        \
                        \ The gradient is the change in altitude as we move from
                        \ one end of the edge to the other
                        \
                        \ Multiplying these two therefore gives us the height of
                        \ the point along the edge that corresponds to the
                        \ current position of the gaze vector
                        \
                        \ This height is relative to the tile corner at the
                        \ start of the edge (i.e. corner X), so to get the
                        \ altitude of the point in the 3D world, we need to add
                        \ the result in (A T) to the altitude of corner X
                        \
                        \ We set G above to the altitude of corner X, which came
                        \ from the call to GetTileAltitude, so G contains the
                        \ high byte of the altitude and is therefore an integer
                        \ value, so we add a low byte of 0 in the addition

 CLC                    \ Set (U T) = (G 0) + (A T)
 ADC G                  \
 STA U                  \ So (U T) contains the altitude of the point on the
                        \ edge that corresponds to the current position of the
                        \ gaze vector

 LDA yCoordLo           \ Set (A *) = (yCoordHi yCoordLo) - (U T)
 SEC                    \
 SBC T                  \ So A contains the high byte of the difference in
 LDA yCoordHi           \ altitude between the current position of the gaze
 SBC U                  \ vector and the point on the edge that corresponds to
                        \ the vector

 BPL gaze17             \ If the current position along the gaze vector is
                        \ higher than the corresponding point on the edge, then
                        \ the viewer's gaze is not being obstructed by the edge,
                        \ so jump to gaze1 via gaze17 to to move along the gaze
                        \ vector and restart the checks

 JMP gaze4              \ Otherwise the current position along the gaze vector
                        \ is below the corresponding point on the edge, and the
                        \ viewer's gaze is being obstructed by the edge, so jump
                        \ to gaze4 to to return from the subroutine with the
                        \ C flag set to indicate that the viewer is not looking
                        \ at a tile

.gaze17

 JMP gaze1              \ Jump to gaze1 to move along the gaze vector and
                        \ restart the checks (this jump point is for use by
                        \ branching instructions)

\ ******************************************************************************
\
\       Name: tileEdges
\       Type: Variable
\   Category: Landscape
\    Summary: A table to map tile shapes and gaze vector direction to tile edges
\
\ ------------------------------------------------------------------------------
\
\ This table contains tile corner numbers from a tile:
\
\      ^           [1]  [2]
\      |
\      |           [0]  [3]
\   z-axis
\    into
\   screen      x-axis from left to right --->
\
\ Each tile corner number represents an edge from the number to the number + 1,
\ so 1 represents the edge from corner 1 to corner 2, for example.
\
\ The table is used to work out which edge should be chosen for the calculation
\ in the FollowGazeVector routine, where we work out whether the gaze vector is
\ hitting a tile slope in a tile with two horizontal edges.
\
\ See part 4 of the FollowGazeVector routine for details of how this table
\ works.
\
\ ******************************************************************************

.tileEdges

 EQUB 0, 3              \ Left and bottom edges (G = 0)
                        \
                        \ First entry (left edge) for xCoordLo < zCoordLo
                        \
                        \ Second entry (bottom edge) for xCoordLo >= zCoordLo

 EQUB 1, 0              \ Top and left edges (G = 1)
                        \
                        \ First entry (top edge) for ~xCoordLo < zCoordLo
                        \
                        \ Second entry (left edge) for ~xCoordLo >= zCoordLo

 EQUB 1, 2              \ Top and right edges (G = 2)
                        \
                        \ First entry (top edge) for xCoordLo < zCoordLo
                        \
                        \ Second entry (right edge) for xCoordLo >= zCoordLo

 EQUB 2, 3              \ Right and bottom edges (G = 3)
                        \
                        \ First entry (right edge) for ~xCoordLo < zCoordLo
                        \
                        \ Second entry (bottom edge) for ~xCoordLo >= zCoordLo

\ ******************************************************************************
\
\       Name: GetTileAltitude
\       Type: Subroutine
\   Category: Landscape
\    Summary: Calculate the altitude of a tile, optionally including platform
\             object and trees in the calculation
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   (xTile, zTile)      The coordinates of the tile to analyse
\
\   considerObjects     The data to extract:
\
\                         * Bit 7 clear = extract the tile's altitude and
\                                         flatness, ignoring any objects on the
\                                         tile
\
\                         * Bit 7 set = if the tile contains a platform object
\                                       (i.e. boulder or tower) or a tree, then
\                                       extract data for the object instead of
\                                       the tile when applicable (this option
\                                       is only set when calling this routine
\                                       from FollowGazeVector)
\
\   xCoordLo            The low byte (i.e. fractional part) of the x-coordinate
\                       of the current position along the gaze vector (when
\                       the routine is called from FollowGazeVector)
\
\   zCoordLo            The low byte (i.e. fractional part) of the z-coordinate
\                       of the current position along the gaze vector (when
\                       the routine is called from FollowGazeVector)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   The high byte of the tile's altitude (though if bit 7 of
\                       considerObjects is set, see platformAltitudeLo below)
\
\   C flag              The tile's shape:
\
\                         * Clear if the tile is flat
\
\                         * Set if the tile is not flat
\
\   platformAltitudeLo  If bit 7 of considerObjects is set and the tile contains
\                       the Sentinel's tower or a boulder, the altitude of the
\                       platform on the top of the tower or boulder is returned
\                       in (A platformAltitudeLo)
\
\   boulderOnTile       If bit 7 of considerObjects is set, this records whether
\                       the tile contains a boulder:
\
\                         * Bit 7 clear = tile does not contain a boulder
\
\                         * Bit 7 set = tile contains a boulder
\
\   targetOnTile        If bit 7 of considerObjects is set, this records whether
\                       the tile contains the target object whose number is in
\                       targetOnTile:
\
\                         * Bit 7 clear = tile does not contain the target
\                                         object
\
\                         * Bit 7 set = tile does contain the target object
\
\   gazeCanSeeTree      If bit 7 of considerObjects is set, this records whether
\                       the tile contains a tree that can be seen by the gaze
\                       vector:
\
\                         * Bit 7 clear = tile does not contain a tree that can
\                                         be seen by the gaze vector
\
\                         * Bit 7 set = tile contains a tree that can be seen by
\                                       the gaze vector
\
\ ******************************************************************************

.GetTileAltitude

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile), setting the C flag if the tile
                        \ contains an object

 BCS data3              \ If the tile contains an object then jump to data3

 PHA                    \ Store the tile data on the stack

 AND #%00001111         \ The tile shape is in the low nibble of the tile data,
 TAY                    \ so extract the tile shape into Y

 PLA                    \ Retrieve the tile data from the stack

 LSR A                  \ Set A to the tile altitude, which is in the top nibble
 LSR A                  \ of the tile data
 LSR A
 LSR A

 CPY #1                 \ Clear the C flag if Y < 1, which will only happen when
                        \ Y = 0, so this clears the C flag if the tile shape is
                        \ flat, or sets the C flag if the tile shape is not flat

 RTS                    \ Return from the subroutine

.data1

                        \ If we get here then the tile contains object #Y and
                        \ bit 7 of considerObjects is set, so we need to process
                        \ the objects on the stack

 CPY targetObject       \ If Y = targetObject then the target object is on the
 BNE data2              \ tile, so set bit 7 of targetOnTile to indicate this
 ROR targetOnTile

.data2

 LDA objectTypes,Y      \ Set A to the type of object that's already on the tile
                        \ (i.e. the type of object #Y)

 CMP #3                 \ If the tile contains an object of type 3 (a boulder),
 BEQ data4              \ jump to data4 to extract details about the boulder

 CMP #2                 \ If the tile contains an object of type 2 (a tree),
 BEQ data4              \ jump to data4 to extract details about the tree

 CMP #6                 \ If the tile doesn't contain the Sentinel's tower (type
 BNE data7              \ 6) then it must contain a robot, sentry, meanie or the
                        \ Sentinel, so jump to data7 to return the altitude of
                        \ the tile rather than the object

                        \ If we get here then the tile contains the Sentinel's
                        \ tower in object #Y

 JSR CheckForTileCentre \ Set T = max(|xCoordLo - 128|, |zCoordLo - 128|)
                        \
                        \ and return the same value in A
                        \
                        \ This calculates how close the current position along
                        \ the gaze vector is to the centre of the tile, in terms
                        \ of the x-coordinate and z-coordinate

 CMP #100               \ If A >= 100 then the gaze vector is a long way from
 BCS data6              \ the centre of the tile (i.e. more than 100/128 = 78%
                        \ of the distance from the centre to the tile edge,
                        \ which is outside the body of the tower), so jump to
                        \ data6 to return the altitude of the tile rather than
                        \ the tower

                        \ If we get here then the gaze vector is pointing at the
                        \ sides of the tower, so we return the altitude of the
                        \ platform on top of the tower

 LDA #16                \ Set L000C = 16 ???
 STA L000C

 LDA yObjectLo,Y        \ Set the following:
 CLC                    \
 ADC #&20               \   (A platformAltitudeLo) = (yObjectHi yObjectLo) + 32
 STA platformAltitudeLo \
 LDA yObjectHi,Y        \ where yObject is the altitude of the Sentinel's tower
 ADC #&00               \
                        \ So we return the altitude of the top of the tower by
                        \ effectively adding the tower's height to the tower
                        \ object's altitude, bearing in mind that objects are
                        \ spawned at a height of 224 above their tiles, so this
                        \ returns the altitude of the top of the tower, with
                        \ the tower being 224 + 32 = 256 fractional parts above
                        \ the tile (so the tower is the height of one entire
                        \ integer y-coordinate)

 CLC                    \ Clear the C flag to indicate that the tile is flat

 RTS                    \ Return from the subroutine

.data3

                        \ If we get here then the tile contains an object

 AND #%00111111         \ Because the tile has an object on it, the tile data
 TAY                    \ contains the number of the top object on the tile in
                        \ bits 0 to 5, so extract the object number into Y (so
                        \ the tile effectively contains object #Y)

 BIT considerObjects    \ If bit 7 of considerObjects is clear, jump to data7 to
 BPL data7              \ return the altitude of the bottom object on the tile,
                        \ iterating down through the stack of objects if there
                        \ is more than one object
                        \
                        \ The altitude of the bottom object is the same as the
                        \ altitude of the tile itself, so this ensures that we
                        \ return the tile's altitude from the subroutine, as per
                        \ bit 7 of considerObjects

 BMI data1              \ Otherwise bit 7 of considerObjects is set, so jump to
                        \ data1 to calculate the ??? (this BMI is effectively a
                        \ JMP as we just passed through a BPL)

.data4

                        \ If we get here then the tile contains a tree or a
                        \ boulder in object #Y

 JSR CheckForTileCentre \ Set T = max(|xCoordLo - 128|, |zCoordLo - 128|)
                        \
                        \ and return the same value in A
                        \
                        \ This calculates how close the current position along
                        \ the gaze vector is to the centre of the tile, in terms
                        \ of the x-coordinate and z-coordinate

 CMP #64                \ If A >= 64 then the gaze vector is more than half way
 BCS data6              \ from the centre of the tile (i.e. more than 64/128 =
                        \ 50% of the distance from the centre to the tile edge,
                        \ which is outside the body of the tree or boulder), so
                        \ jump to data6 to return the altitude of the tile
                        \ rather than the tree or boulder

 LDA objectTypes,Y      \ If object #Y is an object of type 2 (a tree), jump to
 CMP #2                 \ data5
 BEQ data5

                        \ If we get here then the tile contains a boulder in
                        \ object #Y

 SEC                    \ Set bit 7 of boulderOnTile to indicate that the tile
 ROR boulderOnTile      \ contains a boulder

 LDA yObjectLo,Y        \ Set the following:
 SEC                    \
 SBC #&60               \   (A platformAltitudeLo) = (yObjectHi yObjectLo) - 96
 STA platformAltitudeLo \
 LDA yObjectHi,Y        \ where yObject is the altitude of the boulder
 SBC #&00
                        \ So we return the altitude of the top of the boulder by
                        \ effectively adding the boulder's height to the boulder
                        \ object's altitude, bearing in mind that objects are
                        \ spawned at a height of 224 above their tiles, so this
                        \ returns the altitude of the top of the boulder, with
                        \ the boulder being 224 - 96 = 128 fractional parts
                        \ above the tile (so the boulder is the height of one
                        \ half of a y-coordinate)

 CLC                    \ Clear the C flag to indicate that the tile is flat

 RTS                    \ Return from the subroutine

.data5

                        \ If we get here then the tile contains a tree in
                        \ object #Y

 LDA yObjectLo,Y        \ Set the following:
 SEC                    \
 SBC yCoordLo           \   (A U) =  (yObjectHi yObjectLo) - (yCoordHi yCoordLo)
 STA U                  \
 LDA yObjectHi,Y        \ where yObject is the altitude of the tree
 SBC yCoordHi           \
                        \ So (A U) contains the relative altitude of the current
                        \ position along the gaze vector compared to the tree,
                        \ with a positive value indicating that the gaze is
                        \ is below the tree, and a negative value indicating
                        \ that the gaze is above the tree

 PHA                    \ Set (A U) = (A U) + 224
 LDA U                  \
 CLC                    \ This adds the height of the tree to (A U), as trees
 ADC #&E0               \ have a height of 224 fractional y-coordinates, so the
 STA U                  \ value in (A U) is now relative to the top of the tree,
 PLA                    \ so it is effectively the height difference between the
 ADC #&00               \ gaze and the tree top

 BMI data6              \ If A is negative then the current position along the
                        \ gaze vector is above the top of the tree, so jump to
                        \ data6 to return the altitude of the tile rather than
                        \ the tree

 LSR A                  \ Set (A U) = (A U) / 2
 ROR U                  \
                        \ So (A U) is now half the height difference between the
                        \ gaze and tree top

 LSR A                  \ If any of bits 1 to 7 of A are set then A >> 1 will be
 BNE data6              \ non-zero and the original value of (A U) must have
                        \ been at least %100, so that's a positive value with a
                        \ high byte of at least 4
                        \
                        \ This means the gaze vector is too far below the tree
                        \ for it to be visible, so jump to data6 to return the
                        \ altitude of the tile rather than the tree

 LDA U                  \ If we get here then we know A >> 1 = 0, so we can
 ROR A                  \ halve (U A) again and discard the top byte, as it will
                        \ be zero, so this sets:
                        \
                        \   A = (U A) / 2
                        \
                        \ So this is the original height difference between the
                        \ gaze and tree top, divided by 4

                        \ We set T above to the maximum distance between the
                        \ gaze vector and the centre of the tile in terms of the
                        \ horizontal axes

 CMP T                  \ If A < T then the gaze is further from the centre of
 BCC data6              \ the tile than the height difference to the tree top
                        \ divided by 4, so jump to data6 to return the altitude
                        \ of the tile rather than the tree
                        \
                        \ The centre point of the tile is the tree trunk, so
                        \ this test means that gazes at the lower parts of the
                        \ tree can be further from the centre point than gazes
                        \ at the upper parts of the tree, while still being
                        \ considered gazes that fall upon the tree
                        \
                        \ This fits in with the tree's shape and makes the tree
                        \ detection code more accurate

 BIT targetOnTile       \ If bit 7 of targetOnTile is set then the tree is
 BMI data6              \ the targeted object, so skip the following so that ???

 SEC                    \ Set bit 7 of gazeCanSeeTree to indicate that the tree
 ROR gazeCanSeeTree     \ can be seen by the gaze vector

.data6

 LDA objectTypes,Y      \ Set A to the type of object #Y

 CMP #2                 \ If the tile contains an object of type 2 (a tree),
 BEQ data7              \ jump to data7 to skip the following instruction

 LDA #%11000000         \ Set bits 6 and 7 of considerObjects ???
 STA considerObjects

.data7

 LDA objectFlags,Y      \ Set A to the object flags for object #Y

 CMP #%01000000         \ If bit 6 of the object flags for object #Y is set
 BCS data3              \ then object #Y is stacked on top of another object,
                        \ so jump to data3 with the object number in bits 0 to
                        \ 5 of the object flags in A, so we can process that
                        \ object instead

 LDA yObjectHi,Y        \ Bt this point we have reached the object on the tile
                        \ itself, so set A to the y-coordinate of that object,
                        \ which will be the tile altitude, and return from the
                        \ subroutine with the C flag clear to denote a flat
                        \ tile, as objects are only ever placed on flat tiles

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: CheckForTileCentre
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate max(|xCoordLo - 128|, |zCoordLo - 128|)
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   xCoordLo            The low byte of an x-coordinate for comparing to the
\                       centre of a tile (i.e. a fractional part)
\
\   zCoordLo            The low byte of an z-coordinate for comparing to the
\                       centre of a tile (i.e. a fractional part)
\
\ ******************************************************************************

.CheckForTileCentre

                        \ We check the distance of the fractional coordinate in
                        \ (xCoordLo, zCoordLo) from the centre of the tile by
                        \ subtracting from (128, 128), as 128 represents 0.5 in
                        \ fractional terms

 LDA xCoordLo           \ Set A = |xCoordLo - 128|
 SEC
 SBC #128
 BPL maxc1
 EOR #%11111111

.maxc1

 STA T                  \ Set T = |xCoordLo - 128|

 LDA zCoordLo           \ Set A = |zCoordLo - 128|
 SEC
 SBC #128
 BPL maxc2
 EOR #%11111111

.maxc2

 CMP T                  \ If A >= T then A is already set to the higher value
 BCS maxc3              \ out of A and T, so jump to maxc3

 LDA T                  \ If we get here then A < T, so set A to the value of T
                        \ so A is now set the higher value out of A and T

.maxc3

 STA T                  \ A is set to the higher value of A and T, so this does
                        \ the following:
                        \
                        \   T = max(A, T)
                        \
                        \     = max(|xCoordLo - 128|, |zCoordLo - 128|)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetObjectCoords
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Get an object's coordinates
\
\ ------------------------------------------------------------------------------
\
\ This routine fetches the cartesian coordinates of object #X as three 24-bit
\ numbers, as follows:
\
\   (xCoordHi xCoordLo xCoordBot)
\
\   (yCoordHi yCoordLo yCoordBot)
\
\   (zCoordHi zCoordLo zCoordBot)
\
\ The high byte can be thought of as the integer with low and bottom bytes as
\ the fractional part.
\
\ Tile corners are integers in the x- and z-axis, and objects are placed in the
\ centre of tiles by setting the fractional part to 0.5. So an object that's
\ been placed directly on the tile that's anchored at (2, y, 3) will appear at
\ (2.5, y, 3.5).
\
\ The y-coordinate - i.e. the altitude of the object above the tile itself -
\ depends on the object type and whether it is stacked on top of another object.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   An object number
\
\ ******************************************************************************

.GetObjectCoords

 LDA #0                 \ Set the bottom byte of each coordinate to zero
 STA xCoordBot
 STA yCoordBot
 STA zCoordBot

 LDA #128               \ Set the low byte of the x- and -z-coordinates to 128
 STA xCoordLo           \ (which represents 0.5, so the object sits in the
 STA zCoordLo           \ middle of the tile on which it is placed)

 LDA yObjectLo,X        \ Set the low byte of the y-coordinate to the altitude
 STA yCoordLo           \ of object #X

 LDA xObject,X          \ Set the high byte of the x-coordinate to the value for
 STA xCoordHi           \ object #X from the xObject table

 LDA yObjectHi,X        \ Set the high byte of the y-coordinate to the value for
 STA yCoordHi           \ object #X from the yObjectHi table

 LDA zObject,X          \ Set the high byte of the z-coordinate to the value for
 STA zCoordHi           \ object #X from the zObject table

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DeleteObject
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Delete an object, removing it from the landscape and vacating its
\             object number
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of the object to delete
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   X is preserved
\
\ ******************************************************************************

.DeleteObject

 LDA xObject,X          \ Set (xTile, zTile) to the tile coordinates of the
 STA xTile              \ tile containing object #X
 LDA zObject,X
 STA zTile

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile), which we ignore, but this also sets
                        \ the tile page in tileDataPage and the index in Y, so
                        \ tileDataPage+Y now points to the tile data entry in
                        \ the tileData table for object #X

 LDA objectFlags,X      \ Set A to the object flags for object #X

 CMP #%01000000         \ If both bits 6 and 7 of the object flags for object #X
 BCC delo1              \ are clear then object #X is not stacked on top of
                        \ another object, so jump to delo1 to remove object #X
                        \ from the tile itself

                        \ If we get here then object #X is stacked on top of
                        \ another object, and the number of that object is in
                        \ bits 0 to 5 of the object flags for object #X, which
                        \ is currently in A

 ORA #%11000000         \ Set bits of 6 and 7 of A to create a byte with the
                        \ number of the object below object #X in bits 0 to 5,
                        \ and bits 6 and 7 set
                        \
                        \ We now set this as the updated tile data for the tile
                        \ that used to contain object #X at the top of the
                        \ stack, but which now contains the next object down on
                        \ the top of the stack instead

 BNE delo2              \ Jump to delo2 to store A as the new tile data for this
                        \ tile (this BNE is effectively a JMP as the value of A
                        \ before the ORA has to have at least one of bits 6 and
                        \ 7 set, so the result of the ORA is never zero)

.delo1

                        \ If we get here then object #X is not stacked on top of
                        \ another object, so we can remove the object from the
                        \ tile by changing the tile data into the following
                        \ format:
                        \
                        \   * The low nibble contains the tile shape, which in
                        \     this case is flat because only flat tiles can
                        \     contain objects, so we need to set the low nibble
                        \     to shape 0 (to indicate a flat tile)
                        \
                        \   * The high nibble contains the altitude of the tile
                        \     corner in the front-left corner of the tile
                        \
                        \ The altitude of object #X is a 16-bit value in
                        \ (yObjectHi yObjectLo), where the yObjectLo part is
                        \ effectively a fractional part of the altitude that
                        \ describes how far the object is above the tile itself
                        \
                        \ Tile altitudes are whole numbers, so the altitude of
                        \ the tile on which object #X is placed is given in the
                        \ high byte of the object's 16-bit altitude

 LDA yObjectHi,X        \ Set the high nibble of A to the high byte of the
 ASL A                  \ altitude of object #X (which is the tile's altitude)
 ASL A                  \ and set the low nibble to zero to indicate a flat tile
 ASL A                  \
 ASL A                  \ A is now in the format required for the tileData table
                        \ for a flat tile that doesn't contain an object, so we
                        \ can update the tile's data to remove object #X from
                        \ the tile

.delo2

 STA (tileDataPage),Y   \ Update the tile data for object #X to the value in A
                        \ (as we set Y to the relevant index with the call to
                        \ GetTileData above)

 LDA #%10000000         \ Set bit 7 of the object flags for object #X to denote
 STA objectFlags,X      \ that object number X has not been allocated to an
                        \ object and is reusable, so this effectively deletes
                        \ the object

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PlaceObjectOnTile
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Place an object on a tile, putting it on top of any existing
\             boulders or towers
\
\ ------------------------------------------------------------------------------
\
\ This routine sets the following (if successful):
\
\   * X-th entry in (xObject, yObject, zObject) is set to the 3D coordinate of
\     the newly added object, where the y-coordinate is (yObjectHi yObjectLo)
\
\   * X-th entry in objectFlags, bit 7 is clear to indicate that object #X has
\     been allocated to an object
\
\   * X-th entry in objectFlags, bit 6 is set if we add the object on top of a
\     boulder or tower (and the object number of the boulder/tower is in bits
\     0-5)
\
\   * X-th entry in yObjectLo = &E0 ???
\
\   * X-th entry in objectPitchAngle = &F5 ???
\
\   * X-th entry in objectYawAngle is set to a multiple of 11.25 degrees, as
\     determined by the next seed
\
\   * tileData for the tile is set to the object number in X in bits 0 to 5, and
\     bits 6 and 7 are set to indicate that the tile contains an object
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of the object to add to the tile
\
\   (xTile, zTile)      The tile coordinate where we place the object
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   C flag              Status flag:
\
\                         * Clear if we successfully added the object to the
\                           tile
\
\                         * Set if we failed to add the object to the tile (if
\                           the tile is occupied by an object that is not a
\                           a boulder or tower, for example)
\
\ ******************************************************************************

.PlaceObjectOnTile

 LDA xTile              \ Set the 3D coordinate for object #X to (xTile, zTile)
 STA xObject,X          \ by updating the X-th entries in the xObject and
 LDA zTile              \ zObject tables
 STA zObject,X          \
                        \ So this sets the x- and z-coordinates of the 3D
                        \ coordinate for our object; we set the y-coordinate
                        \ later

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile), setting the C flag if the tile
                        \ contains an object
                        \
                        \ This also sets the tile page in tileDataPage and the
                        \ tile number in Y, so tileDataPage+Y now points to the
                        \ tile data entry in the tileData table

 BCC objt4              \ If C flag is clear then this tile does not already
                        \ have an object placed on it, so jump to objt4 to place
                        \ object #X on the tile

 STY tileNumber         \ Store the tile number in tileNumber so we can refer to
                        \ it later

 AND #%00111111         \ Because the tile has an object on it, the tile data
 TAY                    \ contains the number of the top object on the tile in
                        \ bits 0 to 5, so extract the object number into Y (so
                        \ the tile effectively contains object #Y)

 LDA objectTypes,Y      \ Set A to the type of object that's already on the tile
                        \ (i.e. the type of object #Y)

 CMP #3                 \ If the tile contains an object of type 3 (a boulder),
 BEQ objt1              \ jump to objt1 to put the new object on top of the
                        \ boulder

 CMP #6                 \ If the tile doesn't contain the Sentinel's tower (type
 BNE objt6              \ 6) then it must contain an object on which we can't
                        \ place our new object, so jump to objt6 to return from
                        \ the subroutine without adding the object to the tile

.objt1

                        \ If we get here then the object already on the tile is
                        \ either a boulder (type 3) or the Sentinel's tower
                        \ (type 6)
                        \
                        \ In either case, we want to place our object on top of
                        \ the object that is already there, which we can do by
                        \ setting bit 6 of the object flags for the new object
                        \ and putting the number of the existing object into
                        \ bits 0 to 5

 TYA                    \ Set the object flags for the object that we are adding
 ORA #%01000000         \ (i.e. object #X) so that bit 6 is set, and bits 0 to 5
 STA objectFlags,X      \ contain the number of the object that is already on
                        \ the tile
                        \
                        \ This denotes that our new object, object #X, is on top
                        \ of object #Y

 LDA objectTypes,Y      \ If the object that's already on the tile is not the
 CMP #6                 \ Sentinel's tower (type 6), jump to objt2
 BNE objt2

                        \ If we get here then we are placing object #X on top of
                        \ the Sentinel's tower (type 6) in object #Y
                        \
                        \ The next task is to calculate the altitude of the
                        \ object when it is placed on top of the tower (i.e. the
                        \ y-coordinate of the object, as the y-axis goes up and
                        \ down in our 3D world)
                        \
                        \ The tower is defined with a height of one coordinate
                        \ (where a tile-sized cube is one coordinate across)
                        \
                        \ Object y-coordinates are stored as 16-bit numbers in
                        \ the form (yObjectHi yObjectLo), with the low byte
                        \ effectively acting like a fractional part, so to work
                        \ out the y-coordinate for the object we are placing on
                        \ top of the boulder, we need to add (1 0) to the
                        \ tower's current y-coordinate, like this:
                        \
                        \   yObject,X = yObject,Y + (1 0)
                        \
                        \ We need to do this calculation for both bytes,
                        \ starting with the low byte

 LDA yObjectLo,Y        \ First we add the low bytes, by adding 0 to the Y-th
 STA yObjectLo,X        \ entry in yObjectLo and storing this in the low byte of
                        \ the X-th entry in yObjectLo (which we can do by simply
                        \ copying the Y-th entry into the X-th entry)

 CLC                    \ Clear the C flag and set A = 1 so the addition at
 LDA #1                 \ objt3 will do the following:
                        \
                        \   A = yObjectHi,Y + 1
                        \
                        \ This will add the high bytes of the calculation to
                        \ give the result we want:
                        \
                        \   (A yObjectLo,X) = (yObjectHi,Y yObjectLo,Y) + (1 0)
                        \
                        \                   = ((yObjectHi,Y + 1) yObjectLo,Y)
                        \
                        \ with the subsequent jump to objt5 storing A in
                        \ yObjectHi,X as required

 BNE objt3              \ Jump to objt3 to do the calculation (this BNE is
                        \ effectively a JMP as A is never zero)

.objt2

                        \ If we get here then we are placing our new object #X
                        \ on top of the boulder (type 3) in object #Y
                        \
                        \ The next task is to calculate the altitude of the
                        \ object when it is placed on top of the boulder (i.e.
                        \ the y-coordinate of the object, as the y-axis goes up
                        \ and down in our 3D world)
                        \
                        \ Boulders are defined with a height of 0.5 coordinates
                        \ (where a tile-sized cube is one coordinate across)
                        \
                        \ Object y-coordinates are stored as 16-bit numbers in
                        \ the form (yObjectHi yObjectLo), with the low byte
                        \ effectively acting like a fractional part, so to work
                        \ out the y-coordinate for the object we are placing on
                        \ top of the boulder, we need to add (0 128) to the
                        \ boulder's current y-coordinate, like this:
                        \
                        \   yObject,X = yObject,Y + (0 128)
                        \
                        \ We need to do this calculation for both bytes,
                        \ starting with the low byte

 LDA yObjectLo,Y        \ First we add the low bytes, by adding 128 to the Y-th
 CLC                    \ entry in yObjectLo and storing this in the low byte of
 ADC #128               \ the result in the X-th entry in yObjectLo
 STA yObjectLo,X

 LDA #0                 \ Set A = 0 so the following addition will add the high
                        \ bytes to give the result we want:
                        \
                        \   (A yObjectLo,X) = (yObjectHi,Y yObjectLo,Y)
                        \                     + (0 128)
                        \
                        \                   = (yObjectHi,Y (yObjectLo,Y + 128))
                        \
                        \ with the subsequent jump to objt5 storing A in
                        \ yObjectHi,X as required

.objt3

 ADC yObjectHi,Y        \ Add A to the high byte of the y-coordinate of the
                        \ object beneath the one we are adding and store the
                        \ result in A
                        \
                        \ So (A yObjectLo,X) now contains the y-coordinate of
                        \ the new object that we are placing on top of the
                        \ boulder or tower

 LDY tileNumber         \ Set Y to the tile number where we are adding the
                        \ object, which we stored above

 JMP objt5              \ Jump to objt5 to store A as the y-coordinate of the
                        \ new object on the tile, and update the various other
                        \ object and tile tables for the new object

.objt4

 PHA                    \ Store the tile data for the tile on the stack so we
                        \ can retrieve it below

 LDA #0                 \ Clear bit 7 of the object's flags to indicate that
 STA objectFlags,X      \ object #X is allocated to an object

 LDA #224               \ Set the object's entry in yObjectLo to 224
 STA yObjectLo,X        \
                        \ This appears to place objects well above the tile, at
                        \ a height of 224/256 = 0.875 coordinates above the tile
                        \ itself ???

 PLA                    \ Set A to the tile data for the tile, which we stored
                        \ on the stack above

 LSR A                  \ The top nibble of the tile data contains the tile
 LSR A                  \ altitude, so this sets A to the tile altitude
 LSR A
 LSR A

                        \ We now fall through into objt5 to set the tile
                        \ y-coordinate for object #X to the tile altitude in A

.objt5

 STA yObjectHi,X        \ Set the high byte of the 3D y-coordinate for object #X
                        \ to the value of A by updating the X-th entry in the
                        \ yObjectHi table
                        \ 
                        \ We now have a full 3D coordinate for the object in
                        \ (xObject, yObject, zObject), where yObject is stored
                        \ as a 16-bit number in (yObjectHi yObjectLo)

 TXA                    \ Set the tile data for this tile to object number X,
 ORA #%11000000         \ with bits 6 and 7 set to indicate that the tile now
 STA (tileDataPage),Y   \ contains an object

 LDA #245               \ Set the object's pitch angle to 245, or -11 degrees
 STA objectPitchAngle,X \ ???

                        \ We now calculate the object's yaw angle, which
                        \ determines the direction in which it is facing
                        \
                        \ The degree system in the Sentinel looks like this:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of object
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ In this context, looking straight ahead means the
                        \ object is looking into the screen, towards the back of
                        \ the landscape

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers

 AND #%11111000         \ Convert A to be a multiple of 8 and in the range 0 to
                        \ 248 (i.e. 0 to 31 * 8)
                        \
                        \ This rotates the object so it is looking along one of
                        \ 32 fixed rotations, each of which is a multiple of
                        \ 11.25 degrees

 CLC                    \ Set A = A + 96
 ADC #96                \
                        \ This doesn't change the fact that A is a multiple of
                        \ 11.25 degrees, so it's presumably intended to make the
                        \ player's rotation work well on the starting level

 STA objectYawAngle,X   \ Set the object's objectYawAngle to the angle we just
                        \ calculated in A

 CLC                    \ Clear the C flag to indicate that we have successfully
                        \ added the object to the tile

 RTS                    \ Return from the subroutine

.objt6

                        \ If we get here then the tile already contains an
                        \ object and that object is not a boulder (type 3) or
                        \ tower (type 6), so we can't add the new object to the
                        \ tile

 SEC                    \ Set the C flag to indicate that we have failed to add
                        \ the object to the tile

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: tileNumber
\       Type: Variable
\   Category: 3D objects
\    Summary: The tile number to which we are adding an object in the
\             PlaceObjectOnTile routine
\
\ ******************************************************************************

.tileNumber

 EQUB 0

\ ******************************************************************************
\
\       Name: sub_C1F84
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.C1F78

 LDA #0
 STA L0C6D
 STA L0C4D

 STA L0C1E              \ Clear bit 7 of L0C1E ???

 RTS

.sub_C1F84

 JSR sub_C2096
 BCS C1F78
 LDA #&19
 STA L2094
 LDA L0C6D
 BPL C1F98
 SEI
 JSR RemoveSights
 CLI

.C1F98

 LDX viewingObject
 LDA L0C62
 STA L2095
 LDA #0
 LSR L2095
 ROR A
 STA yawAdjustmentLo
 LDA L2095
 ADC objectYawAngle,X
 STA objectYawAngle,X
 LDY #0
 STY lastPanKeyPressed
 LDA bufferColumns
 JSR sub_C2997

 LDA #25                \ Set A = 25 to pass to FillScreen, so we fill the
                        \ screen buffer (as opposed to screen memory)

 LDY #24                \ Set Y = 24 to pass to FillScreen, so we fill 24
                        \ character rows of the screen buffer

 LDX bufferColumns      \ Set X = bufferColumns to pass to FillScreen, so we
                        \ fill bufferColumns character columns in the screen
                        \ buffer

 JSR FillScreen         \ Call FillScreen to fill the screen buffer with the
                        \ background specified in screenBackground
                        \
                        \ screenBackground variable is zeroed in DrawTitleView
                        \ before the gameplay starts, so alll calls to the
                        \ FillScreen routine during gameplay fill the buffer
                        \ with alternating colour 0/1 (blue/black) pixel rows,
                        \ for the sky

 BIT L0C4D
 BPL C1FD2
 LDY currentObject
 JSR DrawObject
 JMP C1FD5

.C1FD2

 JSR DrawLandscapeView  \ Draw the landscape view

.C1FD5

 LDY #0                 \ Set screenBufferAddr(1 0) to the address of the left
 JSR SetBufferAddress   \ column of the screen buffer

 LDX viewingObject
 LDA #0
 STA yawAdjustmentLo
 SEC
 LDA objectYawAngle,X
 SBC L2095
 STA objectYawAngle,X
 LDA #0
 STA U
 LDA L0C62
 ASL A
 ASL A
 ASL A
 ROL U
 CLC
 ADC viewScreenAddr
 STA L2092
 LDA viewScreenAddr+1
 ADC U
 CMP #&80
 BCC C2008
 SBC #&20

.C2008

 STA L2092+1
 BIT L0C6D
 BVC C2022
 BIT sentinelHasWon
 BPL C201A
 LDA #&28
 STA L2094

.C201A

 JSR sub_C5E5F
 LDA sentinelHasWon
 BMI C2061

.C2022

 SEI
 JSR RemoveSights
 SEC
 ROR doNotDrawSights
 CLI
 LDA L2092
 STA toAddr
 LDA L2092+1
 STA toAddr+1
 LDA bufferColumns
 STA loopCounter
 JMP C2058

.C203D

 LDA L2092
 CLC
 ADC #&08
 STA L2092
 STA toAddr
 LDA L2092+1
 ADC #&00
 CMP #&80
 BCC C2053
 SBC #&20

.C2053

 STA L2092+1
 STA toAddr+1

.C2058

 LDY lastPanKeyPressed  \ Set Y to the direction of the last pan key that was
                        \ pressed (which may not still be held down)
                        \
                        \ So this contains the direction of any scrolling that
                        \ we still need to apply, as follows:
                        \
                        \   * 0 = pan right
                        \
                        \   * 1 = pan left
                        \
                        \   * 2 = pan up
                        \
                        \   * 3 = pan down

 JSR ShowScreenBuffer   \ Update the player's scrolling landscape view by
                        \ copying the relevant parts of the screen buffer into
                        \ screen memory

 DEC loopCounter
 BNE C203D

.C2061

 LDA L0C62
 CLC
 ADC bufferColumns
 STA L0C62
 LDA L0C6A
 SEC
 SBC bufferColumns
 BEQ C2080
 STA L0C6A
 STA bufferColumns
 STA L2094
 JMP C1F98

.C2080

 LSR doNotDrawSights
 LDA sightsAreVisible
 BPL C208D
 SEI
 JSR DrawSights
 CLI

.C208D

 JMP C1F78

\ ******************************************************************************
\
\       Name: screenBufferAddr
\       Type: Variable
\   Category: Screen buffer
\    Summary: Storage for the address for the current drawing operation in the
\             screen buffer
\
\ ******************************************************************************

.screenBufferAddr

 EQUW &0000

\ ******************************************************************************
\
\       Name: L2092
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L2092

 EQUW &0000

\ ******************************************************************************
\
\       Name: L2094
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L2094

 EQUB &00

\ ******************************************************************************
\
\       Name: L2095
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L2095

 EQUB &00

\ ******************************************************************************
\
\       Name: sub_C2096
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C2096

 LDY currentObject
 CPY playerObject
 BEQ C2105
 JSR GetObjectAngles
 LDY currentObject
 LDX objectTypes,Y
 LDA L2107,X
 CMP L0CD4
 BCS C20AF
 LDA L0CD4

.C20AF

 STA xDeltaLo
 LDA #0
 STA L0CD4
 JSR GetPitchAngleDelta
 LDA objectViewYawLo
 SEC
 SBC angleLo
 STA T
 LDA objectViewYawHi
 SBC angleHi
 BPL C20CC
 LDA #0
 BEQ C20D3

.C20CC

 ASL T
 ROL A
 CMP #&28
 BCS C2105

.C20D3

 STA L0C62
 LDA objectViewYawLo
 CLC
 ADC angleLo
 STA T
 LDA objectViewYawHi
 ADC angleHi
 BMI C2105
 ASL T
 ROL A
 CMP #&28
 BCC C20EE
 LDA #&27

.C20EE

 CLC
 ADC #&01
 SEC
 SBC L0C62
 STA L0C6A
 BEQ C2105
 CMP #&15
 BCC C2100
 LDA #&14

.C2100

 STA bufferColumns
 CLC
 RTS

.C2105

 SEC
 RTS

\ ******************************************************************************
\
\       Name: L2107
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L2107

 EQUB &3E, &46, &72, &7A, &4A, &4E, &C1

\ ******************************************************************************
\
\       Name: SpawnObject
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Add a new object of the specified type to the objectTypes table
\
\ ------------------------------------------------------------------------------
\
\ This routine spawns a new object by searching the objectFlags table for a free
\ number to allocate. If there is no free number then the routine returns with
\ the C flag set, otherwise the C flag is clear, X and currentObject are set to
\ the number of the new object, and the object type is added to the objectTypes
\ table.
\
\ Note that this routine only adds the object to the objectTypes table; it
\ doesn't update the flags or add any other information about the object.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The type of object to spawn:
\
\                         * 0 = Robot (one of which is the player)
\
\                         * 1 = Sentry
\
\                         * 2 = Tree
\
\                         * 3 = Boulder
\
\                         * 4 = Meanie
\
\                         * 5 = The Sentinel
\
\                         * 6 = The Sentinel's tower
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   The number of the new object (if successful)
\
\   currentObject       The number of the new object (if successful)
\
\   C flag              Status flag:
\
\                         * Clear if the object was successfully spawned
\
\                         * Set if there is no free number for the new object
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   SpawnObject+3       Spawn an object of the type specified in keyPress
\
\                       The keyPress and objectType variables share the same
\                       memory location, so this lets us store object types in
\                       the key press codes in keyLoggerConfig, so that pressing
\                       one of the "create" keys will automatically spawn that
\                       type of object
\
\ ******************************************************************************

.SpawnObject

 STA objectType         \ Store the object type in objectType for future
                        \ reference

 LDX #63                \ In order to be able to create a new object, we need to
                        \ find an unallocated object number in the objectFlags
                        \ table
                        \
                        \ The game can support up to 64 objects, each with its
                        \ own number (0 to 63), so set a counter in X to work
                        \ through the object numbers until we find one that is
                        \ not allocated to an object

.sobj1

 LDA objectFlags,X      \ Set A to the object flags for object #X, which are
                        \ stored in the X-th entry in the objectFlags table

 BMI sobj2              \ If bit 7 of object flags for object #X is set then
                        \ this object number is not yet allocated to an object,
                        \ so jump to sobj2 use this number for our new object

 DEX                    \ Otherwise decrement the counter in X to move on to the
                        \ next object number

 BPL sobj1              \ Loop back to sobj1 to check the next object number

 SEC                    \ If we get here then we have checked all 64 object
                        \ numbers and none of them are free, so set the C flag
                        \ to indicate that we have failed to spawn the object

 RTS                    \ Return from the subroutine

.sobj2

                        \ If we get here then we have found an unallocated
                        \ object number in the objectFlags table at index X

 STX currentObject      \ Set currentObject to the object number in X

 LDA objectType         \ Set the corresponding entry in the objectTypes table
 STA objectTypes,X      \ to the object type that we are spawning, which we
                        \ stored in objectType above

 CLC                    \ Clear the C flag to indicate that we have successfully
                        \ added a new object to the objectFlags table

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: UpdatePlayerEnergy
\       Type: Subroutine
\   Category: Gameplay
\    Summary: Update the player's energy levels by adding or subtracting the
\             amount of energy in a specific object
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of the object whose energy is being added to
\                       or subtracted from the player's energy
\
\   C flag              Controls whether we add or subtract the energy:
\
\                         * Clear = add object #X's energy to the player's
\                                   energy
\
\                         * Set = Subtract object #X's energy from the player's
\                                 energy
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   C flag              Result flag:
\
\                         * Clear if the player still has a positive energy
\                           level after the update
\
\                         * Set if the player now has a negative energy level,
\                           which means the Sentinel has won
\
\ ******************************************************************************

.UpdatePlayerEnergy

 LDY objectTypes,X      \ Set Y to the object type of object #X

 LDA playerEnergy       \ Set A to the player's current energy level

 BCC uple1              \ If the C flag argument is clear, jump to uple1 to add
                        \ the energies

                        \ Otherwise the C flag argument is set, so we subtract
                        \ object #X's energy from the player's energy in A

 SBC objectTypeEnergy,Y \ The objectTypeEnergy table contains the energy levels
                        \ for each of the object types, so this subtracts the
                        \ energy of object #X from the player's energy in A
                        \
                        \ The subtraction works because we know the C flag is
                        \ set, as we just passed through a BCC

 BCS uple2              \ If the subtraction didn't underflow then the player
                        \ still has some energy left, so jump to uple2 to return
                        \ from the subroutine with the C flag clear

 SEC                    \ The player now has negative energy, so return from the
                        \ subroutine with the C flag set to indicate this

 RTS                    \ Return from the subroutine

.uple1

                        \ If we get here then the C flag argument is clear, so
                        \ we add object #X's energy to the player's energy in A


 ADC objectTypeEnergy,Y \ The objectTypeEnergy table contains the energy levels
                        \ for each of the object types, so this adds the energy
                        \ of object #X to the player's energy in A
                        \
                        \ The addition works because we know the C flag is
                        \ clear, as we got here by taking a BCC

.uple2

 AND #63                \ Cap the value in A to a maximum of 63, so the player's
                        \ energy is always in the range 0 to 63

 STA playerEnergy       \ Update the player's energy level to the new level in A

 CLC                    \ Clear the C flag to indicate that the player still has
                        \ a positive amount of energy (i.e. 0 or above)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: objectTypeEnergy
\       Type: Variable
\   Category: 3D objects
\    Summary: The amout of energy required to create each object or the amount
\             energy acquired when absorbing each object
\
\ ******************************************************************************

.objectTypeEnergy

 EQUB 3                 \ Robot = 3 energy

 EQUB 3                 \ Sentry = 3 energy

 EQUB 1                 \ Tree = 1 energy

 EQUB 2                 \ Boulder = 2 energy

 EQUB 1                 \ Meanie = 1 energy

 EQUB 4                 \ The Sentinel = 4 energy

 EQUB 0                 \ The Sentinel's tower = 0 energy

\ ******************************************************************************
\
\       Name: PerformHyperspace
\       Type: Subroutine
\   Category: Gameplay
\    Summary: Hyperspace the player to a brand new tile, ideally at the same
\             altitude as the current tile
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   C flag              Returns:
\
\                         * Clear if the hyperspace was a success, or if the
\                           player didn't have enough energy to hyperspace
\
\                         * Set if we could not spawn a robot to use as the
\                           destination for the hyperspace
\
\ ******************************************************************************

.PerformHyperspace

 LDA #0                 \ Spawn a robot (an object of type 0), returning the
 JSR SpawnObject        \ object number of the new object in X and currentObject

 LDX playerObject       \ Set A to the high byte of the altitude of the player
 LDA yObjectHi,X        \ object (i.e. the high byte of the player object's
                        \ y-coordinate in yObjectHi)

 CLC                    \ Increment A so it's one coordinate higher than the
 ADC #1                 \ player object, so the call to PlaceObjectBelow will
                        \ try to hyperspace the player to the same height as
                        \ before

 LDX currentObject      \ Set X to the object number of the new robot that we
                        \ spawned above

 JSR PlaceObjectBelow   \ Attempt to place the new robot on a tile that is below
                        \ the maximum altitude specified in A (though we may end
                        \ up placing the object higher than this)

 BCS hypr4              \ If the call to PlaceObjectBelow sets the C flag then
                        \ the object has not been successfully placed, so jump
                        \ to hypr4 to return from the subroutine with the C flag
                        \ set to indicate that we haven't managed to hyperspace
                        \ the player

 SEC                    \ Call UpdatePlayerEnergy with the C flag set to
 JSR UpdatePlayerEnergy \ subtract the amount of energy in object #X from the
                        \ player's energy
                        \
                        \ Object #X is the robot we just spawned, so this will
                        \ subtract three energy points from the player

 BCC hypr1              \ If the player still has positive energy then the call
                        \ to UpdatePlayerEnergy will clear the C flag, so jump
                        \ to hypr1 to keep going

                        \ If we get here then the player doesn't have enough
                        \ energy to create a robot for hyperspacing

 JSR DeleteObject       \ Delete object #X and remove it from the landscape, so
                        \ we remove the robot that we just spawned

 LDA #3                 \ Set screenBackground = 3 so the next time the screen
 STA screenBackground   \ is cleared, it shows a black background with stars

 LDA #%10000000         \ Set bit 7 of hyperspaceEndsGame to indicate that the
 STA hyperspaceEndsGame \ game has ended with a hyperspace, and clear bit 6 to
                        \ indicate that the game has ended because the player
                        \ has run out of energy

 BNE hypr3              \ Jump to hypr3 to return from the subroutine (this BNE
                        \ is effectively a JMP as A is never zero)

.hypr1

 LDA #0                 \ Call the PlayMusic routine with A = 0 to play the
 JSR PlayMusic          \ hyperspace music

 LDX playerObject       \ If the player is not on the Sentinel's tile in terms
 LDA xObject,X          \ of the x-coordinate, jump to hypr2
 CMP xTileSentinel
 BNE hypr2

 LDA zObject,X          \ If the player is not on the Sentinel's tile in terms
 CMP zTileSentinel      \ of the z-coordinate, jump to hypr2
 BNE hypr2

                        \ The player is on the Sentinel's tile in both axes, so
                        \ they must have hyperspaced while standing on top of
                        \ the Sentinel's tower, so they have just completed this
                        \ landscape

 LDA #%11000000         \ Set bit 7 of hyperspaceEndsGame to indicate that the
 STA hyperspaceEndsGame \ game has ended with a hyperspace, and set bit 6 to
                        \ indicate that the game has ended because the player
                        \ has won by hyperspacing from the Sentinel's tower

 LDA #%10000000         \ Set bit 7 of doNotPlayLandscape so that when we finish
 STA doNotPlayLandscape \ the landscape, the landscape generation process will
                        \ return normally, without previewing the landscape
                        \
                        \ As the last step in winning a game is to hyperspace
                        \ onto the Sentinel's tower, this ensures that winning a
                        \ level will then display that landscape's secret code
                        \ rather than displaying the preview and making us play
                        \ it again

.hypr2

 JSR FocusOnKeyAction   \ Tell the game to start focusing effort on the key
                        \ action that has been initiated (i.e. the hyperspace)

 LDX currentObject      \ Set the player's object number to that of the new
 STX playerObject       \ robot that we spawned above, so this effectively
                        \ performs the hyperspace into the new robot

.hypr3

 LDA #%10000000         \ Set bit 7 of playerHasMovedTile to indicate that the
 STA playerHasMovedTile \ player has moved to a new tile

 CLC                    \ Clear the C flag to indicate that we have successfully
                        \ hyperspaced the player

.hypr4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawObjectStack
\       Type: Subroutine
\   Category: Drawing objects
\    Summary: Draw an entire stack of objects
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The tile data for the tile containing the stack
\
\ ******************************************************************************

.DrawObjectStack

 AND #%00111111         \ Because the tile has an object on it, the tile data
 STA topObjectOnStack   \ contains the number of the top object on the tile in
                        \ bits 0 to 5, so extract the object number into
                        \ topObjectOnStack

 LDX #0                 \ We now count the number of objects that are stacked on
                        \ the tile, so initialise a counter in X

.stak1

 INX                    \ Increment the object counter in X to record that we
                        \ have found an object in the stack

 AND #%00111111         \ Because the tile has an object on it, the tile data
 TAY                    \ contains the number of the top object on the tile in
                        \ bits 0 to 5, so extract the object number into Y (so
                        \ the tile effectively contains object #Y)

 LDA objectFlags,Y      \ Set A to the object flags for the object on the tile

 CMP #%01000000         \ If bit 6 of the object flags for object #Y is set
 BCS stak1              \ then object #Y is stacked on top of another object,
                        \ and that object number is in bits 0 to 5 of the object
                        \ flags, so jump to stak1 to increase the object count,
                        \ extract that object number from A and check the flags
                        \ again (so this works down through the stack of objects
                        \ until we reach the object at the bottom of the stack)

 DEX                    \ Set objectStackCounter = X - 1 so we can use it as a
 STX objectStackCounter \ counter as we work through all the objects in the
                        \ stack

 BEQ stak7              \ If there is only one object on the tile then the stack
                        \ size will be zero, so jump to stak7 to draw the object
                        \ stack from object #Y down (which in this case will
                        \ just draw object #Y)

                        \ If we get here then there is more than one object in
                        \ the stack, so we now work out in which direction to
                        \ draw the stack: top to bottom or bottom to top
                        \
                        \ If the player is at a lower altitude than the object
                        \ at the bottom of the stack, then the whole stack is
                        \ above the player and the object on the top of the
                        \ stack is the furthest away, so we need to draw the
                        \ stack from top to bottom
                        \
                        \ If it's the other way around and the player is at the
                        \ same or higher altitude than the bottom of the stack,
                        \ then we need to draw the stack from bottom to top, as
                        \ the bottom object is the furthest away
                        \
                        \ There is one exception: if the object stack is the
                        \ Sentinel's tower and we are at the exact same height
                        \ as the tower, then we draw the stack from top to
                        \ bottom to ensure the Sentinel's feet are correctly
                        \ hidden by the platform
                        \
                        \ At this point, object #Y is the bottom object in the
                        \ stack and object #topObjectOnStack is the top object

.stak2

 LDX playerObject       \ Set X to the object number of the player

 LDA yObjectLo,X        \ Set (A T) to the vertical distance between the player
 SEC                    \ and the object we are drawing, as follows:
 SBC yObjectLo,Y        \
 STA T                  \   (A T) = yObject,X - yObject,Y
                        \
                        \ starting with the low bytes

 LDA yObjectHi,X        \ And then the high bytes
 SBC yObjectHi,Y
 
 BMI stak6              \ If the result is negative then the player (object #X)
                        \ is at a lower altitude than the object we are drawing
                        \ (object #Y), so jump to stak6 to draw the entire
                        \ object stack from top to bottom, starting with the top
                        \ object and working down to the bottom

                        \ If we get here then the player is level with or higher
                        \ than the object we are drawing (object #Y)

 ORA T                  \ If at least one of A and T is non-zero then (A T) > 0,
 BNE stak3              \ then the player is at a higher altitude than the
                        \ object we are drawing, so jump to stak3 to skip the
                        \ following check

                        \ If we get here then the player is level with the
                        \ object we are drawing, so we need to check whether
                        \ we are thinking of drawing the Sentinel's tower,
                        \ because if we are, we need to draw the Sentinel before
                        \ the tower to ensure the Sentinel's feet are correctly
                        \ hidden by the platform

 LDA objectTypes,Y      \ If the object we are drawing is the Sentinel's tower
 CMP #6                 \ (an object of type 6), then jump to stak6 to draw the
 BEQ stak6              \ entire object stack from top to bottom, starting with
                        \ the top object (the Sentinel) and working down to the
                        \ bottom object (the tower)

.stak3

                        \ If we get here then the player is higher than the
                        \ object we are drawing (object #Y), so we need to draw
                        \ the object stack upwards, from the bottom to the top
                        \
                        \ This process is a bit convoluted, as the object flags
                        \ only store object numbers that are below other objects
                        \ rather than above, so we have to repeatedly count down
                        \ the stack to work out which object to draw next
                        \
                        \ The first time we enter this loop, object #Y is the
                        \ object at the bottom of the stack, so this loop draws
                        \ the stack from the very bottom to the top
                        \
                        \ The second time we enter this loop, object #Y is the
                        \ object above the original object #Y, so it's the next
                        \ object up
                        \
                        \ We loop around until we have drawn the whole stack
                        \ from bottom to top
                        \
                        \ This loop therefore draws object #Y and then works out
                        \ which object is above object #Y in the stack and loops
                        \ back to repeat the process, until we reach the top of
                        \ the stack

 JSR DrawObject         \ Draw object #Y onto the screen or into the screen
                        \ buffer

                        \ We now work out which object is above object #Y, which
                        \ we do by counting down the stack by the right amount,
                        \ from the top object down
                        \
                        \ This count is stored in objectStackCounter, which
                        \ contains the number of objectx we still have to draw,
                        \ which is the same as the number of objects above
                        \ object #Y

 LDY topObjectOnStack   \ Set Y to the number of the object on top of the stack,
                        \ so we can start counting down from the top

 DEC objectStackCounter \ Decrement the object stack counter as we have just
                        \ drawn object #Y

 BMI stak8              \ If we have drawn all the objects in the stack then the
                        \ counter will now be negative, so jump to stak8 to
                        \ return from the subroutine as we have drawn the whole
                        \ stack

 LDX objectStackCounter \ Otherwise set X to the updated object stack counter,
                        \ which is the number of objects above the object that
                        \ we jusr drew

 BPL stak5              \ Jump to stak5 to start counting down the stack for X
                        \ objects from the top, to give us the object that's
                        \ above object #Y in the stack (this BPL is effectively
                        \ a JMP as we know objectStackCounter is positive, so X
                        \ must also be positive)

.stak4

                        \ If we get here then we need to move down the object
                        \ stack by one place from object #Y, updating Y to the
                        \ number of the next object down

 LDA objectFlags,Y      \ Set A to the object flags for object #Y

 AND #%00111111         \ Object #Y is stacked on top of another object, so the
 TAY                    \ number of the object below is in bits 0 to 5 of the
                        \ object flags, so extract the next object number down
                        \ the stack into Y

 DEX                    \ Decrement the counter in X as we have just moved down
                        \ the stack by one place

.stak5

                        \ This is the entry point for the loop that counts X
                        \ objects down the stack, from the top object down

 BNE stak4              \ If X <> 0 then loop back to stak4 to move down the
                        \ stack

 BEQ stak2              \ Otherwise jump to stak2 to draw object #Y, as that is
                        \ the next object down the stack from the object we just
                        \ drew (this BEQ is effectively a JMP as we just passed
                        \ through a BNE)

.stak6

 LDY topObjectOnStack   \ Set Y = topObjectOnStack so the following loop draws
                        \ the entire object stack from top to bottom, starting
                        \ with the top object and working down to the bottom

.stak7

                        \ This loop draws all the objects in the stack in turn,
                        \ from object #Y at the top, all the way down to the
                        \ object at the bottom of the stack

 JSR DrawObject         \ Draw object #Y onto the screen or into the screen
                        \ buffer

 LDA objectFlags,Y      \ Set A to the object flags for the object we just drew

 AND #%00111111         \ If object #Y is stacked on top of another object, then
 TAY                    \ the number of the object below is in bits 0 to 5 of
                        \ the object flags, so extract the next object number
                        \ down the stack into Y, so we can draw that object next

 DEC objectStackCounter \ Decrement the object stack counter as we have just
                        \ drawn an object

 BPL stak7              \ Loop back until we have drawn all the objects in the
                        \ stack, from object #Y down to the bottom of the stack

.stak8

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FillScreen
\       Type: Subroutine
\   Category: Graphics
\    Summary: Fill a rectangular in screen memory or the screen buffer with the
\             specified background
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Determines whether we fill screen memory or the screen
\                       buffer:
\
\                         * 0 = fill the screen
\
\                         * 25 = fill the screen buffer
\
\   X                   The number of character columns to fill
\
\   Y                   The number of character rows to fill
\
\   screenBackground    The type of background to fill the rectangle with:
\
\                         * 0 = fill with alternating colour 0/1 (blue/black)
\                               pixel rows, for the sky during gameplay
\
\                         * 1 = fill with solid colour 0 (blue)
\
\                         * 2 = fill with dithered pixels in colour 0 (blue)
\                               and colour 3 (e.g. green in landscape 0000)
\                               by alternating colour 3/0/3/0 and 0/3/0/3
\                               pixel bytes
\
\                         * 3 = fill with solid colour 1 (black)
\
\ ******************************************************************************

.FillScreen

 STA fillRowNumber      \ Set fillRowNumber = A, so we start filling from this
                        \ character row number
                        \
                        \ When we are filling the screen buffer, this value is
                        \ 25 + the row number, so we can use this value as a
                        \ lookup into the screenRowAddrLo and screenRowAddrHi
                        \ tables, and it will return the corresponding address
                        \ from the bufferRowAddrLo or bufferRowAddrHi table, to
                        \ give us the row address in the screen buffer

 STY screenRowCounter   \ Set screenRowCounter = Y, so we will fill this many
                        \ character rows

 TXA                    \ If X < 32 then each character row in the fill will fit
 CMP #32                \ into 256 bytes (as each character block is eight bytes
 BCC fill1              \ and 32 * 8 = 256), so jump to fill1 to set bit 7 of
                        \ moreColumnsToFill to record this fact

                        \ If we get here then each character row in the fill
                        \ needs more than 256 bytes, so we set A to the number
                        \ of columns that we need to fill beyond the 256-byte
                        \ limit, which we get by subtracting 32 from the total
                        \ number of columns we need to fill

 SBC #32                \ Set A = X - 32 to store in moreColumnsToFill below
                        \ (this subtraction works as we just passed through a
                        \ BCC instruction, so we know the C flag is set)

 LDX #32                \ Set X = 32 to set as the value of columnCounter below,
                        \ so we fill 32 columns in the first iteration around
                        \ the fill loop, and then fill moreColumnsToFill columns
                        \ in the second iteration

 BNE fill2              \ Jump to fill2 to skip the following instruction (this
                        \ BNE is effectively a JMP as X is never zero)

.fill1

 LDA #%10000000         \ Set bit 7 of moreColumnsToFill in the next instruction
                        \ to indicate that this fill does not require more than
                        \ 32 columns

.fill2

 STA moreColumnsToFill  \ Set moreColumnsToFill to the value of A that we set
                        \ above

 STX columnCounter      \ Set columnCounter to the updated value of X, so this
                        \ contains the number of columns to fill in the first
                        \ iteration around the fill loop (i.e. the total number
                        \ of columns if it's less than 32, or 32 if we need to
                        \ do the fill in two stages)

 LDX screenBackground   \ Set T to the backgroundEven pixel byte for the screen
 LDA backgroundEven,X   \ background type in screenBackground, to give us the
 STA T                  \ pixel byte we should be clearing the screen to for
                        \ even pixel rows

 LDA backgroundOdd,X    \ Set U to the backgroundOdd pixel byte for the screen
 STA U                  \ background type in screenBackground, to give us the
                        \ pixel byte we should be clearing the screen to for odd
                        \ pixel rows

.fill3

 LDX fillRowNumber      \ Set (Q P) to the entry from the screenRowAddrLo and
 LDA screenRowAddrLo,X  \ screenRowAddrHi tables for the character row whose
 STA P                  \ number is in fillRowNumber
 LDA screenRowAddrHi,X  \
 STA Q                  \ When we are filling the screen buffer, fillRowNumber
                        \ is 25 + the row number, so we can use this value as a
                        \ lookup into the screenRowAddrLo and screenRowAddrHi
                        \ tables, and it will return the corresponding address
                        \ from the bufferRowAddrLo or bufferRowAddrHi table, to
                        \ give us the row address in the screen buffer

 LDX columnCounter      \ Set X to the number of columns that we need to fill

 LDA #1                 \ Set loopCounter = 1 so we only do a maximum of two
 STA loopCounter        \ fill stages, to prevent an incorrectly configured fill
                        \ from filling up more than 64 columns

                        \ We now fill X character blocks from screen address
                        \ (Q P) onwards, alternating each pixel row between the
                        \ pixel bytes in T and U

.fill4

 LDY #&FF               \ Set Y = &FF so we increment Y to zero at the start of
                        \ the following loop, so we can use it as an index into
                        \ the block of screen memory starting at (P Q)

.fill5

 INY                    \ Increment the index in Y to point to the first byte
                        \ in the character block

 LDA T                  \ Set the first byte in the character block to T
 STA (P),Y

 INY                    \ Increment the index in Y to point to the second byte
                        \ in the character block

 LDA U                  \ Set the second byte in the character block to U
 STA (P),Y

 INY                    \ Increment the index in Y to point to the third byte
                        \ in the character block

 LDA T                  \ Set the third byte in the character block to T
 STA (P),Y

 INY                    \ Increment the index in Y to point to the fourth byte
                        \ in the character block

 LDA U                  \ Set the fourth byte in the character block to U
 STA (P),Y

 INY                    \ Increment the index in Y to point to the fifth byte
                        \ in the character block

 LDA T                  \ Set the fifth byte in the character block to T
 STA (P),Y

 INY                    \ Increment the index in Y to point to the sixth byte
                        \ in the character block

 LDA U                  \ Set the sixth byte in the character block to U
 STA (P),Y

 INY                    \ Increment the index in Y to point to the seventh byte
                        \ in the character block

 LDA T                  \ Set the seventh byte in the character block to T
 STA (P),Y

 INY                    \ Increment the index in Y to point to the eighth byte
                        \ in the character block

 LDA U                  \ Set the eighth byte in the character block to U
 STA (P),Y

 DEX                    \ Decrement the column counter in X

 BNE fill5              \ Loop back until we have filled X character blocks

 DEC loopCounter        \ Decrement the loop counter

 BMI fill6              \ If we have already run two fill loops, jump to fill6
                        \ to move on to the next row, so we never do more than
                        \ two fill stages

 LDX moreColumnsToFill  \ Set X to the value of moreColumnsToFill, which either
                        \ has bit 7 set, or contains the number of columns we
                        \ still need to fill on top of the 32 we just filled

 BMI fill6              \ If bit 7 of moreColumnsToFill is set then each row in
                        \ the fill fits into 256 bytes, so we will have already
                        \ filled in the required bytes and can jump to fill6 to
                        \ move on to the next row

 INC Q                  \ Increment the high byte of (Q P) to point to the next
                        \ page in memory

 JMP fill4              \ Loop back to fill4 to continue filling along the
                        \ character row, filling the number of columns in X to
                        \ take us to the correct total number for the row

.fill6

 INC fillRowNumber      \ Increment the row number to move down to the next
                        \ character row

 DEC screenRowCounter   \ Decrement the row counter

 BNE fill3              \ Loop back to fill the next character row until we have
                        \ filled the number of rows in screenRowCounter

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: backgroundEven
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel bytes for even pixel rows in the screen background
\
\ ******************************************************************************

.backgroundEven

 EQUB %00000000         \ Background 0 = colour 0 (even)
                        \                colour 1 (odd)

 EQUB %00000000         \ Background 1 = colour 0 (even)
                        \                colour 0 (odd)

 EQUB %10101010         \ Background 2 = colour 3/0/3/0 (even)
                        \                colour 0/3/0/3 (odd)

 EQUB %00001111         \ Background 3 = colour 1 (even)
                        \                colour 1 (odd)

\ ******************************************************************************
\
\       Name: backgroundOdd
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel bytes for odd pixel rows in the screen background
\
\ ******************************************************************************

.backgroundOdd

 EQUB %00001111         \ Background 0 = colour 0 (even)
                        \                colour 1 (odd)

 EQUB %00000000         \ Background 1 = colour 0 (even)
                        \                colour 0 (odd)

 EQUB %01010101         \ Background 2 = colour 3/0/3/0 (even)
                        \                colour 0/3/0/3 (odd)

 EQUB %00001111         \ Background 3 = colour 1 (even)
                        \                colour 1 (odd)

\ ******************************************************************************
\
\       Name: pixelBitMask
\       Type: Variable
\   Category: Graphics
\    Summary: A table for converting a pixel number in the range 0 to 3 into a
\             screen mode 5 bit mask with that pixel's bits set and others clear
\
\ ******************************************************************************

.pixelBitMask

 EQUB %10001000         \ Pixel bit mask with pixel 0 set

 EQUB %01000100         \ Pixel bit mask with pixel 1 set

 EQUB %00100010         \ Pixel bit mask with pixel 2 set

 EQUB %00010001         \ Pixel bit mask with pixel 3 set

\ ******************************************************************************
\
\       Name: colourPixels
\       Type: Variable
\   Category: Graphics
\    Summary: A table that maps logical colours 0 to 3 to a four-pixel byte in
\             that colour
\
\ ******************************************************************************

.colourPixels

 EQUB %00000000         \ Four pixels of colour 0
 EQUB %00001111         \ Four pixels of colour 1
 EQUB %11110000         \ Four pixels of colour 2
 EQUB %11111111         \ Four pixels of colour 3

\ ******************************************************************************
\
\       Name: pixelsToLeft
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel byte with all the pixels to the left of position X set
\
\ ******************************************************************************

.pixelsToLeft

 EQUB %00000000
 EQUB %10001000
 EQUB %11001100
 EQUB %11101110

\ ******************************************************************************
\
\       Name: pixelsToRight
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel byte with all the pixels to the right of position X set
\
\ ******************************************************************************

.pixelsToRight

 EQUB %01110111
 EQUB %00110011
 EQUB %00010001
 EQUB %00000000

\ ******************************************************************************
\
\       Name: leftPixels
\       Type: Variable
\   Category: Graphics
\    Summary: Pixel byte with all the pixels to the right of position X + 1 set,
\             to give the complementary pixel byte to pixelsToRight
\
\ ******************************************************************************

.leftPixels

 EQUB %10001000
 EQUB %11001100
 EQUB %11101110
 EQUB %11111111

\ ******************************************************************************
\
\       Name: L2293Lo
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L2293Lo

 EQUB LO(&0000)
 EQUB LO(&0060)
 EQUB LO(&0000)

\ ******************************************************************************
\
\       Name: L2293Hi
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L2293Hi

 EQUB HI(&0000)
 EQUB HI(&0060)
 EQUB HI(&0000)

\ ******************************************************************************
\
\       Name: sub_C2299
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C2299

 LDA #&01
 STA L002C
 STA L002D
 LDA tileAltitude
 CLC
 ADC L0004
 ROR A
 TAX
 LDA L5B00,X
 CMP L5A00,X
 BCC CRE13
 LDA #&F0
 CLC
 SBC tileAltitude
 STA T
 LSR A
 LSR A
 LSR A

 CLC                    \ If we are configured to draw into the screen buffer
 ADC screenOrBuffer     \ then screenOrBuffer will be 25, so this makes us fetch
                        \ row addresses from bufferRowAddrLo and bufferRowAddrHi
                        \ (as bufferRowAddrLo - screenRowAddrLo is 25)
                        \
                        \ Otherwise vwe are configured to draw directly onto the
                        \ screen and screenOrBuffer is zero, in which case this
                        \ addition doesn't change anything

 TAX
 LDA T
 AND #&07
 CLC
 ADC screenRowAddrLo,X
 STA R
 LDA screenRowAddrHi,X
 STA S
 LDY screenBufferType
 LDA R
 CLC
 ADC L2293Lo,Y          \ Adds &60 when Y = 1
 STA R
 LDA S
 ADC L2293Hi,Y          \ Adds &60 when Y = 1
 STA S

 LDA polygonColours

 BIT blendPolygonEdges  \ If bit 7 of blendPolygonEdges is clear then polygon
 BPL C22EF              \ edges should be drawn in the edge colour, so jump to
                        \ C22EF to skip the following

                        \ If we get here then bit 7 of blendPolygonEdges is set,
                        \ so we draw the polygon edges in the same colour as the
                        \ polygon body (i.e. the fill colour), so the edges
                        \ blend into the body
                        \
                        \ We typically do this for distant objects, as distinct
                        \ edge colours can make those object look messy

 AND #%11001111         \ Copy the fill colour from bits 2-3 of the polygon
 STA T                  \ colour byte into to the edge colour in bits 4-5, so
 LDA polygonColours     \ the polygon edge colour merges into the polygon body
 ASL A
 ASL A
 AND #%00110000
 ORA T

.C22EF

 STA L23C7
 STA L2367
 ORA #&40
 STA L23A2
 LSR A
 LSR A
 AND #&03
 TAY
 LDA colourPixels,Y
 STA L0058
 LDY tileAltitude
 STY L001A
 CPY L0004
 BCS C237F

.CRE13

 RTS

\ ******************************************************************************
\
\       Name: sub_C230D
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C230D

 LDY L001A
 CPY L0004
 BEQ CRE13
 TYA
 AND #&07
 BNE C237A
 LDA R
 CLC
 ADC #&39
 STA R
 LDA S
 ADC #&01
 CMP #&53
 BNE C232F
 LDA bufferRowAddrLo+16
 STA R
 LDA bufferRowAddrHi+16

.C232F

 STA S
 BNE C237C

.C2333

 LDA #0
 STA L002D
 BEQ sub_C230D

.C2339

 LDA #0
 STA L002C
 BEQ sub_C230D

.C233F

 LDA L0061
 ASL A
 STA L0056
 STA L002C
 BNE C23A6

.C2348

 LDA R
 SEC
 SBC #&08
 STA P
 LDA S
 SBC #&00
 STA Q
 LDA #0
 STA L002D
 LDA #&F8
 BNE C23D8

.C235D

 TXA
 AND #&03
 TAX
 LDA L0054
 AND pixelsToLeft,X

.C2366

L2367 = C2366+1

 ORA L3E3C,X
 AND leftPixels,X
 STA T
 LDA (R),Y
 AND pixelsToRight,X
 ORA T
 STA (R),Y
 JMP sub_C230D

.C237A

 INC R

.C237C

 DEY
 STY L001A

.C237F

 LDA L5B00,Y
 CMP L5A00,Y
 BCC CRE13
 TAX
 SBC L0035
 BCC C2333
 CMP L0061
 BCS C233F
 ASL A
 AND #&F8
 TAY
 TXA
 AND #&03
 TAX
 STY L0056
 LDA (R),Y
 STA L0054
 AND pixelsToRight,X

.C23A1

L23A2 = C23A1+1

 ORA L3E7C,X
 STA (R),Y

.C23A6

 LDY L001A
 LDA L5A00,Y
 TAX
 CMP L0036
 BCS C2339
 SEC
 SBC L0035
 BCC C2348
 ASL A
 AND #&F8
 TAY
 CPY L0056
 BCS C235D
 TXA
 AND #&03
 TAX
 LDA (R),Y
 AND pixelsToLeft,X

.C23C6

L23C7 = C23C6+1

 ORA L3E3C,X
 STA (R),Y
 TYA
 CLC
 ADC R
 STA P
 LDA S
 ADC #&00
 STA Q
 TYA

.C23D8

 SEC
 SBC L0056
 LSR A
 STA L23E3
 LDA L0058
 CLC

.C23E2

L23E3 = C23E2+1

 BCC C2460

 LDY #&F8
 STA (P),Y
 LDY #&F0
 STA (P),Y
 LDY #&E8
 STA (P),Y
 LDY #&E0
 STA (P),Y
 LDY #&D8
 STA (P),Y
 LDY #&D0
 STA (P),Y
 LDY #&C8
 STA (P),Y
 LDY #&C0
 STA (P),Y
 LDY #&B8
 STA (P),Y
 LDY #&B0
 STA (P),Y
 LDY #&A8
 STA (P),Y
 LDY #&A0
 STA (P),Y
 LDY #&98
 STA (P),Y
 LDY #&90
 STA (P),Y
 LDY #&88
 STA (P),Y
 LDY #&80
 STA (P),Y
 LDY #&78
 STA (P),Y
 LDY #&70
 STA (P),Y
 LDY #&68
 STA (P),Y
 LDY #&60
 STA (P),Y
 LDY #&58
 STA (P),Y
 LDY #&50
 STA (P),Y
 LDY #&48
 STA (P),Y
 LDY #&40
 STA (P),Y
 LDY #&38
 STA (P),Y
 LDY #&30
 STA (P),Y
 LDY #&28
 STA (P),Y
 LDY #&20
 STA (P),Y
 LDY #&18
 STA (P),Y
 LDY #&10
 STA (P),Y
 LDY #&08
 STA (P),Y

.C2460

 JMP sub_C230D

\ ******************************************************************************
\
\       Name: GetTileVisibility
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: For each tile in the landscape, calculate whether the player can
\             see that tile, to speed up the process of drawing the landscape
\
\ ------------------------------------------------------------------------------
\
\ This routine sets a single bit in the tileVisibility table that records the
\ visibility of that tile from the player's perspective (where 1 = visible,
\ 0 = hidden).
\
\ The position of the bit within the tileVisibility table is calculated in a
\ rather complicated manner, resumably to make it harder to follow what's going
\ on.
\
\ ******************************************************************************

.GetTileVisibility

 LDA hyperspaceEndsGame \ If bit 7 of hyperspaceEndsGame is set then the game
 BMI tvis5              \ has ended because of a hyperspace, so jump to tvis5
                        \ to return from the subroutine
                        \
                        \ This check appears to be unnecessary, as we only call
                        \ GetTileVisibility from game2 in MainGameLoop, and we
                        \ only reach game2 when bit 7 of hyperspaceEndsGame is
                        \ clear, so this BMI will never be taken

 LDA #0                 \ Set A = 0 to use when we zero the tileVisibility table

 STA drawingTableOffset \ Set drawingTableOffset = 0 so the call to first call
                        \ to GetRowVisibility (for tile row 31) will populate
                        \ the table at oddVisibility with the tile visibilities
                        \ of the row being analysed

 LDX #127               \ We now zero the tileVisibility table, so set a counter
                        \ in X for zeroing 128 bytes

.tvis1

 STA tileVisibility,X   \ Zero the X-th byte of the tileVisibility table to
                        \ indicate hidden tiles

 DEX                    \ Decrement the byte counter

 BPL tvis1              \ Loop back until we have zeroed both variables

 JSR GetTileAltitudes   \ Calculate tile corner altitudes and maximum tile
                        \ corner altitudes for each tile in the landscape
                        \
                        \ This also sets the following:
                        \
                        \   * (Q P) = &6000
                        \
                        \   * (S R) = &6020
                        \
                        \ So we have P = 0 and R = &20, ready to pass to the
                        \ GetRowVisibility routine (which expects these values)

 LDA #31                \ Set zTileRow = 31 so the call to GetRowVisibility
 STA zTileRow           \ analyses the back row of tiles

 JSR GetRowVisibility   \ Calculate whether each tile corner in the rearmost row
                        \ is obscured from the player by any intervening
                        \ landscape, putting the results into 32 entries in the
                        \ table at oddVisibility (as drawingTableOffset = 0) as
                        \ follows:
                        \
                        \   * %00000000 if the tile corner is not visible from
                        \     the player's position
                        \
                        \   * %11111111 if the tile corner is visible from the
                        \     player's position

 DEC zTileRow           \ Decrement zTileRow to move forward by one tile row

.tvis2

 LDA drawingTableOffset \ Flip drawingTableOffset between 0 and 32, so each
 EOR #32                \ call to GetRowVisibility alternates between storing
 STA drawingTableOffset \ the tile visibilities in oddVisibility and
                        \ evenVisibility
                        \
                        \ We EOR with 32 because:
                        \
                        \   evenVisibility - oddVisibility = 32
                        \
                        \ So we can add the result in drawingTableOffset to
                        \ oddVisibility to point to the correct table for
                        \ storing the results

 JSR GetRowVisibility   \ Calculate whether each tile corner in the row at
                        \ zTileRow is obscured from the player by any
                        \ intervening landscape, putting the results into 32
                        \ entries in the table at either oddVisibility or
                        \ evenVisibility (depending on the parity of zTileRow)
                        \ as follows:
                        \
                        \   * %00000000 if the tile corner is not visible from
                        \     the player's position
                        \
                        \   * %11111111 if the tile corner is visible from the
                        \     player's position
                        \
                        \ So the current row is in either oddVisibility or
                        \ evenVisibility and the previous row is in the other
                        \
                        \ The call also sets (Q P) to the address of the table
                        \ that contains the altitude and flatness data for tile
                        \ corner row zTileRow, as follows:
                        \
                        \   (Q P) = &6000 + (zTileRow 0)
                        \
                        \ Each value in the table at (Q P) contains the flatness
                        \ of the tile in bit 0 and the altitude of the tile
                        \ corner in bits 1-4

 LDX playerObject       \ Set V to the high byte of the y-coordinate of the
 LDA yObjectHi,X        \ player object
 STA V

 LDX #30                \ Set X = 30 to use as the column number, so we start
                        \ iterating from the right, skipping the rightmost
                        \ column as the tile corners in that column do not
                        \ anchor any tiles (so X iterates from 30 to 0 in the
                        \ following loop)

.tvis3

 TXA                    \ Set A to the X-th entry from (Q P), which contains the
 TAY                    \ altitude and flatness of the X-th tile in the row at
 LDA (P),Y              \ zTileRow

 LDY #%11111111         \ Set Y to a bit mask containing all set bits, to use
                        \ for flagging tiles as being visible in the calculation
                        \ below

 LSR A                  \ Shift bit 0 into the C flag, so it contains the shape,
                        \ and set A as the altitude of the tile

 BCS tvis4              \ If the tile is not flat then the C flag will be set,
                        \ so jump to tvis4 with Y set to the bit mask for
                        \ visible tiles

 CMP V                  \ If A <= V then the tile is at the same altitude or
 BCC tvis4              \ lower than the high byte of the player object's
 BEQ tvis4              \ altitude (which is the player's altitude rounded down
                        \ to the nearest integer), so jump to tvis4 with Y set
                        \ to the bit mask for visible tiles

                        \ If we get here then the tile is flat and it is at a
                        \ higher altitude than the player object, so

 INY                    \ Increment Y to zero to get a bit mask containing all
                        \ clear bits, to use for flagging tiles as not being
                        \ visible in the calculation below

.tvis4

 STY W                  \ Store the bit mask we just calculated in W

                        \ We now store this tile's visibility as a single bit in
                        \ in the tileVisibility table
                        \
                        \ First we need to calculate the location of this tile's
                        \ bit in the table, which we do by encoding the tile
                        \ column number in X and row number in zTileRow into an
                        \ offset into the table (in T) and a bit mask lookup
                        \ (in Y)
                        \
                        \ Presumably this calculation is complex to make it
                        \ harder for people to work out what's going on (at
                        \ least, I can't figure out why it's done this way)

 TXA                    \ X is the column number of the tile we are analysing,
 ASL A                  \ in the range 0 to 30 (%00000 to %11110), so shift that
 ASL A                  \ number into the top five bits of A and clear the last
 ASL A                  \ two bits, so that bits 5-7 contain bits 2-4 of the
 AND #%11100000         \ column number

 ORA zTileRow           \ zTileRow is the row number of the tile we are
 LSR A                  \ analysing, again in the range 0 to 30 (%00000 to
                        \ %11110), so put this into bits 0 to 4 of A and shift
                        \ the whole thing to the right, so we lose bit 0 of the
                        \ row number into the C flag (which we capture below)
                        \ and bits 0 to 3 contain bits 1 to 4 of zTileRow

 STA T                  \ Set T to the value of A, so we now have the following
                        \ in T:
                        \
                        \   * Bit 7 is clear
                        \
                        \   * Bits 4-6 contain bits 2-4 of the column number
                        \
                        \   * Bits 0-3 contain bits 1-4 of the row number
                        \
                        \ We have now encoded the tile number in T, which we can
                        \ use as an index into the tileVisibility table when
                        \ storing the tile's visibility

 TXA                    \ Set bits 0 to 2 of Y as follows:
 AND #%00000011         \
 ROL A                  \    * Bit 0 contains bit 0 of the of the tile row (via
 TAY                    \      the C flag from above)
                        \
                        \    * Bits 1-2 contain bits 0-1 of the column number

 LDA visibileBitMask,Y  \ Set bitMask to a byte with all bits set except the
 EOR #%11111111         \ Y-th bit, counting from the left (so when Y is 0, bit
 STA bitMask            \ 7 is clear, when Y is 1, bit 6 is clear and so on)

 LDA oddVisibility,X    \ Set A to the combined visibility of the four tile
 ORA oddVisibility+1,X  \ corners for the tile we are analysing, by OR'ing the
 ORA evenVisibility,X   \ visibility bytes that we set for the four corners in
 ORA evenVisibility+1,X \ the call to GetRowVisibility:
                        \
                        \   * oddVisibility+X contains the visibility for the
                        \     tile's anchor (i.e. the X-th corner)
                        \
                        \   * oddVisibility+X+1 contains the visibility for the
                        \     corner to the right of the tile's anchor
                        \
                        \   * evenVisibility+X contains the visibility for the
                        \     corner behind the tile's anchor (i.e. the corner
                        \     on the same x-coordinate but from the previous
                        \     row's analysis)
                        \
                        \   * evenVisibility+X+1 contains the visibility for the
                        \     corner just to the right of the last one
                        \
                        \ The GetRowVisibility routine sets visibility in the
                        \ oddVisibility and evenVisibility tables as follows:
                        \
                        \   * %00000000 if the tile corner is not visible
                        \
                        \   * %11111111 if the tile corner is visible
                        \
                        \ So OR'ing the four tile corners will give %11111111 if
                        \ any of the tile corners are visible, and %00000000 if
                        \ none of them are visible

 AND W                  \ Apply the W bit mask from above, which we set to
                        \ %0000000 for tiles that are flat and above the level
                        \ of the player, and %11111111 otherwise
                        \
                        \ So this forces A to 0 (to indicate a hidden tile) for
                        \ tiles that are flat and too high to be seen by the
                        \ player, and leaves A alone for other tiles

 AND visibileBitMask,Y  \ At this point A is either %00000000 for a hidden tile
                        \ or %11111111 for a visible tile, so AND'ing it with
                        \ the Y-th entry in visibileBitMask (which is a bit mask
                        \ with all bits set except the Y-th bit, counting from
                        \ the left) will clear all bits except the Y-th bit,
                        \ which will be 0 for non-visible tiles and 1 for
                        \ visible tiles

 STA U                  \ Store A in U, so U contains all clear bits apart from
                        \ the Y-th bit, which contains the visibility of the
                        \ tile we are processing

 LDY T                  \ Set A to the T-th byte in the tileVisibility table,
 LDA tileVisibility,Y   \ which is where we want to store our visibility bit for
                        \ the tile we are processing

 AND bitMask            \ We set bitMask above to a byte with all bits set
                        \ except the Y-th bit, counting from the left, which
                        \ matches the bit that we used in U to store the tile's
                        \ visibility bit, so this AND clears that bit in the
                        \ byte we just fetched from the tileVisibility table

 ORA U                  \ U contains all clear bits apart from the Y-th bit,
                        \ which contains the visibility of the tile we are
                        \ processing, so this inserts that bit into the byte
                        \ we just fetched from the tileVisibility table

 STA tileVisibility,Y   \ Store the updated byte in the tileVisibility table so
                        \ it contains the visibility bit for the tile in column
                        \ X on row zTileRow

 DEX                    \ Decrement the column number to move left to the next
                        \ tile in the row

 BPL tvis3              \ Loop back until we have processed all the tiles in the
                        \ row

 DEC zTileRow           \ Decrement zTileRow to move forward by one tile row

 BPL tvis2              \ Loop back until we have processed all the tile rows in
                        \ the landscape

.tvis5

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: visibileBitMask
\       Type: Variable
\   Category: Drawing the landscape
\    Summary: A table for converting a number in the range 0 to 7 into a bit
\             mask with only that bit set, when counting from the left
\
\ ******************************************************************************

.visibileBitMask

 EQUB %10000000
 EQUB %01000000
 EQUB %00100000
 EQUB %00010000
 EQUB %00001000
 EQUB %00000100
 EQUB %00000010
 EQUB %00000001

\ ******************************************************************************
\
\       Name: GetRowVisibility (Part 1 of 2)
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Set up the calculations to determine whether each tile corner in a
\             tile row is obscured from the player by any intervening landscape
\
\ ------------------------------------------------------------------------------
\
\ This routine populates a specified table with the vibility of each tile corner
\ in a row, populating the table with 32 entries as follows:
\
\   * %00000000 if the tile corner is not visible from the player's position
\
\   * %11111111 if the tile corner is visible from the player's position
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   zTileRow            The tile z-coordinate of the tile row to analyse
\
\   drawingTableOffset  Defines where we store the results of the analysis:
\
\                         * oddVisibility when drawingTableOffset = 0
\
\                         * evenVisibility when drawingTableOffset = 32
\
\   P                   P is always zero, so (Q P) is of the form &xx00
\
\   R                   R is always &20, so (S R) is of the form &xx20
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   (Q P)               The address of the table that contains the altitude and
\                       shape data for tile row zTileRow, like this:
\
\                         * (Q P) = &6000 + (zTileRow 0)
\
\ ******************************************************************************

.GetRowVisibility

 LDA zTileRow           \ Set the high byte of (Q P) to &60 + zTileRow
 CLC                    \
 ADC #&60               \ This gives us the address where the GetTileAltitudes
 STA Q                  \ routine stored the altitude data for tile row zTileRow
                        \
                        \ This works because we only ever call this routine with
                        \ P = 0, and row zTile = 0 is at &6000, row zTile = 1 is
                        \ at &6100 and so on

 LDA #31                \ Set xTileRow = 31 so we start iterating from the right
 STA xTileRow           \ end of the current row (so xTileRow iterates from 31
                        \ to in the following loop)

                        \ We now loop through each tile corner in the row, from
                        \ right to left, in a loop that's split over part 1 and
                        \ part 2 (and which has an anti-cracker interlude in the
                        \ middle that has nothing to do with visibility checks)

.rvis1

 JSR ProcessSound       \ Process any sounds or music that are being made in the
                        \ background

 LDY #0                 \ Set T = 0, so we can use it to capture the longest
 STY T                  \ axis in the vector calculation below

 DEY                    \ Set traceStepCounter = 255, so we start off by tracing
 STY traceStepCounter   \ 255 steps (as the initial calculation calculates the
                        \ vector to trace by dividing the full vector from the
                        \ player to the tile corner by 256)
                        \
                        \ We may reduce the number of steps below to make the
                        \ process more efficient

 LDY xTileRow           \ Set yTileRow to the altitude of the tile corner we are
 LDA (P),Y              \ analysing
 LSR A                  \
 STA yTileRow           \ The value in the table at (Q P) contains the flatness
                        \ of the tile in bit 0 and the altitude of the tile
                        \ corner in bits 1-4, so we shift this value right by
                        \ one place to extract the altitude

 LDX playerObject       \ Fetch the cartesian coordinates of the player object
 JSR GetObjectCoords    \ as three 24-bit numbers, as follows:
                        \
                        \   (xCoordHi xCoordLo xCoordBot)
                        \
                        \   (yCoordHi yCoordLo yCoordBot)
                        \
                        \   (zCoordHi zCoordLo zCoordBot)

 LDX #2                 \ We now work through all three axes in turn, so set an
                        \ axis counter in X to iterate through 2, 1 and 0 (for
                        \ the z-axis, y-axis and x-axis respectively)
                        \
                        \ The comments in the following loop will concentrate on
                        \ the x-axis to keep things simple

.rvis2

 LDA #0                 \ Zero the high byte of (xVector yVector zVector), which
 STA xVectorHi,X        \ we will use to store the vector from the player to the
                        \ tile corner

 SEC                    \ Set (xVectorLo xVectorBot) = 
 SBC xCoordLo,X         \             ((xTileRow 0) - (xCoordHi xCoordLo)) / 256
 STA xVectorBot,X       \
 LDA xTileRow,X         \ So (xVectorLo xVectorBot) contains the distance in the
 SBC xCoordHi,X         \ x-axis from the player to the tile corner that we are
 STA xVectorLo,X        \ analysing, divided by 256
                        \
                        \ The "divided by 256" part is subtle and important
                        \
                        \ We want to divide the vector from the player to the
                        \ tile corner into small steps, so we can move along the
                        \ vector sequentially, checking on each step whether the
                        \ vector is passing below ground level (in which case we
                        \ will know that the line of sight from the player to
                        \ the tile corner is obstructed by landscape)
                        \
                        \ The above calculation subtracts two high byte/low byte
                        \ 16-bit numbers in (xTileRow 0) and (xCoordHi xCoordLo)
                        \ and puts the result into a low byte/bottom byte 16-bit
                        \ number in (xVectorLo xVectorBot)
                        \
                        \ This is the same as dividing the result of the
                        \ subtraction by 256, which we can see if we consider
                        \ that this would be the normal high/low calculation:
                        \
                        \   (xVectorHi xVectorLo) =   (xTileRow 0)
                        \                           - (xCoordHi xCoordLo)
                        \
                        \ and we also have:
                        \
                        \   (xVectorLo xVectorBot) = (xVectorHi xVectorLo) / 256
                        \
                        \ so we get:
                        \
                        \   (xVectorLo xVectorBot)
                        \           = ((xTileRow 0) - (xCoordHi xCoordLo)) / 256
                        \
                        \ Also, its worth noting that this is the vector from
                        \ the player to the tile corner, because if you add this
                        \ vector to the player's coordinates 256 times, then you
                        \ get the tile corner's coordinates

 BPL rvis3              \ If the result is positive, jump to rvis3, with the low
                        \ byte of the result (xVectorLo) in A

 DEC xVectorHi,X        \ The result is negative, so set xVectorHi to %11111111
                        \ so it can be used as the high byte for the negative
                        \ 24-bit number in (xVectorHi xVectorLo xVectorBot)

 LDA #0                 \ Negate the result as follows (note that we ignore the
 SEC                    \ bottom byte, as we are only interested in the low byte
 SBC xVectorBot,X       \ of the result):
 LDA #0                 \
 SBC xVectorLo,X        \   (A *) = -(xVectorLo xVectorBot)
                        \
                        \ So this makes (A *) positive, to give this:
                        \
                        \   (A *) = |xVectorLo xVectorBot|
                        \
                        \ So the low byte of the result |xVectorLo| is in A

.rvis3

                        \ By this point we have the following:
                        \
                        \   * A = |xVectorLo|
                        \
                        \   * xVectorHi is either 0 or %11111111, depending on
                        \     the sign of (xVectorLo xVectorBot)

 CMP T                  \ If A >= T then set T = A, so T keeps a record of the
 BCC rvis4              \ largest value of |xVectorLo| across all three axes
 STA T                  \
                        \ In other words, once we have finished looping through
                        \ all three axes, T will contain the magnitude of the
                        \ longest axis in the vector:
                        \
                        \   T = max(|xVectorLo|, |yVectorLo|, |zVectorLo|)

.rvis4

 DEX                    \ Decrement the axis counter in X to move on to the next
                        \ axis

 BPL rvis2              \ Loop back until we have processed all three axes

                        \ At this point X is set to 255, which we use below when
                        \ checking the secret entry code in CheckSecretStash

 LDA T                  \ If:
 ASL A                  \
 ASL A                  \   T * 4 < 6
 CMP #6                 \
 BCC rvis10             \ then:
                        \
                        \   T < 1.5
                        \
                        \ and:
                        \
                        \  max(|xVectorLo|, |yVectorLo|, |zVectorLo|) < 1.5
                        \
                        \ In other words, if this is true, then the longest axis
                        \ of the vector from player to the tile corner is less
                        \ than 1.5 (where each tile is of size 1), so the tile
                        \ corner we are analysing is within 1.5 tile widths of
                        \ the player
                        \
                        \ We automatically mark all these close-by tiles as
                        \ being potentially visible, so we jump to rvis10 with
                        \ the C flag clear to store &FF as the visibility result
                        \ (to record that this corner is potentially visible)

                        \ The next step is an optimisation
                        \
                        \ We could trace the vector from the player to the tile
                        \ corner in steps of 256, but given that the landscape
                        \ is only 32 tile corners across in each direction, this
                        \ would mean that most of the time we would be stepping
                        \ along the vector while staying above the same tile
                        \
                        \ Instead we can scale up the size of our steps and do
                        \ fewer of them, and as long as each individual step is
                        \ smaller than a tile width, we can still check every
                        \ landscape tile along the line of sight
                        \
                        \ We therefore double the value in A, which contains the
                        \ longest side of the vector, to be as high as possible
                        \ while still fitting into one byte (which represents a
                        \ fraction of a tile as it's the low byte of the vector)
                        \
                        \ At the same time we double the size of the vector by
                        \ doubling the following:
                        \
                        \   (xVectorHi xVectorLo xVectorBot)
                        \
                        \   (yVectorHi yVectorLo yVectorBot)
                        \
                        \   (zVectorHi zVectorLo zVectorBot)
                        \
                        \ though we don't actually need to shift the high bytes
                        \ as we won't be shifting data out of the low bytes and
                        \ they are either zero or %11111111
                        \
                        \ Because we have doubled the size of the vector, we
                        \ also halve the number of steps in traceStepCounter
                        \
                        \ This reduces the number of steps in the ray-tracing
                        \ process as far as possible while keeping the size of
                        \ each step to less than one tile (so that the tracing
                        \ process still steps through each tile en route)

.rvis5

 ASL xVectorBot         \ Double (xVectorLo xVectorBot) to double the size of
 ROL xVectorLo          \ the vector
 ASL yVectorBot
 ROL yVectorLo
 ASL zVectorBot
 ROL zVectorLo

 LSR traceStepCounter   \ Halve traceStepCounter to halve the number of steps in
                        \ the tracing process

 ASL A                  \ Shift A to the left to shift bit 7 into the C flag, to
                        \ detect when A is as big as it can be within one byte

 BCC rvis5              \ Loop back to repeat the above scalings until we have
                        \ scaled up the vector as much as we can

                        \ So (xVectorHi xVectorLo xVectorBot) now contains the
                        \ vector from the player to the tile corner, divided by
                        \ 256 and scaled up as far as possible while still
                        \ keeping the vector within the dimensions of a tile,
                        \ and traceStepCounter contains the number of times this
                        \ vector fits into the original vector from the player
                        \ to the tile corner
                        \
                        \ We can therefore trace the vector from the player to
                        \ the tile corner by taking the player's coordinates and
                        \ adding the (xVectorHi xVectorLo xVectorBot) vector
                        \ traceStepCounter times, knowing that togther, these
                        \ steps will stop over every tile between the player and
                        \ the tile corner in the process (we may stop over some
                        \ tiles more than once, but that's OK)

 LDA zCoordHi           \ Set zCoordHi = zCoordHi + &60
 CLC                    \
 ADC #&60               \ This sets zCoordHi to the high byte of the address for
 STA zCoordHi           \ the extracted altitude data for the tile row on which
                        \ the player is standing (as zCoordHi is the integer
                        \ part of the player's z-coordinate, which is the number
                        \ of the row containing the player)

                        \ We now have a short interlude to check the secret code
                        \ stash, as part of the game's anti-cracker code, and we
                        \ pick up the tile visibility code in part 2

\ ******************************************************************************
\
\       Name: CheckSecretStash
\       Type: Subroutine
\   Category: Cracker protection
\    Summary: Check whether the secret code stash is correctly set up, as part
\             of the anti-cracker code
\
\ ******************************************************************************

.CheckSecretStash

 LDA doNotCheckSecret   \ If bit 7 of doNotCheckSecret is set then jump down to
 BMI rvis6              \ part 2 of GetRowVisibility to skip checking the secret
                        \ code stash

                        \ The following code does a check on the secret entry
                        \ code for the current landscape to ensure that it
                        \ matches the entered code in the keyboard input buffer
                        \
                        \ If the check fails, then the game restarts by jumping
                        \ to MainTitleLoop to display the title screen
                        \
                        \ Specifically, the following code checks for four bytes
                        \ in the secretCodeStash that correspond to the results
                        \ of the comparisons made in the CheckSecretCode routine
                        \
                        \ This ensures that crackers who manage to bypass the
                        \ CheckSecretCode routine will find that the game
                        \ restarts, unless they also disable this rather well
                        \ hiddden check

 LDA stashOffset-255,X  \ We know that X is 255 from the loop above, so this
                        \ sets A = stashOffset
                        \
                        \ The value of stashOffset is set in the SetSecretStash
                        \ routine during the landscape drawing process, where it
                        \ is set to a value that is unique and consistent for
                        \ each individual landscape

                        \ We now set stashAddr(1 0) to point to the four bytes
                        \ in the secretCodeStash that correspond to the four
                        \ comparisons we made for the secret entry code in the
                        \ CheckSecretCode routine

 CLC                    \ Set stashAddr = A + 41
 ADC #41                \
 STA stashAddr          \ So that's the low byte

 LDX #3                 \ Set X = 3 so we can use it to count four bytes in the
                        \ loop below (as well as in the following calculation)

 TXA                    \ Set stashAddr+1 = HI(secretCodeStash) - 3 + 3
 CLC                    \                 = HI(secretCodeStash)
 ADC #HI(secretCodeStash) - 3
 STA stashAddr+1

                        \ So we now have the following:
                        \
                        \   stashAddr(1 0) = secretCodeStash + stashOffset + 41
                        \
                        \ When the secretCodeStash gets populated in the
                        \ CheckSecretCode routine, we add one byte for each
                        \ iteration and comparison in the secret code generation
                        \ process
                        \
                        \ That process starts by performing 38 iterations and
                        \ storing the results in the secretCodeStash from offset
                        \ stashOffset to stashOffset + 37
                        \
                        \ It then generates the four BCD numbers that make up
                        \ the secret code, storing the results in the stash from
                        \ offset stashOffset + 38 to stashOffset + 41
                        \
                        \ (And it then generates one more result, but we ignore
                        \ that)
                        \
                        \ So stashAddr(1 0) points to the last of those bytes in
                        \ the secretCodeStash, i.e. the byte at stashOffset + 41
                        \
                        \ The value that is stashed in the secretCodeStash is
                        \ the result of subtracting the entered code from the
                        \ generated code, which will be zero if they match, and
                        \ then %01111111 is added to the result (%01111111 being
                        \ the object flags for the Sentinel, which is all part
                        \ of the obfuscation of this process)
                        \
                        \ So if the secretCodeStash contains %01111111, this
                        \ means that particular byte matched, so if all four
                        \ bytes at offset stashOffset + 38 to stashOffset + 41
                        \ equal %01111111, this means the secret code was deemed
                        \ correct by CheckSecretCode

 LDY #0                 \ Set Y = 0 so we can fetch a value from the address in
                        \ stashAddr(1 0) in the following (we don't change its
                        \ value)

                        \ We use X as the loop counter to work through all four
                        \ bytes, as we set it to 3 above

.stas1

 LDA (stashAddr),Y      \ Fetch the contents of address stashAddr(1 0)

 CMP #%01111111         \ If it does not match %01111111 then this byte from the
 BNE talt2              \ secret code was not matched by the CheckSecretCode
                        \ routine (so it must have been bypassed by crackers),
                        \ so jump to MainTitleLoop via talt2 to restart the game

 DEC stashAddr          \ Decrement stashAddr(1 0) to point to the previous byte
                        \ in memory (we decrement as we initialised stashAddr
                        \ above to point to the last result byte in memory, so
                        \ this moves on to the next of the four bytes)

 DEX                    \ Decrement the loop counter

 BPL stas1              \ Loop back until we have checked all four secret code
                        \ bytes

                        \ The four code bytes have now been checked, but we have
                        \ one more check to do, that of the comparison just
                        \ before the four bytes
                        \
                        \ This comparison would have been between inputBuffer+4
                        \ and a BCD number from the landscape's sequence of seed
                        \ numbers
                        \
                        \ When the landscape code is entered, it is converted
                        \ into four BCD numbers in inputBuffer, and the rest of
                        \ the buffer is padded out with &FF, so inputBuffer+4
                        \ contains &FF at the point of comparison
                        \
                        \ &FF is not a valud BCD number, so it can never match a
                        \ BCD number from the landscape's sequence of seed
                        \ numbers, so we know that this comparison can never
                        \ have matched
                        \
                        \ So if stashAddr(1 0) contains %01111111 to indicate a
                        \ match, then we know that the stash has been modified
                        \ by a cracker, so we restart the game

 LDA (stashAddr),Y      \ Fetch the contents of address stashAddr(1 0)

 CMP #%01111111         \ If it matches %01111111 then we know the stash has
 BEQ talt2              \ been compromised, so jump to Mainloop via talt2 to
                        \ restart the game

 SEC                    \ Set bit 7 of doNotCheckSecret so we do not repeat the
 ROR doNotCheckSecret   \ secret code check again (at least, until we reach the
                        \ next landscape)

                        \ Fall through into part 2 of GetRowVisibility to
                        \ continue with the visibility calculations

\ ******************************************************************************
\
\       Name: GetRowVisibility (Part 2 of 2)
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Calculate whether each tile corner in a tile row is obscured from
\             the player by any intervening landscape
\
\ ******************************************************************************

                        \ In part 1 we set up (xVectorHi xVectorLo xVectorBot)
                        \ with the vector from the player to the tile corner,
                        \ split up into traceStepCounter steps, each of which is
                        \ smaller than the size of a tile
                        \
                        \ We can therefore trace the vector from the player to
                        \ the tile corner by taking the player's coordinates and
                        \ adding the vector:
                        \
                        \   [ (xVectorHi xVectorLo xVectorBot) ]
                        \   [ (yVectorHi yVectorLo yVectorBot) ]
                        \   [ (zVectorHi zVectorLo zVectorBot) ]
                        \
                        \ traceStepCounter times, knowing that togther, these
                        \ steps will stop over every tile between the player and
                        \ the tile corner in the process (we may stop over some
                        \ tiles more than once, but that's OK)
                        \
                        \ I'll refer to this vector as the player's gaze, as it
                        \ represents the line-of-sight from the player to the
                        \ tile corner we are analysing
                        \
                        \ So now we step along the player's gaze, checking on
                        \ each step whether the gaze is passing over a tile that
                        \ has a high enough altitude to block the player's view
                        \ of the tile corner we are analysing

.rvis6

 LDX #2                 \ We now work through all three axes in turn, so set an
                        \ axis counter in X to iterate through 2, 1 and 0 (for
                        \ the z-axis, y-axis and x-axis respectively)
                        \
                        \ The comments in the following loop will concentrate on
                        \ the x-axis to keep things simple

 CLC                    \ Clear the C flag so the initial addition at rvis8 will
                        \ start properly

 BCC rvis8              \ Jump into the following loop at rvis8 so we start off
                        \ that calculations with the z-axis and skip the bottom
                        \ byte

.rvis7

 LDA xCoordBot,X        \ For the y-axis calculation, we include the bottom byte
 ADC xVectorBot,X       \ for more accuracy, so we calculate the following:
 STA xCoordBot,X        \
                        \   (xCoordHi xCoordLo xCoordBot) +=
                        \                       (xVectorHi xVectorLo xVectorBot)

.rvis8

                        \ This is where we join the loop to add the next step to
                        \ the vector containing the current position along the
                        \ player's gaze towards the tile corner we're analysing

 LDA xCoordLo,X         \ Set (xCoordHi xCoordLo) += (xVectorHi xVectorLo)
 ADC xVectorLo,X 
 STA xCoordLo,X
 LDA xCoordHi,X
 ADC xVectorHi,X
 STA xCoordHi,X

                        \ The calculation above adds the scaled vector from the
                        \ player to the tile corner, which is in xVector, to the
                        \ player's object coordinates, which is in xCoord
                        \
                        \ So this calculation effectively follows the player's
                        \ gaze towards the tile corner, adding one of the steps
                        \ to the vector x-coordinate in:
                        \
                        \   (xVectorHi xVectorLo)
                        \
                        \ We repeat this for all three axes, calculating the
                        \ x- and z-axes with 16-bit accuracy, and the y-axis
                        \ with 24-bit accuracy (as y-coordinates are stored in
                        \ this way)

 CLC                    \ Clear the C flag so the following additions work

 DEX                    \ Decrement the axis counter

 BEQ rvis8              \ If we are just about to calculate the x-axis, jump
                        \ back to rvis8 to skip the bottom byte

 BPL rvis7              \ If we are about to calculate the y-axis, jump back to
                        \ rvis7 to include the bottom byte

                        \ We now work out whether this step has made the
                        \ player's gaze pass over a tile that is high enough to
                        \ block the player's view of the tile corner that we are
                        \ heading for

 LDA zCoordHi           \ Set the top byte of (S R) to the high byte of the
 STA S                  \ z-coordinate of our current step along gaze vector
                        \
                        \ Because we added &60 to the starting z-coordinate in
                        \ part 1, this will point to the &xx20 table of altitude
                        \ data for the tile row over which the gaze is passing
                        \
                        \ The GetTileAltitude routine populates the &xx20 table
                        \ with the altitude of the highest tile corner for each
                        \ tile, so (S R) now points to this data for the row
                        \ over which we are passing

 LDY xCoordHi           \ Set Y to the high byte of the x-coordinate of our
                        \ current step along gaze vector, which is the tile
                        \ x-coordinate of the tile that the gaze vector is
                        \ currently passing over
                        \
                        \ This means that (S R) + Y will contain the altitude
                        \ of the highest tile corner for the tile that we are
                        \ passing over

 LDA yCoordHi           \ Set A to the high byte of the y-coordinate of our
                        \ current step along gaze vector

 CMP (R),Y              \ If yCoordHi < (S R) + Y then the altitude of the gaze
 BCC rvis9              \ vector is lower than the altitude of the highest point
                        \ of the landscape on the tile over which we are
                        \ passing, which means the gaze vector has hit the
                        \ landscape before reaching the end
                        \
                        \ So jump to rvis9 to record that this tile corner is
                        \ not visible from the player's perspective, as it is
                        \ hidden behind a higher part of the landscape between
                        \ the player and the tile corner

 DEC traceStepCounter   \ Otherwise decrement the step counter to keep moving
                        \ along the vector

 BNE rvis6              \ If we haven't yet done all the steps, loop back to
                        \ rvis6 to do the next step in the ray-trace

                        \ If we get here then we have finished the ray-tracing
                        \ process and we didn't bump into any tiles on the way,
                        \ so the tile corner is not obscured by the landscape
                        \ and is therefore deemed to be visible

 CLC                    \ Clear the C flag so we store %11111111 in the
                        \ visibilitytable to indicate that this tile corner is
                        \ visible

 BCC rvis10             \ Jump to rvis10 to store the result (this BCC is
                        \ effectively a JMP as the C flag is always clear)

.rvis9

 SEC                    \ Set the C flag so we store %00000000 in the visibility
                        \ table to indicate that this tile corner is not visible

.rvis10

 LDA xTileRow           \ Set Y = drawingTableOffset + xTileRow
 ORA drawingTableOffset \
 TAY                    \ The value of drawingTableOffset is either 0 or 32, so
                        \ this creates an index in Y that we can use to store
                        \ the result in either oddVisibility (when it is 0) or
                        \ evenVisibility when it is 32)

 LDA #0                 \ Set A = 0 - 0 - (1 - C)
 SBC #0                 \       = C - 1
                        \
                        \ so this sets:
                        \
                        \   * A = %00000000 if the C flag is set (not visible)
                        \
                        \   * A = %11111111 if the C flag is clear (visible)

 STA oddVisibility,Y    \ Store the result in either the oddVisibility or
                        \ evenVisibility table, as determined by the value of
                        \ drawingTableOffset

 DEC xTileRow           \ Decrement xTileRow to move left along the tile row we
                        \ are analysing

 BMI rvis11             \ If we have already processed the leftmost tile then
                        \ jump to rvis11 to return from the subroutine

 JMP rvis1              \ Otherwise jump back to part 1 to analyse the next tile
                        \ to the left

.rvis11

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetTileAltitudes
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Calculate tile corner altitudes and maximum tile corner altitudes
\             for each tile in the landscape
\
\ ------------------------------------------------------------------------------
\
\ This routine calculates tile altitudes for use when drawing the landscape.
\
\ The altitude of each tile corner and the shape of the anchored tile (if any)
\ are stored as follows:
\
\   * &6000 to &601F for row zTile = 0
\   * &6100 to &611F for row zTile = 1
\     ...
\   * &7E00 to &7E1F for row zTile = 30
\   * &7F00 to &7F1F for row zTile = 31
\
\ The altitude of the highest tile corner for each tile is stored as follows:
\
\   * &6020 to &603E for tile row anchored by zTile = 0
\   * &6120 to &613E for tile row anchored by zTile = 1
\     ...
\   * &7D20 to &7E3E for tile row anchored by zTile = 29
\   * &7E20 to &7E3E for tile row anchored by zTile = 30
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   (Q P)               (Q P) is set to &6000
\
\   (S R)               (Q P) is set to &6020
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   talt2               Jump to MainTitleLoop via game10
\
\ ******************************************************************************

.GetTileAltitudes

 LDA #0                 \ Set the low byte of (Q P) = &7F00
 STA P

 STA considerObjects    \ Clear bit 7 of considerObjects so GetTileAltitude will
                        \ only extract the altitude and flatness of the tiles
                        \ when we call it below, ignoring any objects on the
                        \ landscape

 LDA #&7F               \ Set the high byte of (Q P) = &7F00
 STA Q                  \
                        \ This is the adddress where we will store the altitude
                        \ data for the back row of tile corners in the landscape

                        \ We now iterate through the tile corners with a nested
                        \ loop, with zTile going from 31 to 0 (so that's from
                        \ back to front)
                        \
                        \ For each zTile, xTile also goes from 31 to 0, so
                        \ that's from right to left
                        \
                        \ So we work through the landscape, starting with the
                        \ row of tile corners at the back (which we work through
                        \ from right to left), and then doing the next row
                        \ forward, looping until we reach the front row

 LDA #31                \ Set zTile = 31 so we start iterating from the back row
 STA zTile              \ (so zTile iterates from 31 to 0 in the outer loop)

.talt1

 LDA #31                \ Set xTile = 31 so we start iterating from the right
 STA xTile              \ end of the current row (so xTile iterates from 31 to 0
                        \ in the inner loop)

 BNE talt3              \ Jump to talt3 to join the loop below (this BNE is
                        \ effectively a JMP as A is never zero)

.talt2

 JMP game10             \ Jump to MainTitleLoop to restart the game (this has
                        \ nothing to do with the GetTileAltitudes routine, but
                        \ is all part of the anti-cracker code)

.talt3

 JSR GetTileAltitude    \ Call GetTileAltitude with bit 7 of considerObjects
                        \ clear to extract the following tile data:
                        \
                        \   * A = the high byte of the tile's altitude (which
                        \         is also the altitude of the tile corner)
                        \
                        \   * C flag = the tile's shape, clear if the tile is
                        \              flat or set if the tile is not flat

 LDY xTile              \ Set Y to the tile corner x-coordinate, to use as an
                        \ index so we store the tile corner data like this:
                        \
                        \   * Column xTile = 31 is stored in (Q P) + &1F
                        \   * Column xTile = 30 is stored in (Q P) + &1E
                        \   ...
                        \   * Column xTile = 1 is stored in (Q P) + &01
                        \   * Column xTile = 0 is stored in (Q P) + &00
                        \
                        \ (Q P) starts at &7F00 for zTile = 31, so the back row
                        \ of the landscape is stored in &7F00 to &7F1F
                        \
                        \ (Q P) is decremented for each tile row (see below), so
                        \ the next row forward is stored in &7E00 to &7E1F, for
                        \ example

 ROL A                  \ Rotate the C flag into bit 0 of A, so we have the
                        \ following:
                        \
                        \   * Bit 0 = clear if the tile is flat or set if the
                        \             tile is not flat
                        \
                        \   * Bits 1-4 = the tile corner's altitude

 STA (P),Y              \ Store the tile corner data in A in the Y-th entry in
                        \ the variable at (Q P), so this populates the extracted
                        \ data for the tile corner at (xTile, zTile)

 DEC xTile              \ Decrement the tile corner x-coordinate in the inner
                        \ loop

 BPL talt3              \ Loop back until we have processed all the tile corners
                        \ in the tile row at z-coordinate zTile, working from
                        \ right to left

 DEC Q                  \ Decrement the high byte of (Q P), so we store the
                        \ tile corner data like this:
                        \
                        \   * Row zTile = 31 is stored in &7F00 to &7F1F
                        \   * Row zTile = 30 is stored in &7E00 to &7E1F
                        \   ...
                        \   * Row zTile = 1 is stored in &6100 to &611F
                        \   * Row zTile = 0 is stored in &6000 to &601F

 DEC zTile              \ Decrement the tile corner z-coordinate in the outer
                        \ loop

 BPL talt1              \ Loop back until we have processed all the tile rows in
                        \ the landscape, working from the back row of the
                        \ landscape all the way to the front row
                        \
                        \ This leaves (Q P) set to &6000

                        \ We now iterate through each tile to calculate the
                        \ altitude of the highest tile corner, so we can store
                        \ it after the altitude data that we just extracted

 LDA #&20               \ Set the low byte of (S R) = &20
 STA R                  \
                        \ At this point the low byte of (Q P) is still zero, so
                        \ the following loop will start with the following
                        \ values:
                        \
                        \   (Q P) = &7E00
                        \
                        \   (S R) = &7E20
                        \
                        \ In other words (Q P) points to the altitude data that
                        \ we just extracted, and (S R) points to the next set of
                        \ bytes just after the end of the altitude data

                        \ We now work our way through the tiles, usine X as the
                        \ row number iterating from the rear, and Y as the
                        \ column number iterating from right to left along each
                        \ row in turn

 LDX #30                \ Set X = 30 to use as the row number, so we start
                        \ iterating from the rear, skipping the row right at the
                        \ back as the tile corners in that row do not anchor any
                        \ tiles (so X iterates from 30 to 0 in the outer loop)

.talt4

 TXA                    \ Set A = &60 + X
 CLC                    \
 ADC #&60               \ So this is the high byte of the address of the
                        \ extracted altitude for row X, starting from &7E and
                        \ working down to &60 as we iterate over each row

 STA Q                  \ Set the high byte of (Q P) to A, so (Q P) points to
                        \ the extracted altitude data for row X

 STA S                  \ Set the high byte of (S R) to A, so (S R) points to
                        \ the address just after the extracted altitude data
                        \ for row X

 LDY #30                \ Set Y = 30 to use as the column number, so we start
                        \ iterating from the right, skipping the rightmost
                        \ column as the tile corners in that column do not
                        \ anchor any tiles (so Y iterates from 30 to 0 in the
                        \ inner loop)

.talt5

                        \ We now calculate the altitude of the highest corner
                        \ for the tile that we are analysing, i.e. the tile
                        \ that's anchored by the tile corner at tile coordinates
                        \ (X, Y)
                        \
                        \ We do this by working through all four corners in the
                        \ tile, starting with the anchor point, and then
                        \ checking the corner to the right, then the corner
                        \ behind, and then the corner to the left

 LDA (P),Y              \ Fetch the extracted altitude data for the anchor of
                        \ the tile that we are analysing

 LSR A                  \ Shift bit 0 into the C flag, so it contains the shape,
                        \ and set A as the altitude

 BCC talt9              \ If the tile is flat then the C flag will be clear, so
                        \ jump to talt9 to set (S R) to the altitude of the tile
                        \ anchor, as the tile is flat and this altitude will do
                        \ for the highest point on the tile

 ROL A                  \ Otherwise the tile is not flat, so rotate the C flag
                        \ back into the extracted altitude data in A

 INY                    \ Increment Y to the tile corner to the right of the one
                        \ we are analysing

 CMP (P),Y              \ If this corner's altitude is less than the tile
 BCC talt6              \ anchor's altitude, jump to talt6 to skip the following

 LDA (P),Y              \ Set A to the new corner's height, so that A contains
                        \ the highest altitude of the tile's front two corners

.talt6

 INC Q                  \ Increment the high byte of (Q P), so it now points to
                        \ the extracted altitude data for the row of tile
                        \ corners behind the one we are currently analysing
                        \
                        \ Y is still incremented from the anchor point, so this
                        \ points us to the corner behind the one we just
                        \ analysed

 CMP (P),Y              \ If this corner's altitude is less than the highest
 BCC talt7              \ altitude, jump to talt7 to skip the following

 LDA (P),Y              \ Set A to the new corner's height, so that A contains
                        \ the highest altitude of the tile's front two corners
                        \ and the one at the rear-right of the tile

.talt7

 DEY                    \ Decrement Y to the tile corner to the left of the one
                        \ we just analysed

 CMP (P),Y              \ If this corner's altitude is less than the highest
 BCC talt8              \ altitude, jump to talt8 to skip the following

 LDA (P),Y              \ Set A to the new corner's height, so that A contains
                        \ the highest altitude of the tile's front two corners
                        \ and the two rear corners

.talt8

 DEC Q                  \ Decrement the high byte of (Q P) so it once again
                        \ points to the extracted altitude data for the anchor
                        \ point of the tile we are analysing

 LSR A                  \ Shift the highest altitude in A to remove the tile
                        \ shape from bit 0 and set A to the actual altitude from
                        \ bits 2 to 4

.talt9

 STA (R),Y              \ Set the entry in (S R) for this tile to the value in A
                        \ so it contains the highest altitude of the tile
                        \ anchored by the relevant tile corner

 DEY                    \ Decrement the column counter in Y to move left by one
                        \ tile

 BPL talt5              \ Loop back until we have processed the whole row from
                        \ right to left

 DEX                    \ Decrement the row counter in X to move forward by one
                        \ row

 BPL talt4              \ Loop back to process the next row until we have
                        \ processed all tiles in all rows in the landscape
                        \
                        \ This leaves (S R) set to &6020

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawLandscapeView (Part 1 of 3)
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Set up a number of variables for drawing the landscape view
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   viewingObject       The number of the object that is viewing the landscape
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   C flag              The status of the drawing operation:
\
\                         * Clear = the whole landscape has been drawn
\
\                         * Set = the whole landscape has not been drawn as the
\                                 panning key is no longer being held down
\
\ ******************************************************************************

.DrawLandscapeView

 LDX viewingObject      \ Set X to the number of the object that is viewing the
                        \ landscape

 LDA #LO(L0C40)         \ Set drawViewAngles(1 0) = L0C40 ???
 STA drawViewAngles
 LDA #HI(L0C40)
 STA drawViewAngles+1

 LDA objectYawAngle,X   \ Set A to the yaw angle of the viewer's object

 CLC                    \ Set viewingArcRightYaw = yaw angle + 32
 ADC #32                \
 STA viewingArcRightYaw \ This gives us the yaw angle of the right edge of the
                        \ viewing arc, where the arc is 90 degrees wide (as a
                        \ full circle is represented by 256)

 AND #63                \ Set T = (yaw angle + 32) mod 64 - 32
 SEC                    \
 SBC #32                \ This gives us the yaw angle of the centre of the
 STA T                  \ viewing arc (i.e. the direction of gaze), reduced
                        \ into the range of a single 90-degree quadrant

 LDA viewingArcRightYaw \ Set bits 0-1 of Y to bits 6-7 of viewingArcRightYaw
 ASL A                  \
 ROL A                  \ This gives us a value in the range 0 to 3, giving
 ROL A                  \ the number of the quadrant that contains the right
 AND #3                 \ edge of the viewing arc, numbered clockwise and
 TAY                    \ starting from 12 o'clock to 3pm

 LDA quadrantOffsets,Y  \ Set quadrantOffset to 0, 1, 33 or 32 depending on the
 STA quadrantOffset     \ quadrant containing the right edge of the viewing arc
                        \
                        \ This is used by the DrawTileAndObjects routine ???

 TYA                    \ Set viewingQuadrantx4 = Y * 4
 ASL A                  \
 ASL A                  \ So viewingQuadrantx4 contains the quadrant number
 STA viewingQuadrantx4  \ containing the right edge of the viewing arc,
                        \ multiplied by 4
                        \
                        \ This is used by the DrawSlopingTile routine ???

 TYA                    \ Set viewingQuadrantOpp = Y - 2
 SEC                    \
 SBC #2                 \ So it viewingQuadrantOpp contains the number of the
 STA viewingQuadrantOpp \ quadrant opposite the quadrant containing the right
                        \ edge of the viewing arc
                        \
                        \ This is used by the DrawTileAndObjects routine ???

 LDA T                  \ Set screenLeftYawHi = T - 10
 SEC                    \
 SBC #10                \ So screenLeftYawHi contains the yaw angle of the gaze
 STA screenLeftYawHi    \ in the the centre of the viewing arc, less 14.0625
                        \ degrees (i.e. 360 * 10 / 256)
                        \
                        \ The screen is 20 yaw angle units across, so this sets
                        \ screenLeftYawHi to the high byte of the yaw angle of
                        \ the left edge of the screen, reduced into the range of
                        \ a single 90-degree quadrant (so it's relative to the
                        \ 90-degree viewing arc)

                        \ We now set (xTileViewer, zTileViewer) to the tile
                        \ coordinate of the viewer (object #X), but with the
                        \ axes rotated to match the orientation of the viewer,
                        \ so the x- and z-coordinate axes are from the
                        \ perspective of the viewer rather than of the 3D world
                        \
                        \ As a reminder, the degree system in the Sentinel looks
                        \ like this, with the z-axis pointing into the screen
                        \ and the x-axis pointing right:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of player
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \             ^           x-axis left -->
                        \         /  |  \            |             to right
                        \      -96   |   +96         z-axis
                        \           128              into screen
                        \
                        \ To make this easier to describe, let's label it like a
                        \ clock:
                        \
                        \            12
                        \    10.30   |    1.30
                        \         \  |  /
                        \          \ | /
                        \           \|/
                        \     9 -----+----- 3
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \     7.30   |   4.30
                        \            6
                        \
                        \ We now work out which quadrant contains the viewing
                        \ arc and set (xTileViewer, zTileViewer) to the tile
                        \ coordinates of the viewer, but using the axes from the
                        \ viewer's frame of reference/point of view
                        \
                        \ Note that in the following, we subtract from 30 rather
                        \ than 31 because we are working with tiles rather than
                        \ tile corners ???

 BIT viewingArcRightYaw \ If bit 7 of the quadrant containing the right edge of
 BMI dlan2              \ the viewing arc is set, jump to dlan2

 BVS dlan1              \ If bit 6 of the quadrant containing the right edge of
                        \ the viewing arc is set, jump to dlan1

                        \ If we get here then:
                        \
                        \   * Bit 7 of the right edge's quadrant is clear
                        \   * Bit 6 of the right edge's quadrant is clear
                        \
                        \ This means that the right edge of the viewing arc is
                        \ in the 12 o'clock to 3 o'clock quadrant
                        \
                        \ So the viewing direction in the middle of the arc is
                        \ between 10.30 and 1.30, or broadly in the direction of
                        \ 12 o'clock
                        \
                        \ This is the standard orientation of the landscape,
                        \ so we can simply set the viewer coordinates to those
                        \ of object #X

 LDA xObject,X          \ Set (xTileViewer, zTileViewer) = (x, z)
 STA xTileViewer        \
 LDA zObject,X          \ where object #X is on tile (x, z)
 STA zTileViewer

 JMP dlan4              \ Jump to dlan4 to keep going

.dlan1

                        \ If we get here then:
                        \
                        \   * Bit 7 of the right edge's quadrant is clear
                        \   * Bit 6 of the right edge's quadrant is set
                        \
                        \ This means that the right edge of the viewing arc is
                        \ in the 3 o'clock to 6 o'clock quadrant
                        \
                        \ So the viewing direction in the middle of the arc is
                        \ between 1.30 and 4.30, or broadly in the direction of
                        \ 3 o'clock
                        \
                        \ If you imagine the standard 3D world, with the z-axis
                        \ going into the screen and the x-axis going from left
                        \ to right, then turning right means that from our new
                        \ perspective:
                        \
                        \   * The axis we now see running from left to right is
                        \     the 3D world z-axis, but in the opposite direction
                        \
                        \   * The axis we now see going away from us is the 3D
                        \     world x-axis
                        \
                        \ Therefore, from the perspective of the viewer:
                        \
                        \   * The x-axis is the 3D world z-axis in the opposite
                        \     direction, which is 30 - z
                        \
                        \   * The z-axis is the 3D world x-axis, which is x
                        \
                        \ So that's what we set now

 CLC                    \ Set (xTileViewer, zTileViewer) = (30 - z, x)
 LDA #31                \
 SBC zObject,X          \ where object #X is on tile (x, z)
 STA xTileViewer
 LDA xObject,X
 STA zTileViewer

 JMP dlan4              \ Jump to dlan4 to keep going

.dlan2

                        \ If we get here then bit 7 of the quadrant containing
                        \ the right edge of the viewing arc is set

 BVS dlan3              \ If bit 6 of the quadrant containing the right edge of
                        \ the viewing arc is set, jump to dlan3

                        \ If we get here then:
                        \
                        \   * Bit 7 of the right edge's quadrant is set
                        \   * Bit 6 of the right edge's quadrant is clear
                        \
                        \ This means that the right edge of the viewing arc is
                        \ in the 6 o'clock to 9 o'clock quadrant
                        \
                        \ So the viewing direction in the middle of the arc is
                        \ between 4.30 and 7.30, or broadly in the direction of
                        \ 6 o'clock
                        \
                        \ If you imagine the standard 3D world, with the z-axis
                        \ going into the screen and the x-axis going from left
                        \ to right, then turning around to face out of the
                        \ screen means that from our new perspective:
                        \
                        \   * The axis we now see running from left to right is
                        \     the 3D world x-axis, but in the opposite direction
                        \
                        \   * The axis we now see going away from us is the 3D
                        \     world z-axis, but in the opposite direction
                        \
                        \ Therefore, from the perspective of the viewer:
                        \
                        \   * The x-axis is the 3D world x-axis in the opposite
                        \     direction, which is 30 - x
                        \
                        \   * The z-axis is the 3D world z-axis in the opposite
                        \     direction, which is 30 - z
                        \
                        \ So that's what we set now

 CLC                    \ Set (xTileViewer, zTileViewer) = (30 - x, 30 - z)
 LDA #31                \
 SBC xObject,X          \ where object #X is on tile (x, z)
 STA xTileViewer
 CLC
 LDA #31
 SBC zObject,X
 STA zTileViewer

 JMP dlan4              \ Jump to dlan4 to keep going

.dlan3

                        \ If we get here then:
                        \
                        \   * Bit 7 of the right edge's quadrant is set
                        \   * Bit 6 of the right edge's quadrant is set
                        \
                        \ This means that the right edge of the viewing arc is
                        \ in the 9 o'clock to 12 o'clock quadrant
                        \
                        \ So the viewing direction in the middle of the arc is
                        \ between 7.30 and 10.30, or broadly in the direction of
                        \ 9 o'clock
                        \
                        \ If you imagine the standard 3D world, with the z-axis
                        \ going into the screen and the x-axis going from left
                        \ to right, then turning left means that from our new
                        \ perspective:
                        \
                        \   * The axis we now see running from left to right is
                        \     the 3D world z-axis
                        \
                        \   * The axis we now see going away from us is the 3D
                        \     world x-axis, but in the opposite direction
                        \
                        \ Therefore, from the perspective of the viewer:
                        \
                        \   * The x-axis is the 3D world z-axis, which is z
                        \
                        \   * The z-axis is the 3D world x-axis in the opposite
                        \     direction, which is 30 - x
                        \
                        \ So that's what we set now

 LDA zObject,X          \ Set (xTileViewer, zTileViewer) = (z, 30 - x)
 STA xTileViewer        \
 CLC                    \ where object #X is on tile (x, z)
 LDA #31
 SBC xObject,X
 STA zTileViewer

\ ******************************************************************************
\
\       Name: DrawLandscapeView (Part 2 of 3)
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Work through the landscape, drawing one row of tiles/objects at a
\             time, from the back row to the front row
\
\ ******************************************************************************

.dlan4

 LDA #31                \ We now iterate through all the tile rows, from back to
 STA zTile              \ front towards the viewer, so set a row counter in
                        \ zTile to iterate from 31 to 0

 LDA xTileLeftPrevious  \ Set xTileViewLeft = xTileLeftPrevious, so we start
 STA xTileViewLeft      \ checking for the view edges, starting from the left
                        \ edge from the previous calculation (or from tile zero
                        \ if this is the first time)
                        \
                        \ This makes the search for edges more efficient as the
                        \ edges in neighbouring rows will be close together

 LDA #0                 \ Set drawingTableOffset = 0 so the call to first call
 STA drawingTableOffset \ GetTileViewEdges (for tile row 31) will populate the
                        \ tables at tileViewData+0, tileViewYaw+0 and
                        \ tileViewPitch+0 with the angles of the tile being
                        \ analysed

 JSR GetTileViewEdges   \ For the row of tile corners at the very back of the
                        \ landscape from the point of view of the viewer, work
                        \ out the edges of the visible portion of the row in
                        \ the current player view, as left to right tile
                        \ numbers in xTileViewLeft and xTileViewRight
                        \
                        \ We don't draw this row as it doesn't have any tiles
                        \ anchored by the corners, but we generate the data so
                        \ we can use it when drawing the tile rows below

 LDA xTileViewLeft      \ Store the column number for the left edge of the
 STA xTileLeftPrevious  \ visible portion of the row in xTileLeftPrevious, so 
                        \ we can refer to it above when we move on to the next
                        \ row in front

                        \ We now loop through each row of tile corners that has
                        \ a row of tiles anchored, drawing each row in turn,
                        \ from the back of the view to the front

.dlan5

 LDA drawingTableOffset \ Flip drawingTableOffset between 0 and 32, so each call
 EOR #32                \ to GetTileViewEdges and GetTileViewAngles alternates
 STA drawingTableOffset \ between storing the tile view data in:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \ and storing it in:
                        \
                        \   * (drawViewYawHi+32 drawViewYawLo+32)
                        \
                        \   * (drawViewPitchHi+32 drawViewPitchLo+32)
                        \
                        \   * tileViewData+32
                        \
                        \ This lets us store tile view data for both the current
                        \ row that we are drawing and the previously drawn row

 LDA xTileViewLeft      \ Set xTileViewLeftEdge to the tile number of the left
 STA xTileViewLeftEdge  \ edge of the visible portion of the row we are
                        \ analysing (i.e. zTile) so that we can generate results
                        \ for other rows without losing this information

 LDA xTileViewRight     \ Set xTileViewRightEdge to the tile number of the right
 STA xTileViewRightEdge \ edge of the visible portion of the row we are
                        \ analysing (i.e. zTile) so that we can generate results
                        \ for other rows without losing this information

 JSR ProcessSound       \ Process any sounds or music that are being made in the
                        \ background

 DEC zTile              \ Decrement zTile to the z-coordinate of the next tile
                        \ row forward, towards the viewerm so we can draw this
                        \ new row

 BMI dlan6              \ If we have already drawn all the rows from 31 to 0,
                        \ jump to dlan6 to return from the subroutine with the
                        \ C flag clear

 LDY zTile              \ If the new tile row is not the tile row that contains
 CPY zTileViewer        \ the viewer, jump to dlan7 to draw it
 BNE dlan7

 JMP dlan18             \ The new tile row contains the viewer, so jump to
                        \ dlan18 to draw this row as a special case

.dlan6

 CLC                    \ Clear the C flag to indicate that we have drawn the
                        \ whole landscape

 RTS                    \ Return from the subroutine

.dlan7

                        \ We now check whether the new row, which we are about
                        \ to draw, has the same visible portion as the
                        \ previously drawn row, or if whether the new row's
                        \ visible portion extends beyond the previous visible
                        \ row or doesn't extend as far
                        \
                        \ If the visaible portions don't match, then we either
                        \ need to extend the tile data for the current row to
                        \ match, or we need to go back and extend the tile data
                        \ on the previous row to match the current row
                        \
                        \ This is so we can draw the tiles properly, as tiles
                        \ are made up of tiles from both the current and
                        \ previous rows of tile corners, so the calculate tile
                        \ view data needs to match between the two rows

 JSR GetTileViewEdges   \ For the new tile row, work out the edges of the
                        \ visible portion of the row in the current player view,
                        \ as left to right tile numbers in xTileViewLeft and
                        \ xTileViewRight

 LDY xTileViewLeft      \ If xTileViewLeft = xTileViewLeftEdge then the left
 CPY xTileViewLeftEdge  \ edge of the visible row in this new row is at the same
 BEQ dlan11             \ place as in the previous row, so jump to dlan11 to
                        \ do the same check on the right edge

 BCC dlan9              \ If xTileViewLeft < xTileViewLeftEdge then the left
                        \ edge of the visible row in this new row is less than
                        \ (i.e. to the left of) the edge in the previous row, so
                        \ jump to dlan9 to go back to the previous row to fetch
                        \ the tile data needed to make the datasets match

                        \ Otherwise xTileViewLeft > xTileViewLeftEdge and the
                        \ left edge of the visible row in this new row is
                        \ greater (i.e. to the right of) the edge in the
                        \ previous row, so we need to fetch more data on the
                        \ left end of the current row to make the datasets match

.dlan8

 DEY                    \ Decrement Y to move left along the row by one tile

 JSR GetTileViewAngles  \ Calculate the pitch and yaw angles for the tile corner
                        \ at (Y, zTile), from the perspective of the viewer, and
                        \ store them in the following tables in the relevant
                        \ entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)

 CPY xTileViewLeftEdge  \ Loop back until we have moved left along the tile row
 BNE dlan8              \ all the way to the left edge in the previous row

 BEQ dlan11             \ Jump to dlan11 to move on to the checks on the right
                        \ edge (this BEQ is effectively a JMP as we just passed
                        \ through a BNE)

.dlan9

                        \ If we get here then xTileViewLeft < xTileViewLeftEdge,
                        \ so we need to go back to the previous row to fetch
                        \ more tile data for the left end of the row, so we can
                        \ use it to work out what to draw for the left end of
                        \ the new row we are trying to draw
                        \
                        \ This is because the visible part of the new row (the
                        \ row in front) is extending left beyond the left edge
                        \ of the visible part of the previous row (the one
                        \ behind), so we won't have calculated the required
                        \ tile data for the non-visible part of the previous
                        \ row
                        \
                        \ So we do that now by switching back to the previous
                        \ row and calculating all the tile data for the tiles on
                        \ the left of the previous row that have visible tiles
                        \ in front of them in the new row

 LDA drawingTableOffset \ Flip drawingTableOffset between 0 and 32, so the calls
 EOR #32                \ to GetTileViewEdges and GetTileViewAngles store their
 STA drawingTableOffset \ data into the storage area that we used for the
                        \ previous row, so we effectively extend the data to the
                        \ left for the previous row

 INC zTile              \ Increment xTile to the tile row number behind the one
                        \ we are drawing, i.e. the previous row in this process

 LDY xTileViewLeftEdge  \ Set Y to the left edge for the previous row

.dlan10

 DEY                    \ Decrement Y to move left along the row by one tile

 JSR GetTileViewAngles  \ Calculate the pitch and yaw angles for the tile corner
                        \ at (Y, zTile), from the perspective of the viewer, and
                        \ store them in the following tables in the relevant
                        \ entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)

 CPY xTileViewLeft      \ Loop back until we have moved left along the tile row
 BNE dlan10             \ all the way to the left edge in the new row in front

 STY xTileViewLeftEdge  \ Update xTileViewLeftEdge to store the newly moved edge
                        \ for the previous row

 DEC zTile              \ Decrement zTile once again to move back to the row
                        \ that we are drawing

 LDA drawingTableOffset \ Flip drawingTableOffset back again, so the calls
 EOR #32                \ to GetTileViewEdges and GetTileViewAngles once again
 STA drawingTableOffset \ store data in the new row's storage area

.dlan11

                        \ By this point we have checked the left edges of the
                        \ current and previous rows to fill in gaps in the tile
                        \ data caused by the new row overlapping the previous
                        \ row, and we now do the exact same thing for the right
                        \ edges

 LDY xTileViewRight     \ If xTileViewRight = xTileViewRightEdge then the right
 CPY xTileViewRightEdge \ edge of the visible row in this new row is at the same
 BEQ dlan15             \ place as in the previous row, so jump to dlan15 to
                        \ draw the new row as we have all the tile information
                        \ we need

 BCS dlan13             \ If xTileViewRight > xTileViewRightEdge then the right
                        \ edge of the visible row in this new row is greater
                        \ then (i.e. to the right of) the edge in the previous
                        \ row, so jump to dlan13 to go back to the previous row
                        \ to fetch the tile data needed to make the datasets
                        \ match

                        \ Otherwise xTileViewRight < xTileViewRightEdge and the
                        \ right edge of the visible row in this new row is less
                        \ than (i.e. to the left of) the edge in the previous
                        \ row, so we need to fetch more data on the right end of
                        \ the current row to make the datasets match

.dlan12

 INY                    \ Increment Y to move right along the row by one tile

 JSR GetTileViewAngles  \ Calculate the pitch and yaw angles for the tile corner
                        \ at (Y, zTile), from the perspective of the viewer, and
                        \ store them in the following tables in the relevant
                        \ entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)

 CPY xTileViewRightEdge \ Loop back until we have moved right along the tile row
 BNE dlan12             \ all the way to the right edge in the previous row

 BEQ dlan15             \ Jump to dlan15 to draw the new row as we have all the
                        \ tile information we need (this BEQ is effectively a
                        \ JMP as we just passed through a BNE)

.dlan13

                        \ If we get here, xTileViewRight > xTileViewRightEdge,
                        \ so we need to go back to the previous row to fetch
                        \ more tile data for the right end of the row, so we can
                        \ use it to work out what to draw for the right end of
                        \ the new row we are trying to draw
                        \
                        \ This is because the visible part of the new row (the
                        \ row in front) is extending right beyond the right edge
                        \ of the visible part of the previous row (the one
                        \ behind), so we won't have calculated the required
                        \ tile data for the non-visible part of the previous
                        \ row
                        \
                        \ So we do that now by switching back to the previous
                        \ row and calculating all the tile data for the tiles on
                        \ the right of the previous row that have visible tiles
                        \ in front of them in the new row

 LDA drawingTableOffset \ Flip drawingTableOffset between 0 and 32, so the calls
 EOR #32                \ to GetTileViewEdges and GetTileViewAngles store their
 STA drawingTableOffset \ data into the storage area that we used for the
                        \ previous row, so we effectively extend the data to the
                        \ left for the previous row

 INC zTile              \ Increment xTile to the tile row number behind the one
                        \ we are drawing, i.e. the previous row in this process

 LDY xTileViewRightEdge \ Set Y to the right edge for the previous row

.dlan14

 INY                    \ Increment Y to move right along the row by one tile

 JSR GetTileViewAngles  \ Calculate the pitch and yaw angles for the tile corner
                        \ at (Y, zTile), from the perspective of the viewer, and
                        \ store them in the following tables in the relevant
                        \ entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)

 CPY xTileViewRight     \ Loop back until we have moved right along the tile row
 BNE dlan14             \ all the way to the right edge in the new row in front

 STY xTileViewRightEdge \ Update xTileViewRightEdge to store the newly moved
                        \ edge for the previous row

 DEC zTile              \ Decrement zTile once again to move back to the row
                        \ that we are drawing

 LDA drawingTableOffset \ Flip drawingTableOffset back again, so the calls
 EOR #32                \ to GetTileViewEdges and GetTileViewAngles once again
 STA drawingTableOffset \ store data in the new row's storage area

.dlan15

                        \ By this point we have ensured that we have all the
                        \ tile data that we need to draw the new row

 JSR DrawLandscapeRow   \ Draw the tile row at z-coordinate zTile, between tiles
                        \ xTileViewLeftEdge and xTileViewRightEdge, including
                        \ any objects on any of the tiles

 BIT keepCheckingPanKey \ If bit 7 of keepCheckingPanKey is clear then we should
 BPL dlan16             \ keep drawing the landscape irrespective of whether the
                        \ pan key is still being pressed, so jump to dlan16 to
                        \ jump back to dlan5 to keep drawing the landscape

                        \ If we get here then we need to check whether the same
                        \ pan key is still being held down, and abort the
                        \ drawing process if it isn't (this happens if the
                        \ player initiates a pan, thus triggering this drawing
                        \ process, but releases the key before the drawing has
                        \ finished, in which case we don't need to finish off
                        \ drawing the landscape)

 JSR CheckForSamePanKey \ Check to see whether the same pan key is being
                        \ held down compared to the last time we checked

 BNE dlan17             \ If the same pan key is not being held down, jump to
                        \ dlan17 to return from the subroutine with the C flag
                        \ set to indicate that this is the case

.dlan16

 JMP dlan5              \ Loop back to dlan5 to analyse and draw the next tile
                        \ row forward, towards the viewer

.dlan17

 SEC                    \ Set the C flag to indicate that we are aborting the
                        \ drawing of the landscape as the panning key is no
                        \ longer being held down

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawLandscapeView (Part 3 of 3)
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Draw a tile row in two parts, one on either side of the viewer
\
\ ******************************************************************************

.dlan18

                        \ If we get here then the tile row we are drawing
                        \ contains the viewer
                        \
                        \ The viewer can only see one half of the row, because
                        \ they are standing on it, so we need to work out which
                        \ half this is (if they can see any of the row at all)
                        \ and then draw it
                        \
                        \ We don't draw the viewer's tile yet, as we do that
                        \ later

 LDY xTileViewLeftEdge  \ Set Y to the tile number just inside the left edge of
 INY                    \ the visible portion of the row

 CPY xTileViewer        \ If this isn't the viewer's tile, jump to dlan19 to
 BNE dlan19             \ perform the same check on the right side

                        \ If we get here then the visible part of the viewer's
                        \ tile row starts on the tile just to the left of their
                        \ position, so we are looking left and should draw that
                        \ part of the visible row

 STY xTileViewRightEdge \ Set the right edge to the viewer's tile, so we draw
                        \ from the left edge up to (but not including) the
                        \ viewer's tile

 JMP dlan20             \ Jump to dlan20 to draw the tile row containing the
                        \ viewer

.dlan19

                        \ If we get here then the left edge is not just to the
                        \ left of the viewer, so now we check the right edge

 LDY xTileViewRightEdge \ Set Y to the tile number that's two to the left of the
 DEY                    \ right edge of the visible portion
 DEY

 CPY xTileViewer        \ If this isn't the viewer's tile, jump to dlan21 to
 BNE dlan21             \ skip drawing the tile row altogether, as we can't see
                        \ it to the left or the right (so instead we move on to
                        \ drawing the player's tile)

                        \ If we get here then the visible part of the viewer's
                        \ tile row starts on the tile just to the right of their
                        \ position, so we are looking right and should draw that
                        \ part of the visible row

 INY                    \ Set the left edge to the tile just right of the
 STY xTileViewLeftEdge  \ viewer's tile, so we draw from just right of the
                        \ viewer's tile to the right edge

.dlan20

                        \ We now draw the tile row containing the viewer, but
                        \ first we need to ensure we have the data for the tiles
                        \ at each end

 LDY xTileViewLeftEdge  \ Set Y to the left edge of the viewer's tile row

 JSR GetTileViewAngles  \ Calculate the pitch and yaw angles for the tile corner
                        \ at (Y, zTile), from the perspective of the viewer, and
                        \ store them in the following tables in the relevant
                        \ entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)

 LDY xTileViewRightEdge \ Set Y to the right edge of the viewer's tile row

 JSR GetTileViewAngles  \ Calculate the pitch and yaw angles for the tile corner
                        \ at (Y, zTile), from the perspective of the viewer, and
                        \ store them in the following tables in the relevant
                        \ entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)

 JSR DrawLandscapeRow   \ Draw the tile row at z-coordinate zTile, between tiles
                        \ xTileViewLeftEdge and xTileViewRightEdge, including
                        \ any objects on any of the tiles

.dlan21

                        \ We now draw the tile row beneath the viewer, but first
                        \ we need to ensure we have the data for the tile just
                        \ in front of it

 LDA #0                 \ Set drawingTableOffset = 0 so the following call to
 STA drawingTableOffset \ GetTileViewAngles (which we call to fetch the data for
                        \ the tile corner row in front of viewer) will populate
                        \ the tables at tileViewYaw+0 and tileViewPitch+0

 INC zTile              \ Increment the row number so it's the row in front of
                        \ the viewer

 LDY xTileViewer        \ Set Y to the tile column for the viewer's tile, so we
                        \ can fetch the tile data for the tile directly in front
                        \ of the viewer

 JSR GetTileViewAngles  \ Calculate the pitch and yaw angles for the tile corner
                        \ at (Y, zTile), from the perspective of the viewer, and
                        \ store them in the following tables in the relevant
                        \ entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)

                        \ By this point we have the following:
                        \
                        \   * The tables at tileViewYaw+0 and tileViewPitch+0
                        \     contain data for the tile corner row in front of
                        \     the viewer, i.e. for the front edge of the tile on
                        \     which the viewer sits
                        \
                        \   * The tables at tileViewYaw+32 and tileViewPitch+32
                        \     contain data for the tile corner row containing
                        \     the viewer, i.e. for the rear edge of the tile on
                        \     which the viewer sits
                        \
                        \ Y is the offset of the viewer's tile within these
                        \ tables, so, for example:
                        \
                        \    * drawViewPitchHi,Y is the corner at the front
                        \      left of the viewer's tile
                        \
                        \    * drawViewPitchHi+1,Y is the corner at the front
                        \      right of the viewer's tile
                        \
                        \    * drawViewPitchHi+32,Y is the corner at the rear
                        \      left of the viewer's tile
                        \
                        \    * drawViewPitchHi+32+1,Y is the corner at the rear
                        \      right of the viewer's tile
                        \
                        \ We now set up the angles for the tile to ensure that
                        \ it looks correct

 LDA drawViewPitchHi,Y  \ If the high byte of the pitch angle of the front-left
 CMP #2                 \ edge of the viewer's tile is 2 or more, then it is off
 BCS dlan22             \ the top of the screen, so jump to dlan22 to skip
                        \ drawing it and instead return from the subroutine ???

 STA drawViewPitchHi+1,Y    \ Set the pitch angle for the tile corner in the
 LDA drawViewPitchLo,Y      \ front-right corner of the viewer's tile to be the
 STA drawViewPitchLo+1,Y    \ same as the front-left corner, so this ensures
                            \ that the two front corners of the tile containing
                            \ the viewer are horizontally level

 LDA #32                \ Set drawingTableOffset = 0 so the following call to
 STA drawingTableOffset \ DrawFlatTile (for the tile row beneath the viewer)
                        \ will fetch data from the tables at tileViewData+32,
                        \ tileViewYaw+32 and tileViewPitch+32

 DEC zTile              \ Decrement the row number so it goes back to the row
                        \ containing the viewer

                        \ We now position the corners of the viewe'r's tile so
                        \ it spreads to the left and right screen edges and
                        \ appears to dip down behind the viewer (so it spreads
                        \ down to the bottom of the screen as well)

 LDA #&FF                       \ Set the pitch angle for the two rear tile
 STA drawViewPitchHi+32,Y       \ corners to be as low down as possible (as the
 STA drawViewPitchHi+32+1,Y     \ high byte of &FF makes the angle negative)

 STA drawViewYawHi+32,Y \ Set the yaw angle for the two left tile corners to be
 STA drawViewYawHi,Y    \ as far left as possible

 LDA #20                    \ Set the yaw angle for the two right tile corners
 STA drawViewYawHi+32+1,Y   \ to 20, which is a full screen width, so this puts
 STA drawViewYawHi+1,Y      \ them on the right edge of the screen

 LDA xTileViewer        \ Set xTileToDraw to the column of the viewer's tile, so
 STA xTileToDraw        \ the call to DrawFlatTile draws this tile

 JSR DrawFlatTile       \ Draw the flat tile under the viewer

.dlan22

 CLC                    \ Clear the C flag to indicate that we have drawn the
                        \ whole landscape

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: quadrantOffsets
\       Type: Variable
\   Category: Drawing the landscape
\    Summary: Offsets into the tile view data tables for the four different
\             viewing directions
\
\ ******************************************************************************

.quadrantOffsets

 EQUB 0                 \ Looking at 12 o'clock (front left corner)

 EQUB 1                 \ Looking at 3 o'clock (front right corner)

 EQUB 32 + 1            \ Looking at 6 o'clock (rear right corner)

 EQUb 32                \ Looking at 9 o'clock (rear left corner)

\ ******************************************************************************
\
\       Name: GetTileViewEdges
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: For a given tile row, work out the edges of the visible portion of
\             the row in the current player view, as left to right tile numbers
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   xTileViewLeft       The tile column of the tile we are analysing, from the
\                       perspective of the viewer, to be used as a starting
\                       point for working out the visible edges of the row
\
\   zTile               The tile row of the tile we are analysing, from the
\                       perspective of the viewer
\
\   drawingTableOffset  Defines where we store the results of the analysis in
\                       the tileViewData, tileViewYaw and tileViewPitch drawing
\                       data tables; each table contains two complete sets of
\                       tile data, with the first table at offset 0 and and the
\                       second table at offset 32, so we store the results
\                       as follows:
\
\                         * 0 = store the results in the first table
\                               e.g. in the 32-byte table at tileViewData
\
\                         * 32 = store the results in the second table
\                               e.g. in the 32-byte table at tileViewData+32
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   xTileViewLeft       The number of the tile column on this row that appears
\                       at the left edge of the screen
\
\   xTileViewRight      The number of the tile column on this row that appears
\                       at the right edge of the screen
\
\   tileViewData        Tile data for all the tile corners analysed while
\                       looking for the edges
\
\   drawViewYawHi       High byte of the yaw angles for all the tile corners
\                       analysed while looking for the edges
\
\   drawViewYawLo       Low byte of the yaw angles for all the tile corners
\                       analysed while looking for the edges
\
\   drawViewPitchHi     High byte of the pitch angles for all the tile corners
\                       analysed while looking for the edges
\
\   drawViewPitchLo     Low byte of the pitch angles for all the tile corners
\                       analysed while looking for the edges
\
\   tileIsOnScreen      Information on whether a tile corner is on-screen for
\                       all the tile corners analysed while looking for the
\                       edges
\
\ ******************************************************************************

.GetTileViewEdges

 LDY xTileViewLeft      \ Set Y to the tile column so we can pass it to the
                        \ GetTileViewAngles routine

 JSR GetTileViewAngles  \ Calculate the pitch and yaw angles for the tile corner
                        \ at (Y, zTile), from the perspective of the viewer, and
                        \ store them in the following tables in the relevant
                        \ entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)

 BEQ edge5              \ If A = %00000000 then the tile is not on-screen and is
                        \ past the left edge of the screen, so jump to edge5 to
                        \ move right from this point, looking for a tile that's
                        \ on-screen

                        \ If we get here then our chosen starting tile is either
                        \ on-screen or off the right edge of the screen

 CMP #%10000000         \ If A = %10000000 then the tile is on-screen, so jump
 BEQ edge4              \ to edge4 to update xTileViewRight to this position and
                        \ start moving left, so we work through the portion to
                        \ the left of the starting point

                        \ If we get here then tileIsOnScreen = %10000001 and the
                        \ tile is not on-screen and is past the right edge of
                        \ the screen, so fall through into edge1 to start moving
                        \ right

.edge1

                        \ If we get here then we keep moving right, updating
                        \ xTileViewLeft as we go
                        \
                        \ We keep moving until:
                        \
                        \   * We find a tile that's on-screen or reach the end
                        \     of the tile row, in which case we jump to edge3 to
                        \     set xTileViewRight and return from the subroutine
                        \
                        \   * We find a tile that's off the left of the screen,
                        \     in which case we fall through into edge2

 LDA xTile              \ Store the current column number in xTileViewLeft
 STA xTileViewLeft

 JSR GetTileEdgeToRight \ Move one tile to the right and calculate the pitch and
                        \ yaw angles for the tile corner from the perspective of
                        \ the viewer, and store them in the following tables in
                        \ the relevant entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)
                        \
                        \ The C flag is set if we have already reached the end
                        \ of the row and can't move any further right

 BCS edge3              \ If we just moved off the right end of the row then the
                        \ right end of the row is visible on-screen, so jump to
                        \ edge3 to set xTileViewRight accordingly and return
                        \ from the subroutine

 CMP #%10000001         \ If A = %10000001 then the tile is past the right edge
 BEQ edge1              \ of the screen, so loop back to move right by one more
                        \ tile

 CMP #%10000000         \ If A = %10000000 then the tile is on-screen, so jump
 BEQ edge3              \ to edge3 to set xTileViewRight accordingly and return
                        \ from the subroutine

                        \ If we get here then A must be %00000000 and the tile
                        \ is off the left edge of the screen, so fall through
                        \ into edge2 to keep moving right

.edge2

                        \ If we get here then we keep moving right until:
                        \
                        \   * We find a tile that's on-screen or reach the end
                        \     of the tile row, in which case we jump to edge3 to
                        \     set xTileViewRight and return from the subroutine

 JSR GetTileEdgeToRight \ Move one tile to the right and calculate the pitch and
                        \ yaw angles for the tile corner from the perspective of
                        \ the viewer, and store them in the following tables in
                        \ the relevant entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)
                        \
                        \ The C flag is set if we have already reached the end
                        \ of the row and can't move any further right

 BCS edge3              \ If we just moved off the right end of the row then the
                        \ right end of the row is visible on-screen, so jump to
                        \ edge3 to set xTileViewRight accordingly and return
                        \ from the subroutine

 BEQ edge2              \ If A = %00000000 then the new tile is not visible, so
                        \ loop back to edge2 to keep moving right

                        \ Otherwise the tile is either visible or off the right
                        \ edge, so fall through into edge3 to set xTileViewRight
                        \ accordingly and return from the subroutine

.edge3

 LDA xTile              \ Store the current column number in xTileViewRight
 STA xTileViewRight

 RTS                    \ Return from the subroutine

.edge4

                        \ If we get here then we keep moving left, updating
                        \ xTileViewRight as we go
                        \
                        \ We keep moving until:
                        \
                        \   * We reach the start of the tile row, in which case
                        \     we jump to edge9 to set xTileViewLeft and return
                        \     from the subroutine
                        \
                        \   * We find a tile that's on-screen, in which case we
                        \     jump to edge4 to update xTileViewRight and keep
                        \     moving left
                        \
                        \   * We find a tile that's off the right of the screen,
                        \     in which case jump to edge9 to set xTileViewLeft
                        \     and return from the subroutine
                        \
                        \   * We find a tile that's off the left of the screen,
                        \     in which case jump to edge7 to move left until we
                        \     find a visible tile or run out of row

 LDA xTile              \ Store the current column number in xTileViewRight
 STA xTileViewRight

 JSR GetTileEdgeToLeft  \ Move one tile to the left and calculate the pitch and
                        \ yaw angles for the tile corner from the perspective of
                        \ the viewer, and store them in the following tables in
                        \ the relevant entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)
                        \
                        \ The C flag is set if we have already reached the start
                        \ of the row and can't move any further left

 BCS edge9              \ If we just moved off the left end of the row then the
                        \ left end of the row is visible on-screen, so jump to
                        \ edge9 to set xTileViewLeft accordingly and return from
                        \ the subroutine

 CMP #%10000000         \ If A = %10000000 then the tile is on-screen, so jump
 BEQ edge4              \ to edge4 to update xTileViewRight and keep moving left

 CMP #%00000000         \ If A = %10000001 then the tile is off the right edge
 JMP edge8              \ of the screen, so jump to edge8 to set xTileViewLeft
                        \ accordingly and return from the subroutine
                        \
                        \ If A = %00000000 then the tile is off the left edge of
                        \ the screen, so jump to edge8 and on to edge7 to move
                        \ left until we find a visible tile or run out of row

.edge5

                        \ If we get here then we keep moving right until:
                        \
                        \   * We find a tile that's on-screen or reach the end
                        \     of the tile row, in which case we jump to edge6 to
                        \     set xTileViewRight and start working left from
                        \     xTileViewLeft until we find a visible tile or run
                        \     out of row

 JSR GetTileEdgeToRight \ Move one tile to the right and calculate the pitch and
                        \ yaw angles for the tile corner from the perspective of
                        \ the viewer, and store them in the following tables in
                        \ the relevant entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)
                        \
                        \ The C flag is set if we have already reached the end
                        \ of the row and can't move any further right

 BCS edge6              \ If we just moved off the right end of the row then the
                        \ right end of the row is visible on-screen, so jump to
                        \ edge3 to set xTileViewRight accordingly and start
                        \ moving left from the current left edge value in
                        \ xTileViewLeft

 BEQ edge5              \ If the new tile is not visible and off to the left of
                        \ the screen then loop back to edge5 to keep moving
                        \ right

                        \ If we get here then we have now found a visible tile
                        \ by moving right, so store that in xTileViewRight and
                        \ start moving left

.edge6

 LDA xTile              \ Store the current column number in xTileViewRight
 STA xTileViewRight

 LDA xTileViewLeft      \ Set xTile to the value of xTileViewLeft so we can
 STA xTile              \ start moving left from this point

.edge7

                        \ If we get here then we keep moving left until:
                        \
                        \   * We find a tile that's on-screen or reach the end
                        \     of the tile row, in which case we set
                        \     xTileViewLeft and return from the subroutine

 JSR GetTileEdgeToLeft  \ Move one tile to the left and calculate the pitch and
                        \ yaw angles for the tile corner from the perspective of
                        \ the viewer, and store them in the following tables in
                        \ the relevant entry for this tile corner:
                        \
                        \   * (drawViewYawHi drawViewYawLo)
                        \
                        \   * (drawViewPitchHi drawViewPitchLo)
                        \
                        \   * tileViewData
                        \
                        \   * tileIsOnScreen (also returned in A and the Z flag)
                        \
                        \ The C flag is set if we have already reached the start
                        \ of the row and can't move any further left

 BCS edge9              \ If we just moved off the left end of the row then the
                        \ left end of the row is visible on-screen, so jump to
                        \ edge9 to set xTileViewLeft accordingly and return from
                        \ the subroutine

.edge8

 BEQ edge7              \ If the new tile is not visible then loop back to edge7
                        \ to keep moving left

.edge9

 LDA xTile              \ Store the current column number in xTileViewLeft
 STA xTileViewLeft

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetTileEdgeToLeft
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Move one tile to the left along the tile row that we are analysing
\             for view edges and tile angles
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   prev1               Return from the subroutine with the C flag set
\
\ ******************************************************************************

.prev1

 SEC                    \ Set the C flag to indicate that we have reached the
                        \ end of the tile row

 RTS                    \ Return from the subroutine

.GetTileEdgeToLeft

 LDY xTile              \ Set Y to the column of the tile corner we are
                        \ currently analysing when looking for the view edges
                        \ and calculating the tile's pitch and yaw angles

 BEQ prev1              \ If Y = 0 then we are already at the left end of the
                        \ tile row and can't move any further left, so jump to
                        \ prev1 to return from the subroutine with the C flag
                        \ set

 DEY                    \ Otherwise decrement Y to move one tile to the left

 JMP GetTileViewAngles  \ Jump to GetTileViewAngles to analyse the new corner to
                        \ look for the view edges and calculate the tile's pitch
                        \ and yaw angles, and return from the subroutine with
                        \ the C flag clear

\ ******************************************************************************
\
\       Name: GetTileEdgeToRight
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Move one tile to the right along the tile row that we are
\             analysing for view edges and tile angles
\
\ ******************************************************************************

.GetTileEdgeToRight

 LDY xTile              \ Set Y to the column of the tile corner we are
                        \ currently analysing when looking for the view edges
                        \ and calculating the tile's pitch and yaw angles

 INY                    \ Increment Y to move one tile to the right

 CPY #32                \ If Y = 32 then we have gone past the end of the tile
 BEQ prev1              \ row and can't move any further tight, so jump to prev1
                        \ to return from the subroutine with the C flag set

                        \ Otherwise fall through into GetTileViewAngles to
                        \ analyse the new corner to look for the view edges and
                        \ calculate the tile's pitch and yaw angles, and return
                        \ from the subroutine with the C flag clear

\ ******************************************************************************
\
\       Name: GetTileViewAngles (Part 1 of 4)
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Calculate the pitch and yaw angles for a tile corner, relative to
\             a viewer object (e.g. the player), and whether it is on-screen
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The tile column of the tile we are analysing, from the
\                       perspective of the viewer
\
\   zTile               The tile row of the tile we are analysing, from the
\                       perspective of the viewer
\
\   drawingTableOffset  Defines where we store the results of the analysis in
\                       the tileViewData, tileViewYaw and tileViewPitch drawing
\                       data tables; each table contains two complete sets of
\                       tile data, with the first table at offset 0 and and the
\                       second table at offset 32, so we store the results
\                       as follows:
\
\                         * 0 = store the results in the first table
\                               e.g. in the 32-byte table at tileViewData
\
\                         * 32 = store the results in the second table
\                               e.g. in the 32-byte table at tileViewData+32
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   tileViewData        Tile data for this tile corner, stored in the relevant
\                       entry for this tile corner
\
\   drawViewYawHi       High byte of the yaw angle, stored in the relevant entry
\                       for this tile corner
\
\   drawViewYawLo       Low byte of the yaw angle, stored in the relevant entry
\                       for this tile corner
\
\   drawViewPitchHi     High byte of the pitch angle, stored in the relevant
\                       entry for this tile corner
\
\   drawViewPitchLo     Low byte of the pitch angle, stored in the relevant
\                       entry for this tile corner
\
\   tileIsOnScreen      Determines whether the tile corner is on-screen (i.e.
\                       within the max and min yaw angle limits):
\
\                         * %00000000 = tile is not on-screen and is past the
\                                       left edge of the screen
\
\                         * %10000000 = tile is on-screen
\
\                         * %10000001 = tile is not on-screen and is past the
\                                       right edge of the screen
\
\   A                   The value of tileIsOnScreen is also returned in A
\
\   Z flag              The Z flag is set according to the value of
\                       tileIsOnScreen, so a BNE or BEQ following the call to
\                       GetTileViewAngles will act accordingly
\
\   C flag              The C flag is clear to indicate that we have not gone
\                       past the end of the tile row, which is used when calling
\                       this routine via GetTileEdgeToLeft or GetTileEdgeToRight
\
\   Y                   Y is preserved
\
\ ******************************************************************************

.GetTileViewAngles

 STY xTile              \ Store the tile column in xTile, so we can analyse the
                        \ tile at (xTile, zTile)

 STY yStoreTileView     \ Store Y in yStoreTileView so it can be preserved
                        \ across calls to the routine

 TYA                    \ Set drawingTableIndex = Y + drawingTableOffset
 ORA drawingTableOffset \
 STA drawingTableIndex  \ So drawingTableIndex is the index into the drawing
                        \ tables for the tile we are analysing

 LDA #0                 \ Set tileIsOnScreen = 0, so the default is that the
 STA tileIsOnScreen     \ tile is not on-screen (we change this in part 3 if it
                        \ is on-screen)

 LDX viewingObject      \ Set X to the number of the object that is viewing the
                        \ landscape

                        \ We start by calculating the difference (the delta) in
                        \ the x-axis between the viewer and the tile we are
                        \ analysing

 LDA #128               \ Set the low byte of (xDeltaHi xDeltaLo) to 128
 STA xDeltaLo

 CLC                    \ Set the high byte of (xDeltaHi xDeltaLo) to the
 LDA xTile              \ following:
 SBC xTileViewer        \
 SEC                    \   xTile - xTileViewer - 1 - xTitleOffset
 SBC xTitleOffset       \
 STA xDeltaHi           \ Note that xTitleOffset is zero during gameplay, and is
                        \ only non-zero when we are drawing large 3D text on the
                        \ title screen, so let's ignore it for now to keep
                        \ things simple
                        \
                        \ Setting the low byte to 128 effectively adds 0.5 to
                        \ the result, so we get this:
                        \
                        \   (xDeltaHi xDeltaLo) = xTile - xTileViewer - 0.5
                        \
                        \ So this is the delta along the x-axis between the
                        \ viewer and the tile that we are analysing

 BPL tang1              \ If the result is positive then jump to tang1 to skip
                        \ the following

 LDA #0                 \ Negate the result to make it positive, so we now have:
 SEC                    \
 SBC xDeltaLo           \   (A xDeltaLo) = |xTile - xTileViewer - 0.5|
 STA xDeltaLo
 LDA #0
 SBC xDeltaHi

.tang1

 STA xDeltaAbsoluteHi   \ Set xDeltaAbsoluteHi = |xDeltaHi|
                        \
                        \ So we now have the absolute z-axis length in:
                        \
                        \   (xDeltaAbsoluteHi xDeltaLo)
                        \
                        \ and the original high byte of the signed x-axis length
                        \ is still in xDeltaHi

                        \ We now do the same thing but for the z-axis, so that
                        \ zDelta contains the difference (the delta) in the
                        \ z-axis between the viewer and the tile we are
                        \ analysing

 LDA #128               \ Set the low byte of (zDeltaHi zDeltaLo) to 128
 STA zDeltaLo

 CLC                    \ Set the high byte of (zDeltaHi zDeltaLo) to the
 LDA zTile              \ following:
 SBC zTileViewer        \
 STA zDeltaHi           \   zTile - zTileViewer - 1
                        \
                        \ Setting the low byte to 128 effectively adds 0.5 to
                        \ the result, so we get this:
                        \
                        \   (zDeltaHi zDeltaLo) = zTile - zTileViewer - 0.5
                        \
                        \ So this is the delta along the z-axis between the
                        \ viewer and the tile that we are analysing

 BPL tang2              \ If the result is positive then jump to tang2 to skip
                        \ the following

 LDA #0                 \ Negate the result to make it positive, so we now have:
 SEC                    \
 SBC zDeltaLo           \   (A zDeltaLo) = |zTile - zTileViewer - 0.5|
 STA zDeltaLo
 LDA #0
 SBC zDeltaHi

.tang2

 STA zDeltaAbsoluteHi   \ Set zDeltaAbsoluteHi = |zDeltaHi|
                        \
                        \ So we now have the absolute z-axis length in:
                        \
                        \   (zDeltaAbsoluteHi zDeltaLo)
                        \
                        \ and the original high byte of the signed z-axis length
                        \ is still in zDeltaHi

                        \ We now have both deltas, so we now can calculate the
                        \ angle of the hypotenuse of the triangle formed by
                        \ these axes, which is the projection of the 3D vector
                        \ from the viewer to the tile down onto the ground plane
                        \ (so imagine a light shining down from above, casting
                        \ the vector's shadow onto the y = 0 plane - that's the
                        \ hypotenuse)

 JSR GetHypotenuseAngle \ Calculate the angle of the hypotenuse in the triangle
                        \ with the following non-hypotenuse sides:
                        \
                        \   * (xDeltaHi xDeltaLo)
                        \
                        \   * (zDeltaHi zDeltaLo)
                        \
                        \ and return the angle in (angleHi angleLo), the tangent
                        \ in angleTangent, the length of the longer side in
                        \ (aHi aLo) and the length of the shorter side in
                        \ (bHi bLo)

                        \ The angle of the hypotenuse is the yaw angle of the
                        \ 3D vector from the viewer to the tile corner we are
                        \ analysing, so store it in the table at (drawViewYawHi
                        \ drawViewYawLo)
                        \
                        \ We also subtract the following:
                        \
                        \   * screenLeftYawHi from the high byte so the result
                        \     is the relative yaw angle from the left edge of
                        \     the screen, so the result is effectively a screen
                        \     x-coordinate where zero is the left screen edge
                        \
                        \   * yawAdjustmentLo from the low byte so ???

 LDY drawingTableIndex  \ Set Y to the drawing table index for this tile

 LDA angleLo            \ Set (drawViewYawHi drawViewYawLo) for this tile to:
 SEC                    \
 SBC yawAdjustmentLo    \   (angleHi angleLo) - (screenLeftYawHi 0)
 STA drawViewYawLo,Y    \                     - (0 yawAdjustmentLo)
                        \
                        \ starting with the low bytes

 LDA angleHi            \ And then the high bytes
 SBC screenLeftYawHi
 STA drawViewYawHi,Y

 JSR GetHypotenuse      \ Calculate the length of the hypotenuse in the triangle
                        \ with side lengths of (aHi aLo) and (bHi bLo) and angle
                        \ angleTangent, which are still set from the call to
                        \ GetHypotenuseAngle above to the values for the 3D
                        \ vector from the viewer to the tile corner we are
                        \ analysing
                        \
                        \ The hypotenuse length is returned in (hypotenuseHi
                        \ hypotenuseLo), so we can use it to calculate the pitch
                        \ angle of the viewer-to-tile vector in part 3

                        \ Fall through into part 2 to start the pitch angle
                        \ calculations

\ ******************************************************************************
\
\       Name: GetTileViewAngles (Part 2 of 4)
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Fetch the tile data for the tile corner we are analysing
\
\ ******************************************************************************

                        \ We have calculated the yaw angle of the vector from
                        \ the viewer to the tile corner we are analysing, so
                        \ now for the pitch angle
                        \
                        \ We start by fetching the tile data for the tile corner
                        \ we are analysing, and for that we need to know the
                        \ tile coordinates in terms of the 3D world, as that's
                        \ how the tileData table is organised
                        \
                        \ The following code sets (X, Y) to the coordinate of
                        \ the tile corner we are analysing, i.e (xTile, zTile),
                        \ but with the axes rotated to match the orientation of
                        \ the 3D world rather than the viewer (as xTile and
                        \ zTile contain the coordinates from the perspective of
                        \ the viewer, not the 3D world)
                        \
                        \ This is the reverse of the process described in part 1
                        \ of the DrawLandscapeView routine, which changes the
                        \ frame of reference from the 3D world to the viewer
                        \
                        \ In that routine, we map the following coordinate
                        \ changes, depending on the direction in which the
                        \ viewer is facing compared to the 3D world's default
                        \ axes:
                        \
                        \    * If the viewer has not turned:
                        \      (x, z) maps to (x, z)
                        \
                        \    * If the viewer has turned right:
                        \      (x, z) maps to (30 - z, x)
                        \
                        \    * If the viewer has turned around:
                        \      (x, z) maps to (30 - x, 30 - z)
                        \
                        \    * If the viewer has turned left:
                        \      (x, z) maps to (z, 30 - x)
                        \
                        \ So we apply the same logic here, but in the reverse
                        \ direction, as we want to move from the viewer's frame
                        \ of reference into the 3D world's frame of reference
                        \
                        \ Note that the logic in DrawLandscapeView subtracts
                        \ from 30, while here we subtract from 31, because this
                        \ logic is working with tile corners, while the logic in
                        \ DrawLandscapeView is working with tiles

 BIT viewingArcRightYaw \ If bit 7 of the quadrant containing the right edge of
 BMI tang4              \ the viewing arc is set, jump to tang4

 BVS tang3              \ If bit 6 of the quadrant containing the right edge of
                        \ the viewing arc is set, jump to tang3

                        \ If we get here then:
                        \
                        \   * Bit 7 of the right edge's quadrant is clear
                        \   * Bit 6 of the right edge's quadrant is clear
                        \
                        \ This means that the right edge of the viewing arc is
                        \ in the 12 o'clock to 3 o'clock quadrant
                        \
                        \ This means that the viewer has not turned, so we can
                        \ use the tile coordinates unchanged

 LDX xTile              \ Set X = xTile

 LDY zTile              \ Set Y = zTile

 JMP tang6              \ Jump to tang6 to keep going

.tang3

                        \ If we get here then:
                        \
                        \   * Bit 7 of the right edge's quadrant is clear
                        \   * Bit 6 of the right edge's quadrant is set
                        \
                        \ This means that the right edge of the viewing arc is
                        \ in the 3 o'clock to 6 o'clock quadrant
                        \
                        \ This means that the viewer has turned right, so we can
                        \ turn left to go back to the 3D world
                        \
                        \ Turning left maps (x, z) maps to (z, 31 - x), so
                        \ that's what we do now

 LDX zTile              \ Set X = zTile

 LDA #31                \ Set Y = 31 - xTile
 SEC
 SBC xTile
 TAY

 JMP tang6              \ Jump to tang6 to keep going

.tang4

                        \ If we get here then bit 7 of the quadrant containing
                        \ the right edge of the viewing arc is set

 BVS tang5              \ If bit 6 of the quadrant containing the right edge of
                        \ the viewing arc is set, jump to tang5

                        \ If we get here then:
                        \
                        \   * Bit 7 of the right edge's quadrant is set
                        \   * Bit 6 of the right edge's quadrant is clear
                        \
                        \ This means that the viewer has turned around, so we
                        \ turn back around to go back to the 3D world
                        \
                        \ Turning around maps (x, z) maps to (31 - x, 31 - z),
                        \ so that's what we do now

 LDA #31                \ Set X = 31 - xTile
 SEC
 SBC xTile
 TAX

 LDA #31                \ Set Y = 31 - zTile
 SEC
 SBC zTile
 TAY

 JMP tang6              \ Jump to tang6 to keep going

.tang5

                        \ If we get here then:
                        \
                        \   * Bit 7 of the right edge's quadrant is set
                        \   * Bit 6 of the right edge's quadrant is set
                        \
                        \ This means that the right edge of the viewing arc is
                        \ in the 9 o'clock to 12 o'clock quadrant
                        \
                        \ This means that the viewer has turned left, so we can
                        \ turn right to go back to the 3D world
                        \
                        \ Turning right maps (x, z) maps to (31 - z, x), so
                        \ that's what we do now

 LDA #31                \ Set X = 31 - xTile
 SEC
 SBC zTile
 TAX

 LDY xTile              \ Set Y = yTile

.tang6

                        \ We now have the tile coordinates for the tile that we
                        \ are analysing, but in 3D world coordinates, so we can
                        \ now fetch the tile data
                        \
                        \ The 3D world coordinates for the tile are in (X, Y),
                        \ so we can fetch the tile data using code that's very
                        \ similar to the GetTileData routine
                        \
                        \ In the following comments I will refer to (X, Y) as
                        \ (xTile, zTile), just as in GetTileData, as that's a
                        \ bit easier to follow than X and Y

 STY T                  \ Store zTile in T, so we can use it in the following
                        \ calculation

 TXA                    \ Set Y = (xTile << 3 and %11100000) + zTile
 ASL A                  \       = (xTile >> 2 and %00000111) << 5 + zTile
 ASL A                  \       = (xTile div 4) * &20 + zTile
 ASL A
 AND #%11100000
 ORA T
 TAY

 TXA                    \ Set A = bits 0-1 of xTile
 AND #%00000011         \       = xTile mod 4

 STA T                  \ Store A in T so we can use it in part 3 to calculate
                        \ the address of the tila's visibility bit

                        \ The low byte of tileDataPage(1 0) gets set to zero in
                        \ ResetVariables and is never changed
                        \
                        \ The low byte of tileData is also zero, as we know that
                        \ tileData is &0400
                        \
                        \ So in the following, we are just adding the high bytes
                        \ to get a result that is on a page boundary

 CLC                    \ Set the following:
 ADC #HI(tileData)      \
 STA tileDataPage+1     \   tileDataPage(1 0) = tileData + (A 0)
                        \                     = tileData + (xTile mod 4) * &100

                        \ So we now have the following:
                        \
                        \   tileDataPage(1 0) = tileData + (xTile mod 4) * &100
                        \
                        \   Y = (xTile div 4) * &20 + zTile
                        \
                        \ The address in tileDataPage(1 0) is the page within
                        \ tileData for the tile anchored at (xTile, zTile), and
                        \ is always one of &0400, &0500, &0600 or &0700 because
                        \ (xTile mod 4) is one of 0, 1, 2 or 3
                        \
                        \ The value of Y is the offset within that page of the
                        \ tile data for the tile anchored at (xTile, zTile)
                        \
                        \ We can therefore fetch the tile data for the specified
                        \ tile using Y as an index offset from tileDataPage(1 0)

 LDA (tileDataPage),Y   \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 LDX drawingTableIndex  \ Store the tile data in the correct place in the
 STA tileViewData,X     \ tileViewData table

                        \ Fall through into part 3 to finish the pitch angle
                        \ calculations

\ ******************************************************************************
\
\       Name: GetTileViewAngles (Part 3 of 4)
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Calculate the pitch angle for the tile corner
\
\ ******************************************************************************

                        \ By this point, A contains the tile data for the tile
                        \ we are analysing and Y contains the index offset of
                        \ the tile data from tileDataPage(1 0)

 CMP #%11000000         \ If both bits 6 and 7 are set in the tile data then the
 BCC tang8              \ tile we are analysing contains an object, in which
                        \ case keep going, otherwise there is no object on the
                        \ tile so jump to tang8

.tang7

                        \ If we get here then the tile we are analysing contains
                        \ an object and the tile data is in A

 AND #%00111111         \ Because the tile has an object on it, the tile data
 TAY                    \ contains the number of the top object on the tile in
                        \ bits 0 to 5, so extract the object number into Y (so
                        \ the tile effectively contains object #Y)

 LDA objectFlags,Y      \ Set A to the object flags for the object on the tile

 CMP #%01000000         \ If bit 6 of the object flags for object #Y is set
 BCS tang7              \ then object #Y is stacked on top of another object,
                        \ and that object number is in bits 0 to 5 of the object
                        \ flags, so jump to tang7 to extract that object number
                        \ from A and check the flags again (so this works down
                        \ through the stack of objects until we reach the object
                        \ at the bottom of the stack)

 LDA yObjectHi,Y        \ Bt this point we have reached the object on the tile
 STA U                  \ itself, so set U to the y-coordinate of that object,
                        \ which will be the tile altitude, and return from the
                        \ subroutine with the C flag clear to denote a flat
                        \ tile, as objects are only ever placed on flat tiles

 JMP tang9              \ Jump to tang9 to keep going, leaving the tile's entry
                        \ in the tileViewData table alone (so it still contains
                        \ the tile data that we stored in part 2)

.tang8

                        \ If we get here then the tile we are analysing does not
                        \ contain an object and the tile data is in A, with Y
                        \ containing the index offset of the tile data from
                        \ tileDataPage(1 0)
                        \
                        \ From part 2, we have:
                        \
                        \   * T = bits 0-1 of xTile
                        \
                        \   * Y = (xTile div 4) * &20 + zTile

 LSR A                  \ The high nibble of the tile data contains the altitude
 LSR A                  \ of the tile's anchor, so shift this into U
 LSR A
 LSR A
 STA U

                        \ We now fetch the tile's visiblility bit from the
                        \ tileVisibility table, using the reverse of the logic
                        \ in the GetTileVisibility routine for calculating the
                        \ address of the visiblility bit

 TYA                    \ Shift Y right by one place, so the C flag is set to
 LSR A                  \ bit 0 of zTile (the row number), and Y contains the
 TAY                    \ following:
                        \
                        \   * Bits 4 to 6 contain bits 2 to 4 of xTile (the
                        \     column number)
                        \
                        \   * Bits 0 to 3 contain bits 1 to 4 of zTile (the
                        \     row number)
                        \
                        \ This therefore gives us the offset in the visibility
                        \ table for the tile's visibility byte, as per the
                        \ GetTileVisibility routine

 ROL T                  \ In part 2 we set T to bits 0-1 of xTile (the column
                        \ number), so this sets T as follows:
                        \
                        \    * Bit 0 contains bit 0 of the of the tile row in
                        \      zTile (via the C flag from above)
                        \
                        \    * Bits 1-2 contain bits 0-1 of the column number in
                        \      xTile
                        \
                        \ This therefore gives us the bit number within the byte
                        \ in the visibility table for the tile's visibility, as
                        \ per the GetTileVisibility routine

 LDA tileVisibility,Y   \ Set A to the visibility byte that contains the
                        \ visibility bit for this tile

 LDY T                  \ Fetch the Y-th bit from the visibility byte, which
 AND visibileBitMask,Y  \ contains the specific visibility bit for this tile

 BNE tang9              \ If the visibility bit is set then A will be non-zero,
                        \ so skip the following instruction, leaving the entry
                        \ for this tile to contain the non-zero tile data that
                        \ we stored in tileViewData,X at the end of part 2

 STA tileViewData,X     \ The visibility bit is zero, so zero the entry in the
                        \ tileViewData table for this tile (which otherwise
                        \ would contain the tile data that we set in part 2)

.tang9

 LDX viewingObject      \ Set X to the number of the object that is viewing the
                        \ landscape

 LDA #0                 \ Set (A xDeltaLo) = (U 0) - y-coordinate of object #X
 SEC                    \
 SBC yObjectLo,X        \ We set U above to the altitude of the tile that we are
 STA xDeltaLo           \ analysing, so (A xDeltaLo) now contains the vertical
 LDA U                  \ distance between the viewer and the tile we are
 SBC yObjectHi,X        \ analysing, ready to pass to GetPitchAngleDelta

 JSR GetPitchAngleDelta \ Set (pitchDeltaHi pitchDeltaLo) to the pitch angle of
                        \ the vector relative to the viewer's pitch angle
                        \
                        \ The vector in question has x- and z-axis elements from
                        \ part 1:
                        \
                        \   * (xDeltaHi xDeltaLo)
                        \
                        \   * (zDeltaHi zDeltaLo)
                        \
                        \ and we calculated the (hypotenuseHi hypotenuseLo) for
                        \ this in part 1
                        \
                        \ The vector also has y-axis element of (A xDeltaLo),
                        \ which we just calculated
                        \
                        \ So this call calculates the relative pitch angle for
                        \ the vector between the viewer and the tile that we are
                        \ analysing, so store it in the correct entry in the
                        \ table at (drawViewPitchHi drawViewPitchLo)

 LDY drawingTableIndex  \ Set Y to the drawing table index for this tile

 LDA pitchDeltaHi       \ Store the high byte of the pitch vector in the correct
 STA drawViewPitchHi,Y  \ part of the drawViewPitchHi table

 LDA pitchDeltaLo       \ Store the low byte of the pitch vector in the correct
 STA drawViewPitchLo,Y  \ part of the drawViewPitchLo table

                        \ Fall through into part 4 to work out how much of the
                        \ tile is on-screen

\ ******************************************************************************
\
\       Name: GetTileViewAngles (Part 4 of 4)
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Calculate how much of the tile is on-screen
\
\ ******************************************************************************

                        \ By this point we have pitch and yaw angles for the
                        \ vector between the viewer and the tile that we are
                        \ analysing, relative to the viewing gaze, so we now
                        \ need to work out the value of tileIsOnScreen to return
                        \
                        \ We set tileIsOnScreen to zero at the start of the
                        \ routine, to indicate that the tile is not on-screen
                        \
                        \ We now set the following bits if applicable:
                        \
                        \   * Set bit 7 when tileViewYaw >= minYawAngle
                        \
                        \   * Set bit 0 when drawViewYawHi >= maxYawAngleHi
                        \
                        \ where tileViewYaw is (drawViewYawHi drawViewYawLo)
                        \ and minYawAngle is (minYawAngleHi minYawAngleLo)
                        \
                        \ So bit 7 is set when the tile corner is inside the
                        \ minimum yaw limit, and bit 0 is set when the tile
                        \ corner is inside (but not on) the maximum yaw limit
                        \
                        \ If the yaw limit is the screen size, then the two bits
                        \ determine whether the tile is on-screen

 LDA drawViewYawHi,Y    \ If drawViewYawHi < minYawAngleHi, jump to tang11 to
 CMP minYawAngleHi      \ return with tileIsOnScreen = 0, as the tile is off the
 BCC tang11             \ left of the screen edge

 BNE tang10             \ If drawViewYawHi > minYawAngleHi, jump to tang10 with
                        \ the C flag set to set bit 7 of tileIsOnScreen

                        \ If we get here then drawViewYawHi = minYawAngleHi, so
                        \ we now check the low bytes

 LDA drawViewYawLo,Y    \ If drawViewYawLo < minYawAngleLo, jump to tang11 to
 CMP minYawAngleLo      \ return with tileIsOnScreen = 0
 BCC tang11

 LDA drawViewYawHi,Y    \ If we get here then drawViewYawLo >= minYawAngleLo, so
                        \ the C flag is set, and we set A to drawViewYawHi for
                        \ the comparison below

.tang10

                        \ If we get here then the C flag is set, as we have to
                        \ pass through a BCC to get here

 ROR tileIsOnScreen     \ Set bit 7 of tileIsOnScreen, so bit 7 is set if the
                        \ tile is on or to the right of the minimum yaw limit,
                        \ i.e. to the right of the left edge of the screen

 CMP maxYawAngleHi      \ If drawViewYawHi < maxYawAngleHi, jump to tang11 to
 BCC tang11             \ return from the routine with bit 0 of tileIsOnScreen
                        \ clear

                        \ If we get here then drawViewYawHi >= maxYawAngleHi,
                        \ so the tile is off-screen to the right

 INC tileIsOnScreen     \ Set bit 0 of tileIsOnScreen to indicate that the tile
                        \ is to the right of the maximum yaw limit, i.e. to the
                        \ right of the right edge of the screen

.tang11

 LDY yStoreTileView     \ Restore Y so that it's preserved

 LDA tileIsOnScreen     \ Set A to the value of tileIsOnScreen, to return from
                        \ the subroutine

 CLC                    \ Clear the C flag to indicate that we have not gone
                        \ past the end of the tile row, which is used when
                        \ calling this routine via GetTileEdgeToLeft or
                        \ GetTileEdgeToRight

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawLandscapeRow
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Draw a row of tiles between the left visible edge and the right
\             visible, in two parts towards each side of the viewer
\
\ ******************************************************************************

.DrawLandscapeRow

 LDA xTileViewLeftEdge  \ Set xTileToDraw to the column number of the tile at
 STA xTileToDraw        \ the left edge of the visible row we want to draw

.draw1

 CMP xTileViewRightEdge \ If we have gone past the right edge, jump to draw4 to
 BCS draw4              \ return from the subroutine

 CMP xTileViewer        \ If we have gone past the viewer's tile column, jump to
 BCS draw2              \ draw2 to draw the second half

 JSR DrawTileAndObjects \ Draw the tile and any objects stacked on it

 INC xTileToDraw        \ Increment the column number to move right along the
                        \ row

 LDA xTileToDraw        \ Set A to the updated column number of the tile we want
                        \ to draw

 JMP draw1              \ Loop back to draw1 the next tile to the right until we
                        \ reach the viewer's tile column or reach the end of the
                        \ row

.draw2

 LDA xTileViewRightEdge \ Set A to the column number of the tile at the right
                        \ edge of the visible row we want to draw

.draw3

 SEC                    \ Decrement the column counter in A to move left along
 SBC #1                 \ the row

 BMI draw4              \ If we have reached the start of the row, jump to draw4
                        \ to return from the subroutine

 STA xTileToDraw        \ Store the updated column number of the tile we want to
                        \ draw

 CMP xTileViewLeftEdge  \ If we have gone past the left edge, jump to draw4 to
 BCC draw4              \ return from the subroutine

 CMP xTileViewer        \ If we have gone past the viewer's tile column, jump to
 BCC draw4              \ draw4 to return from the subroutine

 JSR DrawTileAndObjects \ Draw the tile and any objects stacked on it

 LDA xTileToDraw        \ Set A to the column number of the tile we just drew

 JMP draw3              \ Loop back to draw1 the next tile to the left until we
                        \ reach the viewer's tile column or reach the end of the
                        \ row

.draw4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FlipBufferType
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Flip the buffer type between buffer type 0 (left row buffer) and
\             buffer type 1 (right row buffer)
\
\ ******************************************************************************

.FlipBufferType

 LDA screenBufferType   \ Flip bit 0 of screenBufferType to swap between buffer
 AND #1                 \ type 0 (left row buffer) and buffer type 1 (right row
 EOR #1                 \ buffer)

                        \ Fall through into ConfigureBuffer to configure the new
                        \ buffer type

\ ******************************************************************************
\
\       Name: ConfigureBuffer
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Set up the variables required to configure the screen buffer to a
\             specific buffer type
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The type of buffer to configure:
\
\                         * 0 = left row buffer (for up/down pan)
\                               for the first 256 bytes of the 320-byte row
\
\                         * 1 = right row buffer (for up/down pan)
\                               for the last 64 bytes of the 320-byte row
\
\                         * 2 = column buffer (for left/right pan)
\
\ ******************************************************************************

.ConfigureBuffer

 STA screenBufferType   \ Set screenBufferType to the new buffer type

 TAY                    \ Copy the buffer type into Y so we can use it as an
                        \ index into the various buffer configuration tables

 LDA minBufferYaw,Y     \ Set the high byte of (minYawAngleHi minYawAngleLo) to
 STA minYawAngleHi      \ 20 or 8 ???

 LSR A                  \ Set maxYawAngleHi = 138 or 132
 EOR #%10000000         \                   = -118 or -124
 STA maxYawAngleHi      \ ???

 LDA L298B,Y            \ Set L0011 to 10, 2, or 12 ???
 STA L0011              \ Gets added to drawViewYawHi in sub_C2D36 ???

 LDA L2991,Y            \ Set L0061 to 112, 112 or 64 ???
 STA L0061              \ 112 = 14 * 8, 64 = 8 * 8

 LDA L298E,Y            \ Set L0035 to 80, 64, 96 ???
 STA L0035              \ Gets subtracted from values in L5B00 or L5A00 ???

 CLC                    \ Set L0036 = L0035 + L0061
 ADC L0061              \
 STA L0036              \ i.e. 80 + 112
                        \      64 + 112
                        \      96 + 64 ???

 LDA #0                 \ Zero the low byte of (minYawAngleHi minYawAngleLo)
 STA minYawAngleLo

 STA L0029              \ Set L0029 = 0 ???

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: L298B
\       Type: Variable
\   Category: Screen buffer
\    Summary: ???
\
\ ******************************************************************************

.L298B

 EQUB 10                \ Left row buffer ???

 EQUB 2                 \ Right row buffer ???

 EQUB 12                \ Column buffer ???

\ ******************************************************************************
\
\       Name: L298E
\       Type: Variable
\   Category: Screen buffer
\    Summary: ???
\
\ ******************************************************************************

.L298E

 EQUB 80                \ Left row buffer ???

 EQUB 64                \ Right row buffer ???

 EQUB 96                \ Column buffer ???

\ ******************************************************************************
\
\       Name: L2991
\       Type: Variable
\   Category: Screen buffer
\    Summary: ???
\
\ ******************************************************************************

.L2991

 EQUB 112               \ Left row buffer ???

 EQUB 112               \ Right row buffer ???

 EQUB 64                \ Column buffer ???

\ ******************************************************************************
\
\       Name: minBufferYaw
\       Type: Variable
\   Category: Screen buffer
\    Summary: Minimum allowed yaw angles for points in the screen buffer
\
\ ******************************************************************************

.minBufferYaw

 EQUB 20                \ Left row buffer contains yaw angles up to 20

 EQUB 20                \ Right row buffer contains yaw angles up to 20

 EQUB 8                 \ Column buffer contains yaw angles up to 8

\ ******************************************************************************
\
\       Name: sub_C2997
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   CRE17               Contains an RTS
\
\ ******************************************************************************

.sub_C2997

 STA T
 LSR A
 STA minYawAngleHi
 LDA #0
 ROR A
 STA minYawAngleLo
 LDA minYawAngleHi
 LSR A
 EOR #&80
 STA maxYawAngleHi
 LDA T
 ASL A
 ASL A
 STA L0061
 LSR A
 AND #&FC
 ORA #&80
 STA L0036
 SEC
 SBC L0061
 STA L0035
 LSR A
 LSR A
 LSR A
 STA L0011
 LDA #0
 ROR A
 STA L0029
 LDA #&02
 STA screenBufferType

.CRE17

 RTS

\ ******************************************************************************
\
\       Name: DrawTileAndObjects
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Draw a tile and any objects stacked on it
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   xTileToDraw         The tile x-coordinate (i.e. the tile column)
\
\   zTile               The tile z-coordinate (i.e. the tile row)
\
\ ******************************************************************************

.tobj1

                        \ If we get here then we need to draw a block in the
                        \ title screen's 3D text
                        \
                        \ We use object #63 for this purpose, and we set it to
                        \ the object number for the 3D text block pair that the
                        \ SpawnCharacter3D put into bits 0 to 3 of the tile data

 LDA tileViewData,X     \ Set the object type for object #63 to the bottom
 AND #%00001111         \ nibble of the tile data, which contains the object
 STA objectTypes+63     \ number for the 3D text block pair for this part of the
                        \ text:
                        \
                        \   * 0 for no blocks in the pair
                        \
                        \   * 7 for no block (left), block (right)
                        \
                        \   * 8 for block (left), no block (right)
                        \
                        \   * 9 for block (left), no block (right)

 BEQ CRE17              \ If the object type is zero then jump to CRE17 to
                        \ return from the subroutine without drawing anything

                        \ Otherwise we have set the type of object #63 to the
                        \ correct 3D text block object, so now we set the tile
                        \ coordinate and draw the object

 LDA xTileToDraw        \ Set the x-coordinate for the block in object #63 to
 STA xObject+63         \ the tile column in xTileToDraw

 LDA zTile              \ Set the z-coordinate for the block in object #63 to
 STA zObject+63         \ the tile row in zTile

 LDY #63                \ Set Y = 63 to pass to the DrawObject routine so we
                        \ draw object #63

 JMP DrawObject         \ Jump to DrawObject to draw the 3D text block we've set
                        \ up in object #63, returning from the subroutine using
                        \ a tail call

.DrawTileAndObjects

 JSR ProcessSound       \ Process any sounds or music that are being made in the
                        \ background

 LDA xTileToDraw        \ Set X to the index of the tile data that we set up for
 ORA drawingTableOffset \ this tile in part 2 of the GetTileViewAngles routine
 CLC                    \ ???
 ADC quadrantOffset
 AND #%00111111
 TAX

 BIT drawingTitleScreen \ If bit 7 of drawingTitleScreen is set then we are
 BMI tobj1              \ drawing a title screen, so jump up to tobj1 to draw
                        \ this tile as a block in the title screen's 3D text

 LDA tileViewData,X     \ Set A to the tile data for the current view, which we
                        \ set in the GetTileViewAngles routine to the tile data
                        \ for this tile, but zeroed if the tile is not visible
                        \ (which will happen if the tile does not contain an
                        \ object and is marked as not being visible from the
                        \ player's point of view in the tileVisibility table)

 BEQ CRE17              \ If A is zero then we marked this tile as being hidden
                        \ in part 3 of the GetTileViewAngles routine, so jump to
                        \ CRE17 to return from the subroutine without drawing
                        \ anything

 CMP #%11000000         \ If both bits 6 and 7 are set in the tile data then the
 BCC tobj2              \ tile we are analysing contains an object, in which
                        \ case keep going, otherwise there is no object on the
                        \ tile so jump to tobj2

                        \ If we get here then the tile we are drawing contains
                        \ an object

 PHA                    \ Store the tile data on the stack

 JSR DrawFlatTile       \ Draw the flat tile that's beneath the object

 PLA                    \ Retrieve the tile data from the stack

 JMP DrawObjectStack    \ Draw the stack of objects on top of the tile, and
                        \ return from the subroutine using a tail call

.tobj2

                        \ If we get here then the tile we are drawing does not
                        \ contain an object

 AND #%00001111         \ Set A to the tile shape for the tile, which is in the
                        \ bottom nibble of the tile data

 BEQ DrawFlatTile       \ If the tile shape is zero then the tile is flat, so
                        \ jump to DrawFlatTile to draw the flat tile, returning
                        \ from the subroutine using a tail call

 CMP #12                \ If the tile shape is 12 then we know the tile consists
 BEQ tobj3              \ of two faces, so jump to tobj3

 CMP #4                 \ If the tile shape is 4 then we know the tile consists
 BNE DrawSlopingTile    \ of two faces, so keep going, otherwise we don't know
                        \ how many faces it contains, so jump to DrawSlopingTile
                        \ to work this out

.tobj3

                        \ If we get here then the tile shape is 4 or 12, both of
                        \ which we know consist of two triangular faces

 PHA                    \ Store the tile shape on the stack

 LDA viewingQuadrantOpp \ Set L0045 to bit 0 of viewingQuadrantOpp to pass to
 AND #1                 \ the DrawTwoFaceTile routine ???
 STA L0045

 PLA                    \ Retrieve the tile shape from the stack

 BNE DrawTwoFaceTile    \ Jump to DrawTwoFaceTile to draw the tile, returning
                        \ from the subroutine using a tail call (this BNE is
                        \ effectively a JMP as we know the tile shape is
                        \ non-zero)

\ ******************************************************************************
\
\       Name: DrawFlatTile
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Draw a flat tile in the correct colour for the chess board effect
\             that we use to draw the landscape
\
\ ******************************************************************************

.DrawFlatTile

 LDX #0                 \ If bit 0 of xTileToDraw and zTile are the same, then
 LDA xTileToDraw        \ the tile's x-coordinate and z-coordinate are either
 EOR zTile              \ both odd or both even, so jump to DrawOneFaceTile
 AND #1                 \ with X set to 0 to draw this tile in colour 3 (white,
 BEQ DrawOneFaceTile    \ yellow, cyan or red)

 LDX #8                 \ Otherwise the tile's x-coordinate and z-coordinate are
                        \ different (i.e. one is odd and one is even), so set
                        \ X to 8 to draw this tile in colour 0 (blue)

                        \ We now have a very short interlude to set the value of
                        \ stashOffset as part of the game's anti-cracker code,
                        \ and we pick up the tile-drawing process again in the
                        \ DrawOneFaceTile routine

\ ******************************************************************************
\
\       Name: SetSecretStash
\       Type: Subroutine
\   Category: Cracker protection
\    Summary: Alter the secret code stash, as part of the anti-cracker code
\
\ ******************************************************************************

.SetSecretStash

                        \ This routine sets the value of stashOffset, which is
                        \ the offset into the secretCodeStash where we store a
                        \ set of generated values for later checking in the
                        \ GetRowVisibility routine
                        \
                        \ The offset is set to the middle byte from the
                        \ landscape seed linear feedback shift register (LFSR),
                        \ overwriting previous values until we get here for the
                        \ last time
                        \
                        \ As we only reach this routine when drawing flat tiles
                        \ in colour 0, so stashOffset is set to the middle byte
                        \ from the landscape seed linear feedback shift register
                        \ for the last flat colour 0 tile to be drawn
                        \
                        \ The value itself doesn't matter, it's just another way
                        \ of throwing crackers off the trail of working out how
                        \ to generate landscape codes, as it changes the address
                        \ of the secret code stash for each landscape

 LDA seedNumberLFSR+2-8,X   \ At this point, X = 8 from DrawFlatTile, so this
 STA stashOffset-8,X        \ sets the following:
                            \
                            \   stashOffset = seedNumberLFSR+2

                        \ seedNumberLFSR+2 is the middle byte of the LFSR at
                        \ seedNumberLFSR(4 3 2 1 0), so this sets the secret
                        \ code stash offset to a unique and consistent value for
                        \ each landscape

                        \ Fall through into DrawOneFaceTile to finish drawing
                        \ the flat tile

\ ******************************************************************************
\
\       Name: DrawOneFaceTile
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Draw a tile with one quadrilateral (four-sided) face
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The reference shape to use when picking the tile's
\                       colour from the tileShapeColour table
\
\ ******************************************************************************

.DrawOneFaceTile

 LDA tileShapeColour,X  \ Set polygonColours to the entry for the reference shape
 STA polygonColours     \ from the tileShapeColour or tileShapeColour+16 table,
                        \ so we draw the polygon in the correct colour

 LDA #%00000000         \ Clear bits 6 and 7 of polygonType so the following
 STA polygonType        \ call to DrawPolygon draws a quadrilateral tile face

 JMP DrawPolygon        \ Jump to DrawPolygon to draw the quadrilateral and
                        \ return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: DrawSlopingTile
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Draw a sloping tile that is not shape 4 or 12
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The shape of the tile to draw (not 0, 4 or 12)
\
\ ******************************************************************************

.DrawSlopingTile

 TAX                    \ Set X to the tile shape so we can retrieve it later

 SEC                    \ Set Y = (A - viewingQuadrantx4) mod 16
 SBC viewingQuadrantx4  \
 AND #%00001111         \ Tiles are grouped into four groups, so this sets the
 TAY                    \ correct group for the orientation of the viewer
                        \
                        \ In other words, this makes the shape numbers relative
                        \ to the viewer's orientation, so we can set the correct
                        \ colours for the shape's faces
                        \
                        \ Specifically, it realigns the following tile shape
                        \ numbers so that the numbering starts in the quadrant
                        \ where the player is facing:
                        \
                        \   1    0 0            Y = 1-3 when facing 12 o'clock
                        \        1 1              = 5-7 when facing 9 o'clock
                        \                         = 9-11 when facing 6 o'clock
                        \   2    1 1              = 13-15 when facing 3 o'clock
                        \        0 1
                        \
                        \   3    1 0
                        \        1 1
                        \
                        \
                        \   5    1 0            Y = 1-3 when facing 3 o'clock
                        \        1 0              = 5-7 when facing 12 o'clock
                        \                         = 9-11 when facing 9 o'clock
                        \   6    1 0              = 13-15 when facing 6 o'clock
                        \        0 0
                        \
                        \   7    1 1
                        \        1 0
                        \
                        \
                        \   9    1 1            Y = 1-3 when facing 6 o'clock
                        \        0 0              = 5-7 when facing 3 o'clock
                        \                         = 9-11 when facing 12 o'clock
                        \   10   0 1              = 13-15 when facing 9 o'clock
                        \        0 0
                        \
                        \   11   0 0
                        \        1 0
                        \
                        \
                        \   13   0 1            Y = 1-3 when facing 9 o'clock
                        \        0 1              = 5-7 when facing 6 o'clock
                        \                         = 9-11 when facing 3 o'clock
                        \   14   0 0              = 13-15 when facing 12 o'clock
                        \        0 1
                        \
                        \   15   0 1
                        \        1 1
                        \
                        \ We use this value below when calculating the colours
                        \ of the two faces in two-face tiles

 AND #%00000011         \ If Y mod 4 = 1 then the tile shape is the first shape 
 CMP #%00000001         \ in one of the groups above, so it's a single sloping
 BEQ DrawOneFaceTile    \ face from one horizontal edge to another, so jump to
                        \ DrawOneFaceTile to draw this one-face tile

                        \ If we get here then the tile shape is the second or
                        \ third shape in one of the groups above, so one corner
                        \ is a different altitude to the othes
                        \
                        \ We now use the value of Y to pick the correct value
                        \ for L0045 and the correct tileShapeColour table offset
                        \ for the tile colour, so we can pass them to
                        \ DrawTwoFaceTile to draw the tile

 LDA L2D03,Y            \ Set L0045 = 1 for Y = 6, 7, 14, 15 ???
 STA L0045              \             0 for Y = 2, 3, 10, 11

 TXA                    \ Set A = 1 for tile shapes 6, 7, 14, 15
 AND #%00000100         \         0 for tile shapes 2, 3, 10, 11
 LSR A
 LSR A

 CLC                    \ Set C flag if viewingQuadrantOpp = 1 and A = 1
 ADC viewingQuadrantOpp \            or viewingQuadrantOpp = 2
 CMP #2                 \            or viewingQuadrantOpp = 3
                        \
                        \ Clear C flag if viewingQuadrantOpp = 0
                        \              or viewingQuadrantOpp = 1 and A = 0

 TXA                    \ Set A to the tile shape to pass to DrawTwoFaceTile

 BCS DrawTwoFaceTile    \ Add 16 to the tile shape if the C flag is clear ???
 ORA #16

                        \ Fall through into DrawTwoFaceTile to draw the tile
                        \ with two triangular (three-sided) faces

\ ******************************************************************************
\
\       Name: DrawTwoFaceTile
\       Type: Subroutine
\   Category: Drawing the landscape
\    Summary: Draw a tile with two triangular (three-sided) faces
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The shape of the tile to draw, amended to use as an
\                       offset into the tileShapeColour table ???
\
\                       Add 16 if either of these is true, so we use the colours
\                       from tileShapeColour+16:
\
\                         * viewingQuadrantOpp = 0
\
\                         * viewingQuadrantOpp = 1, shape = 2, 3, 10, 11
\
\   L0045               Set to 0 or 1 ???
\
\                         * For shapes 4 or 12 = bit 0 of viewingQuadrantOpp
\
\                         * Otherwise:
\
\                           * 1 for shapes 6, 7, 14, 15 (viewer-relative)
\
\                           * 0 for all other shapes
\
\ ******************************************************************************

.DrawTwoFaceTile

 STA L0034              \ Set L0034 to the tile shape, amended to use as an
                        \ offset into the tileShapeColour table

 TAX                    \ Set X to the tile shape so we can use it as an index
                        \ into the tileShapeColour table

 LDA #%10000000         \ Set bit 7 and clear bit 6 of polygonType so the call
 STA polygonType        \ to DrawPolygon draws the first triangle in the tile
                        \ face

 LDA tileShapeColour,X  \ Set polygonColours to the entry for this shape from
 STA polygonColours     \ the tileShapeColour or tileShapeColour+16 table, so ww
                        \ draw the first polygon in the correct colour

 JSR DrawPolygon        \ Draw the first trianglar face

 LDA L0034              \ Set polygonColours to the entry for this shape from
 EOR #16                \ the other tileShapeColour table (so if the previous
 TAX                    \ colour was from tileShapeColour then we pick the next
 LDA tileShapeColour,X  \ colour from tileShapeColour+16)
 STA polygonColours

 LDA polygonType        \ Set bit 6 of polygonType so both bits 6 and 7 are set,
 ORA #%01000000         \ so the call to DrawPolygon draws the second triangle
 STA polygonType        \ in the tile face

                        \ Fall into DrawPolygon to draw the second trianglar
                        \ face

\ ******************************************************************************
\
\       Name: DrawPolygon
\       Type: Subroutine
\   Category: Drawing polygons
\    Summary: ???
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   L0034               The tile shape, amended to use as an offset into the
\                       tileShapeColour table
\
\   polygonType         Bits 6 and 7 determine the type of polygon to draw (the
\                       calling subroutine is in brackets)
\
\                         * %00xxxxxx = quadrilateral (DrawOneFaceTile)
\
\                         * %01xxxxxx = object polygon (DrawObject)
\
\                         * %10xxxxxx = first triangle (DrawTwoFaceTile)
\
\                         * %11xxxxxx = second triangle (DrawTwoFaceTile)
\
\   screenBufferType    The type of buffer to use:
\
\                         * 0 = left row buffer (for up/down pan)
\                               for the first 256 bytes of the 320-byte row
\
\                         * 1 = right row buffer (for up/down pan)
\                               for the last 64 bytes of the 320-byte row
\
\                         * 2 = column buffer (for left/right pan)
\
\   drawViewAngles(1 0) The point data:
\
\                         * When drawing tile faces, this points to L0C40 ???
\
\                         * When drawing object polygons, this points to a list
\                           of object-relative numbers of polygon points
\
\ ******************************************************************************

.DrawPolygon

 LDY screenBufferType   \ If screenBufferType >= 2 then we must be drawing into
 CPY #2                 \ the column buffer, so jump to poly2 ???
 BCS poly2

 JSR sub_C2D36          \ Seems to check something to do with drawing ???

 BCS poly1              \ If the call to sub_C2D36 set the C flag then ???, so
                        \ jump to poly1 to skip the following

 JSR sub_C2299          \ Seems to do the actual drawing ???

 LDY screenBufferType   \ screenBufferType is 0 or 1, so this must be ???, so
 LDA L002C,Y            \ set A = L002C or L002D

 CMP #1                 \ If L002C or L002D = 1, jump to poly3 to return from
 BEQ poly3              \ the subroutine

.poly1

 JSR FlipBufferType     \ Flip the buffer type between 0 and 1 and set lots of
                        \ variables accordingly ???

.poly2

 JSR sub_C2D36          \ Seems to check something to do with drawing ???

 BCS poly3              \ If the call to sub_C2D36 set the C flag then ???, so
                        \ jump to poly3 to return from the subroutine

 JSR sub_C2299          \ Seems to do the actual drawing ???

.poly3

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GenerateLandscape
\       Type: Subroutine
\   Category: Landscape
\    Summary: Generate tile data for the landscape
\
\ ------------------------------------------------------------------------------
\
\ This routine populates the tileData table with tile data for each of the tile
\ corners in the landscape. The landscape consists of 31x31 square tiles, made
\ up of a 32x32 grid of tile corners.
\
\ One byte of tile data is generated for each tile corner in the landscape. Each
\ byte of tile data contains two pieces of information:
\
\   * The low nibble of each byte contains the tile shape, which describes the
\     layout and structure of the landscape on that tile.
\
\   * The high nibble of each byte contains the altitude of the tile corner in
\     the front-left corner of the tile (i.e. the corner closest to the
\     landscape origin). We call this tile corner the "anchor".
\
\ As each tile is defined by a tile corner and a shape, we tend to use the terms
\ "tile" and "tile corner" interchangeably, depending on the context. That said,
\ for tile corners along the furthest back and rightmost edges of the landscape,
\ the shape data is ignored, as there is no landscape beyond the edges.
\
\ See the GetTileShape routine for information on the different types of tile
\ shape.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   doNotPlayLandscape  Controls how we return from the subroutine:
\
\                         * If bit 7 is set, return from the subroutine normally
\
\                         * If bit 7 is clear, jump to PreviewLandscape once the
\                           landscape is generated
\
\ ******************************************************************************

.GenerateLandscape

                        \ We start by generating 81 seed numbers, though these
                        \ are ignored (with one exception)
                        \
                        \ These numbers get stored in the stripData table, from
                        \ stripData+80 down to stripData+0, but there's no
                        \ specific reason for this - they could just as easily
                        \ be discarded
                        \
                        \ The purpose of this step is to get the seed number
                        \ generator to a point where the output is predictable
                        \ and stable, so that every time we generate a sequence
                        \ of seed numbers for a landscape, they are exactly the
                        \ same each time while being unique to that landscape
                        \ number
                        \
                        \ That said, the third seed number that's generated and
                        \ stored at stripData+78 is used by the anti-cracker
                        \ code in the SetCrackerSeed and CheckCrackerSeed
                        \ routines, as it contains the high byte of the BCD
                        \ landscape number (this is because the seed generator
                        \ is initialised using the landscape number, and the
                        \ third number out of the shift register is unchanged
                        \ and still contains the initial value of that byte -
                        \ see the InitialiseSeeds routine for more details)

 LDX #80                \ Set a counter in X so we can generate 81 seed numbers

.land1

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers

 STA stripData,X        \ Set the X-th entry in the stripData table to the seed
                        \ number in A

 DEX                    \ Decrement the counter

 BPL land1              \ Loop back until we have generated all 81 seed numbers

                        \ We now set the value of tileDataMultiplier for this
                        \ landscape, which is a multiplier that we apply to the
                        \ altitudes of the tile corners to alter the steepness
                        \ of the landscape

 LDA landscapeZero      \ If this is not landscape 0000, jump to land2
 BNE land2

 LDA #24                \ This is landscape 0000, so set A = 24 to use for the
                        \ tile data multiplier in tileDataMultiplier

 BNE land3              \ Jump to land3 to skip the following (this BNE is
                        \ effectively a JMP as A is never zero)

.land2

 JSR GetNextSeed0To22   \ Set A to the next number from the landscape's sequence
                        \ of seed numbers, converted to the range 0 to 22

 CLC                    \ Set A = A + 14
 ADC #14                \
                        \ So A is now a number in the range 14 to 36

.land3

 STA tileDataMultiplier \ Set tileDataMultiplier = A
                        \
                        \ So this is 24 for landscape 0000 and in the range 14
                        \ to 36 for all other landscapes

                        \ We now populate the tileData table with tile corner
                        \ altitudes, which we store in the low nibble of the
                        \ tile data (for now)

 LDA #&80               \ Call ProcessTileData with A = &80 to set the tile data
 JSR ProcessTileData    \ for the whole landscape to the next set of numbers
                        \ from the landscape's sequence of seed numbers

 LDA #%00000000         \ Call SmoothTileData with bit 6 of A clear, to smooth
 JSR SmoothTileData     \ the landscape in lines of tile corners, working along
                        \ rows from left to right and along columns from front
                        \ to back, and smoothing each tile by setting each tile
                        \ corner's altitude to the average of its altitude with
                        \ the three following tile corners
                        \
                        \ This process is repeated twice by the single call to
                        \ SmoothTileData

 LDA #1                 \ Call ProcessTileData with A = 1 to scale the tile data
 JSR ProcessTileData    \ for the whole landscape by the tileDataMultiplier
                        \ before capping each byte of data to between 1 and 11
                        \
                        \ This capping process ensures that when we place the
                        \ tile altitude in the top nibble of the tile data, we
                        \ never have both bits 6 and 7 set (these bits can
                        \ therefore be used to identify whether or not a tile
                        \ contains an object)

 LDA #%01000000         \ Call SmoothTileData with bit 6 of A set, to smooth
 JSR SmoothTileData     \ the landscape in lines of tile corners, from the rear
                        \ row to the front row and then from the right column to
                        \ the left column, smoothing each outlier tile corner by
                        \ setting its altitude to that of its closest immediate
                        \ neighbour (where "closest" is in terms of altitude)
                        \
                        \ This smooths over any single-point spikes or troughs
                        \ in each row and column
                        \
                        \ This process is repeated twice by the single call to
                        \ SmoothTileData

                        \ The tileData table now contains the altitude of each
                        \ tile corner, with each altitude in the range 1 to 11,
                        \ so the altitude data is in the low nibble of each byte
                        \ of tile data
                        \
                        \ We now calculate the tile shape for the tiles anchored
                        \ at each tile corner in turn, where the anchor is in
                        \ the front-left corner of the tile (i.e. nearest the
                        \ origin)
                        \
                        \ Note that the last tile corners at the right end of
                        \ each row or at the back of each column do not anchor
                        \ any tiles, as they are at the edge (so their shapes
                        \ are not calculated)
                        \
                        \ We put the tile shape into the high nibble of the tile
                        \ data (for now)

 LDA #30                \ Set zTile = 30 so we start iterating from the rear,
 STA zTile              \ skipping the row right at the back as the tile corners
                        \ in that row do not anchor any tiles (so zTile iterates
                        \ from 30 to 0 in the outer loop)

.land4

 LDA #30                \ Set xTile = 30 so we start iterating from the right,
 STA xTile              \ skipping the rightmost column as the tile corners
                        \ in that column do not anchor any tiles (so xTile
                        \ iterates from 30 to 0 in the inner loop)

.land5

 JSR GetTileShape       \ Set X to the shape of the tile anchored at
                        \ (xTile, zTile)
                        \
                        \ This will be in the range 1 to 11 (so it fits into
                        \ the low nibble)

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile), which we ignore, but this also sets
                        \ the tile page in tileDataPage and the index in Y, so
                        \ tileDataPage+Y now points to the tile data entry in
                        \ the tileData table

                        \ We now put the tile shape into the high nibble of the
                        \ tile data, so the low nibble of the tile data contains
                        \ the tile altitude and the high nibble contains the
                        \ tile shape (for now)

 TXA                    \ Put the tile shape in X into the high nibble of A by
 ASL A                  \ shifting X to the left by three spaces and OR'ing the
 ASL A                  \ result into the tile data at tileData + Y
 ASL A                  \
 ASL A                  \ This works because both the tile altitude and tile
 ORA (tileDataPage),Y   \ shape fit into the range 0 to 15, or four bits
 STA (tileDataPage),Y

 DEC xTile              \ Decrement the tile x-coordinate in the inner loop

 BPL land5              \ Loop back until we have processed all the tile corners
                        \ in the tile row at z-coordinate zTile, working from
                        \ right to left

 DEC zTile              \ Decrement outer loop counter

 BPL land4              \ Loop back until we have processed all the tile rows in
                        \ the landscape, working from the back of the landscape
                        \ all the way to the front row

                        \ By this point the high nibble of each byte of tile
                        \ data contains the tile shape and the low nibble
                        \ contains the tile altitude, so now we swap these
                        \ around
                        \
                        \ We do this so that we can reuse bits 6 and 7 to in
                        \ each byte of tile data to store the presence of an
                        \ object on the tile, as moving the tile altitude into
                        \ the high nibble means that bits 6 and 7 will never
                        \ be set (as the altitude is in the range 0 to 11)
                        \
                        \ We can therefore set both bit 6 and 7 to indicate that
                        \ a tile contains an object, and we can reuse the other
                        \ bits to store the object information (as we only ever
                        \ place objects on flat tiles, so we can discard the
                        \ shape data)

 LDA #2                 \ Call ProcessTileData with A = 2 to swap the high and
 JSR ProcessTileData    \ low nibbles of all the tile data for the whole
                        \ landscape
                        \
                        \ So now the low nibble of each byte of tile data
                        \ contains the tile shape and the high nibble contains
                        \ the tile altitude, as required
                        \
                        \ This also sets the N flag, so a BMI branch would be
                        \ taken at this point (see the following instruction)

 RTS                    \ Return from the subroutine
                        \
                        \ If the SmoothTileCorners routine has modified the
                        \ return address on the stack, then this RTS instruction
                        \ will actually take us to JumpToPreview+1, and the BMI
                        \ branch instruction at JumpToPreview+1 will be taken
                        \ because the call to ProcessTileData sets the N flag,
                        \ so this RTS will end up taking us to PreviewLandscape
                        \
                        \ If the SmoothTileCorners routine has not modified the
                        \ return address, then the RTS will take us to the
                        \ SecretCodeError routine, just after the original
                        \ caller, i.e. just after the JSR GenerateLandscape
                        \ instruction (which will either be at the end of the
                        \ main title loop if the player enters an incorrect
                        \ secret code, or when displaying a landscape's secet
                        \ code after the level is completed)

\ ******************************************************************************
\
\       Name: ProcessTileData
\       Type: Subroutine
\   Category: Landscape
\    Summary: Process the tile data for all tiles in the landscape
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Controls what we do to the tile data:
\
\                         * 0 = zero all the tile data
\
\                         * 1 = scale all the tile data by the multiplier in
\                               tileDataMultiplier before capping it to a value
\                               between 1 and 11
\
\                         * 2 = swap the high and low nibbles of all the tile
\                               data
\
\                         * &80 = set the tile data to the next set of numbers
\                                 from the landscape's sequence of seed numbers
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   N flag              The N flag is set (so a BMI branch will be taken)
\
\ ******************************************************************************

.ProcessTileData

 STA processAction      \ Store the action in processAction for later

                        \ We now loop through all the tiles in the landscape
                        \
                        \ The landscape consists of 31x31 square tiles, like a
                        \ chess board that's sitting on a table in front of us,
                        \ going into the screen
                        \
                        \ The landscape is defined by the altitudes of the
                        \ corners of each of the tile, so that's a 32x32 grid of
                        \ altitudes
                        \
                        \ The x-axis is along the front edge, from left to
                        \ right, while the z-axis goes into the screen, away
                        \ from us
                        \
                        \ We iterate through the tile corners with a nested
                        \ loop, with zTile going from 31 to 0 (so that's from
                        \ back to front)
                        \
                        \ For each zTile, xTile also goes from 31 to 0, so
                        \ that's from right to left
                        \
                        \ So we work through the landscape, starting with the
                        \ row of tile corners at the back (which we work through
                        \ from right to left), and then doing the next row
                        \ forward, looping until we reach the front row

 LDA #31                \ Set zTile = 31 so we start iterating from the back row
 STA zTile              \ (so zTile iterates from 31 to 0 in the outer loop)

.proc1

 LDA #31                \ Set xTile = 31 so we start iterating from the right
 STA xTile              \ end of the current row (so xTile iterates from 31 to 0
                        \ in the inner loop)

.proc2

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile), which we ignore, but this also sets
                        \ the tile page in tileDataPage and the index in Y, so
                        \ tileDataPage+Y now points to the tile data entry in
                        \ the tileData table

 LDA processAction      \ Set A to the argument that was passed to the routine
                        \ and which we stored in processAction,
                        \
                        \ This specifies how we process the tile data

 BEQ proc8              \ If processAction = 0 then jump to proc8 to zero the
                        \ tile data for the tile anchored at (xTile, zTile)

 BMI proc7              \ If processAction = &80 then jump to proc7 to set the
                        \ tile data for the tile anchored at (xTile, zTile) to
                        \ the next number from the landscape's sequence of seed
                        \ numbers

                        \ If we get here then processAction must be 1 or 2 (as
                        \ the routine is only ever called with A = 0, 1, 2 or
                        \ &80)

 LSR A                  \ If processAction = 1 then this sets the C flag,
                        \ otherwise processAction = 2 and this clears the C flag

 LDA (tileDataPage),Y   \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 BCS proc3              \ If the C flag is set then processAction = 1, so jump
                        \ to proc3

                        \ If we get here then processAction = 2, so now we swap
                        \ the high and low nibble of the tile data

 LSR A                  \ Set bits 0-3 of T to the high nibble (bits 4-7) of the
 LSR A                  \ tile data in A
 LSR A
 LSR A
 STA T

 LDA (tileDataPage),Y   \ Set A once again to the tile data for the tile
                        \ anchored at (xTile, zTile)

 ASL A                  \ Set bits 4-7 of A to the low nibble (bits 0-3) of the
 ASL A                  \ tile data in A
 ASL A
 ASL A

 ORA T                  \ Merge A and T, so A now contains its original high
                        \ nibble in bits 0-3 (from T) and its original low
                        \ nibble in bits 4-7 (from A)
                        \
                        \ So this swaps the high and low nibbles around in the
                        \ tile data in A

 JMP proc8              \ Jump to proc8 to store A as the tile data for the tile
                        \ we are processing

.proc3

                        \ If we get here then processAction = 1, so we now do
                        \ various manipulations, including multiplying the
                        \ tile data by the multiplier in tileDataMultiplier
                        \ and capping the result to a positive number between
                        \ 1 and 11
                        \
                        \ At this point the tile data contains a seed number,
                        \ so this processs converts it into a value that we can
                        \ use as the altitude of the tile corner

 SEC                    \ Set A = tile data - 128
 SBC #128

 PHP                    \ Store the flags from the subtraction, so we can set
                        \ the sign of the scaled altitude below

 BPL proc4              \ If the result of the subtraction in A is positive,
                        \ skip the following as A is already positive

 EOR #%11111111         \ The result in A is negative, so negate it using two's
 CLC                    \ complement, so we have:
 ADC #1                 \
                        \   A = |tile data - 128|
                        \
                        \ This negation reflects negative altitudes from below
                        \ sea level to the equivalent altitude above sea level

.proc4

 STA U                  \ Set U = A
                        \       = |tile data - 128|

 LDA tileDataMultiplier \ Set A to the multiplier that we need to apply to the
                        \ tile data, which is in the range 14 to 36

 JSR Multiply8x8        \ Set (A T) = A * U
                        \           = tileDataMultiplier * |tile data - 128|

 PLP                    \ Restore the flags from the subtraction above, so
                        \ the N flag contains the sign of (tile data - 128)
                        \ (clear if it is positive, set if it is negative)

 JSR Absolute16Bit      \ Set the sign of (A T) to match the result of the
                        \ subtraction above, so we now have:
                        \
                        \   (A T) = tileDataMultiplier * (tile data - 128)

                        \ So if the original tile data represents a landscape
                        \ altitude, with "sea level" at altitude 128, then the
                        \ high byte of this calculation in A represents a
                        \ scaling of the altitude by tileDataMultiplier / 256,
                        \ with the scaling centred around sea level
                        \
                        \ This means that mountain peaks get higher and marine
                        \ trenches get deeper, stretching away from sea level
                        \ at altitude 128 in the original data
                        \
                        \ As tileDataMultiplier is in the range 14 to 36, this
                        \ transforms the tile data values as follows:
                        \
                        \   * Values start out in the range 0 to 255
                        \
                        \   * Converting to |tile data - 128| translates them
                        \     into values in the range 0 to 127, representing
                        \     magnitudes of altitude (0 = sea level, 127 = top
                        \     of Everest or bottom of Mariana Trench, stack
                        \     contains flags denoting high altitude or murky
                        \     depths)
                        \
                        \   * Multiplying by 14/256 (the minimum multiplier)
                        \     changes the range into 0 to 6
                        \
                        \   * Multiplying by 36/256 (the maximum multiplier)
                        \     changes the range into 0 to 17
                        \
                        \   * Reapplying the sign converts the magnitudes back
                        \     into depths or heights
                        \
                        \ So the above takes the seed numbers in the original
                        \ tile data and transforms then into values of A with a
                        \ maximum range of -17 to +17 (for higher multipliers)
                        \ or -6 to +6 (for lower multipliers)
                        \
                        \ We now take this result and do various additions and
                        \ cappings to change the result into a positive number
                        \ between 1 and 11

 CLC                    \ Set A = A + 6
 ADC #6                 \
                        \ So the ranges for A are now:
                        \
                        \   * Minimum multiplier range is -1 to +13
                        \
                        \   * Maximum multiplier range is -11 to +23

 BPL proc5              \ If A is positive then jump to proc5 to skip the
                        \ following

 LDA #0                 \ Otherwise A is negative, so set A = 0

.proc5

                        \ By this point A is a positive number and the ranges
                        \ for A are now:
                        \
                        \   * Minimum multiplier range is 0 to 13
                        \
                        \   * Maximum multiplier range is 0 to 23

 CLC                    \ Set A = A + 1
 ADC #1

                        \ By this point A is a positive number and the ranges
                        \ for A are now:
                        \
                        \   * Minimum multiplier range is 1 to 14
                        \
                        \   * Maximum multiplier range is 1 to 24

 CMP #12                \ If A < 12 then jump to proc6 to skip the following
 BCC proc6

 LDA #11                \ Otherwise A >= 12, so set A = 11

.proc6

                        \ By this point, A is a positive number between 1 and 11
                        \
                        \ For minimum values of the multiplier we have only lost
                        \ the very low and very high values in the range
                        \
                        \ For maximum values of the multiplier we have lost
                        \ around one-third at the top end and one-third at the
                        \ bottom end
                        \
                        \ We can now use this as the altitude of the tile
                        \ corner, which we can feed into the smoothing routines
                        \ to generate a gently rolling landscape that is
                        \ suitable for the game

 JMP proc8              \ Jump to proc8 to store A as the tile data for the tile
                        \ we are processing

.proc7

                        \ If we get here then the argument in A is &80, so we
                        \ fill the tile data table with seed numbers

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers

.proc8

 STA (tileDataPage),Y   \ Store A as the tile data for the tile anchored at
                        \ (xTile, zTile)

 DEC xTile              \ Decrement the tile x-coordinate in the inner loop

 BPL proc2              \ Loop back until we have processed all the tiles in the
                        \ tile row at z-coordinate zTile, working from right to
                        \ left

 DEC zTile              \ Decrement the outer loop counter

 BPL proc1              \ Loop back until we have processed all the tile rows in
                        \ the landscape, working from the back row of the
                        \ landscape all the way to the front row

                        \ Note that by this point the N flag is set, which means
                        \ a BMI branch would be taken (this is important when
                        \ analysing the intentionally confusing flow of the main
                        \ title loop created by the stack modifications in the
                        \ GenerateLandscape, SmoothTileCorners and JumpToPreview
                        \ routines)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SmoothTileData
\       Type: Subroutine
\   Category: Landscape
\    Summary: Smooth the entire landscape
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Controls how we smooth the tile data:
\
\                         * Bit 6 clear = smooth each row/column of tile corners
\                                         by working along the row/column and
\                                         setting each tile corner's altitude to
\                                         the average of its altitude with the
\                                         three following tile corners, working
\                                         along rows from left to right and
\                                         along columns from front to back
\
\                         * Bit 6 set = smooth each row/column of tile corners
\                                       by working along the row/column and
\                                       setting the altitude of each outlier
\                                       tile corner to that of its closest
\                                       immediate neighbour in terms of altitude
\                                       (i.e. smooth out single-point spikes or
\                                       troughs in the row/column)
\
\ ******************************************************************************

.SmoothTileData

 STA smoothingAction    \ Store the action in smoothingAction so the calls to
                        \ SmoothTileCorners can access it

 LDA #2                 \ We perform the smoothing process twice, so set a loop
 STA loopCounter        \ counter in loopCounter to count down from 2

.smoo1

                        \ We start by working our way through the landscape,
                        \ smoothing the row of tile corners at the back (i.e. at
                        \ tile z-coordinate 31), and then smoothing the next row
                        \ forward, looping until we reach the front row

 LDA #31                \ Set zTile = 31 so we start iterating from the back row
 STA zTile              \ (so zTile iterates from 31 to 0 in the following loop)

.smoo2

 LDA #00000000          \ Call SmoothTileCorners with bit 7 of A clear to smooth
 JSR SmoothTileCorners  \ the row of tile corners at z-coordinate zTile

 DEC zTile              \ Decrement the tile z-coordinate to move forward by one
                        \ tile row

 BPL smoo2              \ Loop back until we have smoothed all 32 rows

                        \ Next we work our way through the landscape from right
                        \ to left, smoothing the column of tile corners on the
                        \ right (i.e. the column of tile corners going into the
                        \ screen at tile x-coordinate 31), and then smoothing
                        \ the next column to the left, looping until we reach
                        \ the column along the left edge of the landscape

 LDA #31                \ Set xTile = 31 so we start iterating from the right
 STA xTile              \ column (so xTile iterates from 31 to 0 in the
                        \ following loop)

.smoo3

 LDA #%10000000         \ Call SmoothTileCorners with bit 7 of A set to smooth
 JSR SmoothTileCorners  \ the column of tile corners at x-coordinate xTile

 DEC xTile              \ Decrement the tile x-coordinate to move left by one
                        \ tile column

 BPL smoo3              \ Loop back until we have smoothed all 32 columns

 DEC loopCounter        \ Decrement the loop counter

 BNE smoo1              \ Loop back until we have done the whole smoothing
                        \ process twice

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetTileData
\       Type: Subroutine
\   Category: Landscape
\    Summary: Get the tile data and tile data address for a specific tile
\
\ ------------------------------------------------------------------------------
\
\ The tile data table at tileData is made up of sequences of 32 columns of tile
\ corners going into the screen, where each column goes from z = 0 to 31 along
\ the same x-coordinate, with the columns interleaved in steps of 4 like this:
\
\   &0400-&041F = 32-corner column going into the screen at x =  0
\   &0420-&043F = 32-corner column going into the screen at x =  4
\   &0440-&045F = 32-corner column going into the screen at x =  8
\   &0460-&047F = 32-corner column going into the screen at x = 12
\   &0480-&049F = 32-corner column going into the screen at x = 16
\   &04A0-&04BF = 32-corner column going into the screen at x = 20
\   &04C0-&04DF = 32-corner column going into the screen at x = 24
\   &04E0-&04FF = 32-corner column going into the screen at x = 28
\
\   &0500-&051F = 32-corner column going into the screen at x =  1
\   &0520-&053F = 32-corner column going into the screen at x =  5
\   &0540-&055F = 32-corner column going into the screen at x =  9
\   &0560-&057F = 32-corner column going into the screen at x = 13
\   &0580-&059F = 32-corner column going into the screen at x = 17
\   &05A0-&05BF = 32-corner column going into the screen at x = 21
\   &05C0-&05DF = 32-corner column going into the screen at x = 25
\   &05E0-&05FF = 32-corner column going into the screen at x = 29
\
\   &0600-&061F = 32-corner column going into the screen at x =  2
\   &0620-&063F = 32-corner column going into the screen at x =  6
\   &0640-&065F = 32-corner column going into the screen at x = 10
\   &0660-&067F = 32-corner column going into the screen at x = 14
\   &0680-&069F = 32-corner column going into the screen at x = 18
\   &06A0-&06BF = 32-corner column going into the screen at x = 22
\   &06C0-&06DF = 32-corner column going into the screen at x = 26
\   &06E0-&06FF = 32-corner column going into the screen at x = 30
\
\   &0700-&071F = 32-corner column going into the screen at x =  3
\   &0720-&073F = 32-corner column going into the screen at x =  7
\   &0740-&075F = 32-corner column going into the screen at x = 11
\   &0760-&077F = 32-corner column going into the screen at x = 15
\   &0780-&079F = 32-corner column going into the screen at x = 19
\   &07A0-&07BF = 32-corner column going into the screen at x = 23
\   &07C0-&07DF = 32-corner column going into the screen at x = 27
\   &07E0-&07FF = 32-corner column going into the screen at x = 31
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   xTile               A tile corner x-coordinate (0 to 31)
\
\   zTile               A tile corner z-coordinate (0 to 31)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   The tile data for the tile anchored at (xTile, zTile):
\
\                         * If the tile does not contain an object, then:
\
\                           * The tile shape is in the low nibble (0 to 15)
\
\                           * The tile altitude is in the high nibble (1 to 11)
\
\                         * If the tile contains an object, then:
\
\                           * Bits 0 to 5 contain the object number of the
\                             object on the tile (0 to 63)
\
\                           * Bits 6 and 7 are both set
\
\   tileDataPage(1 0)   The address of the page containing the tile data
\
\   Y                   The offset from tileDataPage(1 0) of the tile data
\
\   C flag              Determines whether the tile contains an object:
\
\                         * Set if this tile contains an object
\
\                         * Clear if this tile does not contain an object
\
\ ******************************************************************************

.GetTileData

 LDA xTile              \ Set Y = (xTile << 3 and %11100000) + zTile
 ASL A                  \       = (xTile >> 2 and %00000111) << 5 + zTile
 ASL A                  \       = (xTile div 4) * &20 + zTile
 ASL A
 AND #%11100000
 ORA zTile
 TAY

 LDA xTile              \ Set A = bits 0-1 of xTile
 AND #%00000011         \       = xTile mod 4

                        \ The low byte of tileDataPage(1 0) gets set to zero in
                        \ ResetVariables and is never changed
                        \
                        \ The low byte of tileData is also zero, as we know that
                        \ tileData is &0400
                        \
                        \ So in the following, we are just adding the high bytes
                        \ to get a result that is on a page boundary

 CLC                    \ Set the following:
 ADC #HI(tileData)      \
 STA tileDataPage+1     \   tileDataPage(1 0) = tileData + (A 0)
                        \                     = tileData + (xTile mod 4) * &100

                        \ So we now have the following:
                        \
                        \   tileDataPage(1 0) = tileData + (xTile mod 4) * &100
                        \
                        \   Y = (xTile div 4) * &20 + zTile
                        \
                        \ The address in tileDataPage(1 0) is the page within
                        \ tileData for the tile anchored at (xTile, zTile), and
                        \ is always one of &0400, &0500, &0600 or &0700 because
                        \ (xTile mod 4) is one of 0, 1, 2 or 3
                        \
                        \ The value of Y is the offset within that page of the
                        \ tile data for the tile anchored at (xTile, zTile)
                        \
                        \ We can therefore fetch the tile data for the specified
                        \ tile using Y as an index offset from tileDataPage(1 0)

 LDA (tileDataPage),Y   \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 CMP #%11000000         \ Set the C flag if A >= %11000000, which will be the
                        \ case if both bit 6 and bit 7 of A are set

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: SmoothTileCorners (Part 1 of 4)
\       Type: Subroutine
\   Category: Landscape
\    Summary: Smooth a row or column of tile corners (a "strip of tiles")
\
\ ------------------------------------------------------------------------------
\
\ This part copies the row or column of tile corners to a temporary workspace.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Controls which tile corners we smooth in the tile data:
\
\                         * Bit 7 clear = smooth the row of tile corners at
\                                         z-coordinate zTile
\
\                         * Bit 7 set = smooth the column of tile corners at
\                                       x-coordinate xTile
\
\ ******************************************************************************

.SmoothTileCorners

 ORA smoothingAction    \ We configured the smoothing action in bit 6 of
 STA processAction      \ smoothingAction in the SmoothTileData routine before
                        \ calling this routine, and bit 7 of A tells us whether
                        \ to smooth a row or a column of tile cornser, so this
                        \ combines both configurations from bit 6 and bit 7 into
                        \ one byte that we store in processAction

 LDX #34                \ We start by copying the tile data for the row/column
                        \ that we want to smooth into the stripData workspace,
                        \ so we can process it before copying it back into the
                        \ tileData table
                        \
                        \ In the following commentary I will refer to this
                        \ copied row or column of tile corners as a "strip of
                        \ tiles", as saying "row or column of tile corners"
                        \ every time is a bit of a monthful
                        \
                        \ We actually create a strip of tile data containing 35
                        \ tile corners, with offsets 0 to 31 being the tile data
                        \ for the strip we are smoothing and offsets 32 to 34
                        \ being repeats of the data for tile corners 0 to 2
                        \
                        \ So we effectively duplicate the first three tile
                        \ corners onto the end of the strip so we can wrap the
                        \ smoothing calculations around past the end of the
                        \ strip

.stri1

 TXA                    \ Set A = X mod 32
 AND #31                \
                        \ This ensures that for X = 32 to 34, we copy the tile
                        \ data for tiles 0 to 2 (as A = 0 to 2 for X = 32 to 34)

 BIT processAction      \ If bit 7 of processAction is clear then we are
 BPL stri2              \ smoothing a row of tiles at z-coordinate zTile, so
                        \ jump to stri2 to iterate across xTile

 STA zTile              \ If we get here then we are smoothing a column of tiles
                        \ so set zTile to the counter in X so we iterate along
                        \ the z-coordinate (i.e. coming out of the screen)

 JMP stri3              \ Jump to stri3 to skip the following

.stri2

 STA xTile              \ If we get here then we are smoothing a row of tiles
                        \ so set xTile to the counter in X so we iterate along
                        \ the x-coordinate (i.e. from right to left)

.stri3

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 STA stripData,X        \ Store the tile data for (xTile, zTile) into the X-th
                        \ byte in our temporary workspace

 DEX                    \ Decrement the tile counter in X

 BPL stri1              \ Loop back until we have copied tile data for all 32
                        \ tiles in the strip, plus three more tiles on the end

 BIT processAction      \ If bit 6 of processAction is clear then we need to
 BVC stri11             \ smooth the strip by averaging tile altitudes, so jump
                        \ to part 3 to implement this

                        \ Otherwise fall through into part 2 to smooth the strip
                        \ by moving outlier tiles

\ ******************************************************************************
\
\       Name: SmoothTileCorners (Part 2 of 4)
\       Type: Subroutine
\   Category: Landscape
\    Summary: Smooth a strip by moving each outlier tile corner to the altitude
\             of its closest immediate neighbour (in terms of altitude)
\
\ ------------------------------------------------------------------------------
\
\ This part smoothes the strip by working along the strip and applying the
\ following algorithm:
\
\   * If this tile corner is higher then both its neighbours, move it down
\
\   * If this tile corner is lower then both its neighbours, move it up
\
\ In each case, we move the tile corner until it is level with the closest one
\ to its original altitude. This has the effect of smoothing out single-point
\ spikes or troughs in the strip.
\
\ ******************************************************************************

                        \ If we get here then bit 6 of processAction is set, so
                        \ we smooth the tile strip by moving each outlier tile
                        \ to the altitude of its closest immediate neighbour (in
                        \ terms of altitude)
                        \
                        \ This smoothes out single-point spikes or troughs

 LDX #31                \ We now work our way along the strip, smoothing the
                        \ altitudes of tiles 1 to 32, so set a tile counter in X
                        \
                        \ Note that we smooth tiles 1 to 32 rather than tiles
                        \ 0 to 31 (tile 0 remains unchanged by the smoothing
                        \ process)

.stri4

                        \ In the following, we are processing the tile at
                        \ position X + 1, i.e. stripData+1,X
                        \
                        \ We smooth a tile by looking at the altitudes of the
                        \ two tiles either side of that tile, i.e. stripData,X
                        \ and stripData+2,X
                        \
                        \ We are smoothing from high values of X to low values,
                        \ so by this point the tile at stripData+2,X has already
                        \ been smoothed
                        \
                        \ Let's name the tiles as follows:
                        \
                        \   * stripData+2,X = "previous tile" (as it has already
                        \                     been smoothed)
                        \
                        \   * stripData+1,X = "this tile" (as this is the tile
                        \                      we are smoothing)
                        \
                        \   * stripData,X   = "next tile" (as this is the tile
                        \                      we will be smoothing next)
                        \
                        \ The smoothing algorithm is implemented as follows,
                        \ where we are comparing the altitude of each tile (as
                        \ at this stage tileData only contains tile altitudes):
                        \
                        \   * If this = previous, do nothing
                        \
                        \   * If this < previous and this >= next, do nothing
                        \
                        \   * If this < previous and this < next, set
                        \     this = min(previous, next)
                        \
                        \   * If this > previous and this <= next, do nothing
                        \
                        \   * If this > previous and this > next, set
                        \     this = max(previous, next)
                        \
                        \ Or to simplify:
                        \
                        \  * If this tile is higher then both its neighbours,
                        \    move it down until it isn't
                        \
                        \  * If this tile is lower then both its neighbours,
                        \    move it up until it isn't
                        \
                        \ So this algorithm smoothes the landscape by squeezing
                        \ the landscape into a flatter shape, moving outlier
                        \ tiles closer to the landscape's overall line

 LDA stripData+1,X      \ If this tile is at the same altitude as the previous
 CMP stripData+2,X      \ tile, jump to stri9 to move on to smoothing the next
 BEQ stri9              \ tile, as the transition from the previous tile to this
                        \ tile is already flat

 BCS stri5              \ If this tile is higher than the previous tile, jump to
                        \ stri5

                        \ If we get here then this tile is lower than the
                        \ previous tile

 CMP stripData,X        \ If this tile is at the same altitude or higher than
 BEQ stri9              \ the next tile, jump to stri9 to move on to smoothing
 BCS stri9              \ the next tile

                        \ If we get here then this tile is lower than the
                        \ previous tile and lower than the next tile

 LDA stripData+2,X      \ Set the flags from comparing the previous and next
 CMP stripData,X        \ tiles (so in stri6, tile A is the previous tile and
                        \ tile B is the next tile)

 JMP stri6              \ Jump to stri6, so that:
                        \
                        \   * If previous < next, set this = previous
                        \
                        \   * If previous >= next, set this = next
                        \
                        \ In other words, set:
                        \
                        \   this = min(previous, next)
                        \
                        \ before moving on to the next tile

.stri5

                        \ If we get here then this tile is higher than the
                        \ previous tile

 CMP stripData,X        \ If this tile is at the same altitude or lower than the
 BEQ stri9              \ next tile jump to stri9 to move on to smoothing the
 BCC stri9              \ next tile

                        \ If we get here then this tile is higher than the
                        \ previous tile and this tile is higher than the next
                        \ tile

 LDA stripData,X        \ Set the flags from comparing the next and previous
 CMP stripData+2,X      \ tiles (so in stri6, tile A is the next tile and
                        \ tile B is the previous tile)

                        \ Fall through into stri6, so that:
                        \
                        \   * If next < previous, set this = previous
                        \
                        \   * If next >= previous, set this = next
                        \
                        \ In other words, set:
                        \
                        \   this = max(previous, next)
                        \
                        \ before moving on to the next tile
.stri6

                        \ We get here after comparing two tiles; let's call them
                        \ tile A and tile B

 BCC stri7              \ If tile A is lower than tile B, jump to stri7 to set
                        \ the altitude of this tile to the altitude of the
                        \ previous tile

 LDA stripData,X        \ Set A to the altitude of the next tile and jump to
 JMP stri8              \ stri8 to set the altitude of this tile to the altitude
                        \ of the next tile

.stri7

 LDA stripData+2,X      \ Set A to the altitude of the previous tile

.stri8

 STA stripData+1,X      \ Set the altitude of this tile to the value in A

.stri9

 DEX                    \ Decrement the strip tile counter in X

 BPL stri4              \ Loop back until we have worked our way through the
                        \ whole strip

 BIT doNotPlayLandscape \ If bit 7 of doNotPlayLandscape is set then we do not
 BMI stri10             \ want to play the landscape after generating it, so
                        \ jump to stri10 to skip the following, leaving the
                        \ stack unmodified
                        \
                        \ This means that the JSR GenerateLandscape instruction
                        \ that got us here will return normally, so the RTS at
                        \ the end of the GenerateLandscape routine will behave
                        \ as expected, like this:
                        \
                        \   * If we called GenerateLandscape from the
                        \     MainTitleLoop routine, then we return there to
                        \     fall through into SecretCodeError, which displays
                        \     the "WRONG SECRET CODE" error message for when the
                        \     player enters an incorrect secret code
                        \
                        \   * If we called GenerateLandscape from the
                        \     FinishLandscape routine, then we return there to
                        \     display the landscape's secret entry code
                        \     on-screen, for when the player completes a level
                        \
                        \ If bit 7 of doNotPlayLandscape is clear then we keep
                        \ going to modify the return address on the stack, so
                        \ that the RTS at the end of the GenerateLandscape takes
                        \ us to the PreviewLandscape routine

                        \ The above loop ended with X set to &FF, so &0100 + X
                        \ in the following points to the top of the stack at
                        \ &01FF

 LDA #HI(JumpToPreview) \ Set the return address on the bottom of the stack at
 STA &0100,X            \ (&01FE &01FF) to JumpToPreview
 DEX                    \
 LDA #LO(JumpToPreview) \ Note that when an RTS instruction is executed, it pops
 STA &0100,X            \ the address off the top of the stack and then jumps to
                        \ that address + 1, so putting the JumpToPreview address
                        \ on the stack means that the RTS at the end of the
                        \ GenerateLandscape routine will actually send us to
                        \ address JumpToPreview+1
                        \
                        \ This is intentional and is intended to confuse any
                        \ crackers who might have reached this point, because
                        \ the JumpToPreview routine not only contains a JMP
                        \ instruction at JumpToPreview, but it also contains a
                        \ BMI instruction at JumpToPreview+1, if our crackers
                        \ forgot about this subtlty of the RTS instruction, they
                        \ might end up going down a rabbit hole

.stri10

 JMP stri16             \ Jump to stri16 to copy the tile data for the smoothed
                        \ strip back into the tileData table

\ ******************************************************************************
\
\       Name: SmoothTileCorners (Part 3 of 4)
\       Type: Subroutine
\   Category: Landscape
\    Summary: Smooth a strip by setting the tile corner altitudes to the average
\             of the current tile corner altitude and three following corners
\
\ ------------------------------------------------------------------------------
\
\ This part smoothes the strip by working along the strip and replacing the
\ altitude of each tile corner with the average of that corner's altitude plus
\ the next three corners, working along rows from left to right and columns
\ from near to far.
\
\ ******************************************************************************

.stri11

                        \ If we get here then bit 6 of processAction is clear,
                        \ so we smooth the tile strip by working our way along
                        \ the strip and setting each tile's altitude to the
                        \ average of its altitude with the three following tiles

 LDX #0                 \ We now work our way along the strip, smoothing the
                        \ altitudes of tiles 0 to 31, so set a tile counter in X
                        \
                        \ We work along rows from left to right and columns from
                        \ near to far

.stri12

 LDA #0                 \ Set U = 0 to use as the high byte of (U A), which we
 STA U                  \ will use to calculate the sum of the neighbouring tile
                        \ altitudes

 LDA stripData,X        \ Set A to the altitude of the tile we are smoothing
                        \ (the one at index X)

 CLC                    \ Add the altitude of the next tile along
 ADC stripData+1,X

 BCC stri13             \ If the addition overflowed then increment the high
 CLC                    \ byte in U, so we have the correct result of the sum
 INC U                  \ in (U A)

.stri13

 ADC stripData+2,X      \ Add the altitude of the next tile along

 BCC stri14             \ If the addition overflowed then increment the high
 CLC                    \ byte in U, so we have the correct result of the sum
 INC U                  \ in (U A)

.stri14

 ADC stripData+3,X      \ Add the altitude of the next tile along

 BCC stri15             \ If the addition overflowed then increment the high
 CLC                    \ byte in U, so we have the correct result of the sum
 INC U                  \ in (U A)

.stri15

                        \ So by this point (U A) contains the sum of the
                        \ altitudes of the tile we are smoothing, and the next
                        \ three tiles along the strip

 LSR U                  \ Set (U A) = (U A) / 4
 ROR A                  \
 LSR U                  \ So (U A) contains the average of the four altitudes,
 ROR A                  \ and we know that the high byte in U will be zero as
                        \ each of the four elements of the sum fits into one
                        \ byte

 STA stripData,X        \ Set the altitude of the tile we are smoothing to the
                        \ average that we just calculated

 INX                    \ Increment the tile counter to move along the strip

 CPX #32                \ Loop back until we have worked our way through the
 BCC stri12             \ strip and have smoothed tiles 0 to 31
                        \
                        \ This means that when we exit the loop, X = 32

                        \ We now have a very short interlude to set up some of
                        \ the anti-cracker code before continuing the smoothing
                        \ process in part 4

\ ******************************************************************************
\
\       Name: SetCrackerSeed
\       Type: Subroutine
\   Category: Cracker protection
\    Summary: Set up anti-cracker tile-related data that can be checked in the
\             CheckCrackerSeed routine
\
\ ******************************************************************************

.SetCrackerSeed

 LDA stripData+78-32,X  \ Copy the contents of stripData+78 into the operand of
 STA CrackerSeed+1-32,X \ the unused LDA #0 instruction at CrackerSeed (this
                        \ location is presumably disguised as an instruction to
                        \ obfuscate this process)
                        \
                        \ At this point stripData+78 contains the third seed
                        \ number to be generated at the start of the
                        \ GenerateLandscape routine, where 81 seed numbers are
                        \ generated and stored at stripData
                        \
                        \ This third seed contains the high byte of the BCD
                        \ landscape number
                        \
                        \ This is because the seed generator is initialised
                        \ using the landscape number, and the third number out
                        \ of the shift register is unchanged and still contains
                        \ the initial value of that byte - see the
                        \ InitialiseSeeds routine for more details)
                        \
                        \ This value is altered in the AlterCrackerSeed routine
                        \ that runs as part of the gameplay routines, and is
                        \ checked in the CheckCrackerSeed routine that runs as
                        \ part of the SpawnCharacter3D routine when drawing the
                        \ landscape's secret code

                        \ Fall through into part 4 of SmoothTileCorners to
                        \ continue with the smoothing process

\ ******************************************************************************
\
\       Name: SmoothTileCorners (Part 4 of 4)
\       Type: Subroutine
\   Category: Landscape
\    Summary: Copy the smoothed strip data back into the tileData table
\
\ ------------------------------------------------------------------------------
\
\ This part copies the smoothed strip back into the tileData table.
\
\ ******************************************************************************

.stri16

                        \ By this point we have smoothed the whole strip, so we
                        \ can now copy the smoothed tile data back into the
                        \ tileData table

 LDX #31                \ Set A counter in X to work through the tile data for
                        \ the 32 tiles in the strip we just smoothed

.stri17

 TXA                    \ Set A to the tile index

 BIT processAction      \ If bit 7 of processAction is clear then we are
 BPL stri18             \ smoothing a row of tiles at z-coordinate zTile, so
                        \ jump to stri18 to iterate across xTile

 STA zTile              \ If we get here then we are smoothing a column of tiles
                        \ so set zTile to the counter in X so we iterate along
                        \ the z-coordinate (i.e. coming out of the screen)

 JMP stri19             \ Jump to stri19 to skip the following

.stri18

 STA xTile              \ If we get here then we are smoothing a row of tiles
                        \ so set xTile to the counter in X so we iterate along
                        \ the x-coordinate (i.e. from right to left)

.stri19

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile), which we ignore, but this also sets
                        \ the tile page in tileDataPage and the index in Y, so
                        \ tileDataPage+Y now points to the tile data entry in
                        \ the tileData table

 LDA stripData,X        \ Copy the X-th byte of tile data from the smoothed
 STA (tileDataPage),Y   \ strip into the corresponding entry for (xTile, zTile)
                        \ in the tileData table

 DEX                    \ Decrement the tile counter in X so we work our way
                        \ along to the next tile in the strip we are smoothing

 BPL stri17             \ Loop back to smooth the next tile until we have
                        \ smoothed the whole strip

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetTileShape
\       Type: Subroutine
\   Category: Landscape
\    Summary: Calculate the shape of the tile anchored at (xTile, zTile)
\
\ ------------------------------------------------------------------------------
\
\ Given a tile at altitude S, with neighbouring altitudes T, U and V:
\
\      ^           [T]  [U]
\      |
\      |           [S]  [V]
\   z-axis
\    into
\   screen      x-axis from left to right --->
\
\ The shape is calculated as follows, where:
\
\   * 0 and 1 represent arbitrary altitudes that are in that order, with 1 being
\     higher than 0
\
\   * a, b represent arbitrary altitudes where a <> b <> 1
\
\ These are all the different types of shape (note there is no shape 8, and
\ shapes 4 and 12 can have multiple layouts):
\
\   Shape   S vs V      S vs T      S vs U      U vs V      U vs T      Layout
\   -----   ------      ------      ------      ------      ------      ------
\
\   0       S == V      S == T      S == U                              1 1
\                                                                       1 1
\
\   1       S == V      S <> T                  U <  V      U == T      0 0
\                                                                       1 1
\
\   2       S <> V      S <> T      S <= U      U == V      U == T      1 1
\                                                                       0 1
\
\   3       S == V      S == T      S >  U                              1 0
\                                                                       1 1
\
\   4a      S <> V      S <> T                  U == V      U <> T      a 1
\                                                                       b 1
\
\   4b      S <> V      S == T                  U <> V      U <> T      1 a
\                                                                       1 b
\
\   5       S <> V      S == T                  U == V      U <  T      1 0
\                                                                       1 0
\
\   6       S == V      S <> T                  U == V      U <  T      1 0
\                                                                       0 0
\
\   7       S <> V      S == T                  U >= V      U == T      1 1
\                                                                       1 0
\
\   9       S == V      S <> T                  U >= V      U == T      1 1
\                                                                       0 0
\
\   10      S == V      S == T      S <  U                              0 1
\                                                                       0 0
\
\   11      S <> V      S <> T      S >  U      U == V      U == T      0 0
\                                                                       1 0
\
\   12a     S <> V      S <> T                  U <> V                  1 1
\                                                                       a b
\
\   12b     S == V      S <> T                  U <> V      U <> T      a b
\                                                                       1 1
\
\   13      S <> V      S == T                  U == V      U >= T      0 1
\                                                                       0 1
\
\   14      S <> V      S == T                  U <  V      U == T      0 0
\                                                                       0 1
\
\   15      S == V      S <> T                  U == V      U >= T      0 1
\                                                                       1 1
\
\ Note that for shape 12a, the top-right corner could in theory be a different
\ altitude to a, b and 1, and the comparisons would still fit. However, the way
\ the landscape gets smoothed ensures that every tile has at least one
\ horizontal edge, so this means the top-right corner must be at altitude 1.
\
\ It is worth noting that:
\
\   * Shape 0 has four horizontal edges
\
\   * Shapes 4 and 12 have one horizontal edge and three sloping edges
\
\   * Shape 8 is unused
\
\   * All other shapes (1, 2, 3, 5, 6, 7, 9, 10, 11, 14 and 15) have two
\     horizontal edges and two sloping edges
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   The shape of the tile anchored at (xTile, zTile)
\
\ ******************************************************************************

.GetTileShape

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 AND #%00001111         \ Extract the tile altitude from the low nibble and
 STA S                  \ store it in S

 INC xTile              \ Move along the x-axis to fetch the next tile to the
                        \ right

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 AND #%00001111         \ Extract the tile altitude from the low nibble and
 STA V                  \ store it in V

 INC zTile              \ Move along the x-axis to fetch the next tile into the
                        \ screen

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 AND #%00001111         \ Extract the tile altitude from the low nibble and
 STA U                  \ store it in U

 DEC xTile              \ Move back along the x-axis to fetch the next tile to
                        \ the left

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile)

 AND #%00001111         \ Extract the tile altitude from the low nibble and
 STA T                  \ store it in T

 DEC zTile              \ Move out of the screen, back along the z-axis to take
                        \ us back to the tile we are processing

                        \ So at this point we have the altitudes of four tile
                        \ corners, as follows, with the view from above:
                        \
                        \      ^           [T]  [U]
                        \      |
                        \      |           [S]  [V]
                        \   z-axis
                        \    into
                        \   screen      x-axis from left to right --->
                        \
                        \ S is the altitude of the tile corner that anchors the
                        \ tile for which we are calculating the shape, and T, U
                        \ and V are the altitudes of the tile's other three
                        \ corners, so now we can analyse the shape of the tile

 LDA S                  \ If S = V then jump to shap10
 CMP V
 BEQ shap10

 CMP T                  \ If S = T then jump to shap4
 BEQ shap4

 LDA U                  \ If U = V then jump to shap2
 CMP V
 BEQ shap2

.shap1

                        \ If we get here then we either fell through from above:
                        \
                        \   * S <> V
                        \   * S <> T
                        \   * U <> V
                        \
                        \ or we jumped here from shap10 and:
                        \
                        \   * S == V
                        \   * S <> T
                        \   * U <> T
                        \   * U <> V

 LDX #12                \ Return a shape value of 12 in X

 RTS                    \ Return from the subroutine

.shap2

                        \ If we get here then then:
                        \
                        \   * S <> V
                        \   * S <> T
                        \   * U == V
                        \
                        \ and A is set to U

 CMP T                  \ If U <> T then jump to shap5
 BNE shap5

                        \ If we get here then:
                        \
                        \   * S <> V
                        \   * S <> T
                        \   * U == V
                        \   * U == T
                        \
                        \ and A is set to U

 LDX #2                 \ Set X = 2 to return as the shape if U >= S

 CMP S                  \ If U >= S then jump to shap3 to return a shape value
 BCS shap3              \ of 2

 LDX #11                \ U < S so return a shape value of 11 in X

.shap3

 RTS                    \ Return from the subroutine

.shap4

                        \ If we get here then:
                        \
                        \   * S <> V
                        \   * S == T

 LDA U                  \ If U = V then jump to shap8
 CMP V
 BEQ shap8

                        \ If we get here then:
                        \
                        \   * S <> V
                        \   * S == T
                        \   * U <> V
                        \
                        \ and A is set to U

 CMP T                  \ If U = T then jump to shap6
 BEQ shap6

.shap5

                        \ If we get here then either we jumped from shap2:
                        \
                        \   * S <> V
                        \   * S <> T
                        \   * U == V
                        \   * U <> T
                        \
                        \ or we fell through from above:
                        \
                        \   * S <> V
                        \   * S == T
                        \   * U <> V
                        \   * U <> T

 LDX #4                 \ Return a shape value of 4 in X

 RTS                    \ Return from the subroutine

.shap6

                        \ If we get here then:
                        \
                        \   * S <> V
                        \   * S == T
                        \   * U <> V
                        \   * U == T
                        \
                        \ and A is set to U

 LDX #14                \ Set X = 14 to return as the shape if U < V

 CMP V                  \ If U < V then jump to shap7 to return a shape value
 BCC shap7              \ of 14

 LDX #7                 \ U >= V so return a shape value of 7 in X

.shap7

 RTS                    \ Return from the subroutine

.shap8

                        \ If we get here then:
                        \
                        \   * S <> V
                        \   * S == T
                        \   * U == V
                        \
                        \ and A is set to U

 LDX #5                 \ Set X = 5 to return as the shape if U < T

 CMP T                  \ If U < T then jump to shap7 to return a shape value
 BCC shap9              \ of 5

 LDX #13                \ U >= T so return a shape value of 13 in X

.shap9

 RTS                    \ Return from the subroutine

.shap10

                        \ If we get here then:
                        \
                        \   * S == V
                        \
                        \ and A is set to S

 CMP T                  \ If S = T then jump to shap14
 BEQ shap14

 LDA U                  \ If U = T then jump to shap12
 CMP T
 BEQ shap12

                        \ If we get here then:
                        \
                        \   * S == V
                        \   * S <> T
                        \   * U <> T
                        \
                        \ and A is set to U

 CMP V                  \ If U <> V then jump to shap1
 BNE shap1

                        \ If we get here then:
                        \
                        \   * S == V
                        \   * S <> T
                        \   * U <> T
                        \   * U == V
                        \
                        \ and A is set to U

 LDX #6                 \ Set X = 6 to return as the shape if U < T

 CMP T                  \ If U < T then jump to shap11 to return a shape value
 BCC shap11             \ of 6

 LDX #15                \ U >= T so return a shape value of 15 in X

.shap11

 RTS                    \ Return from the subroutine

.shap12

                        \ If we get here then:
                        \
                        \   * S == V
                        \   * S <> T
                        \   * U == T
                        \
                        \ and A is set to U

 LDX #1                 \ Set X = 1 to return as the shape if U < V

 CMP V                  \ If U < V then jump to shap11 to return a shape value
 BCC shap13             \ of 1

 LDX #9                 \ U >= V so return a shape value of 9 in X

.shap13

 RTS                    \ Return from the subroutine

.shap14

                        \ If we get here then:
                        \
                        \   * S == V
                        \   * S == T
                        \
                        \ and A is set to S

 CMP U                  \ If S = U then jump to shap16
 BEQ shap16

 LDX #10                \ Set X = 10 to return as the shape if S < U

 BCC shap15             \ If S < U then jump to shap15 to return a shape value
                        \ of 10

 LDX #3                 \ S > U so return a shape value of 93 in X

.shap15

 RTS                    \ Return from the subroutine

.shap16

                        \ If we get here then:
                        \
                        \   * S == V
                        \   * S == T
                        \   * S == U

 LDX #0                 \ Return a shape value of 0 in X

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: L2CDF
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L2CDF

 EQUB &01, &21, &FF, &1F

\ ******************************************************************************
\
\       Name: tileShapeColour
\       Type: Variable
\   Category: Drawing the landscape
\    Summary: Tile colours by shape and the orientation of the viewer
\
\ ------------------------------------------------------------------------------
\
\ The colours shown in the comments below are for landscape 0000, which has the
\ following palette:
\
\   * Colour 0 = blue
\
\   * Colour 1 = black
\
\   * Colour 2 = white
\
\   * Colour 3 = green
\
\ Colours 2 and 3 can be altered depending on the context (for gameplay, the
\ palette changes depending on the number of enemies, for example). The range of
\ colours is as follows:
\
\   * Colour 2 can be white, yellow, cyan or red
\
\   * Colour 3 can be green, red, yellow or cyan
\
\ ******************************************************************************

.tileShapeColour

 EQUB 3 << 2 + 3 << 4   \ Shape  0 = colour 3 (green) and colour 0 (blue)
 EQUB 1 << 2            \ Shape  1 = colour 1 (black) and colour 0 (blue)
 EQUB 1 << 2            \ Shape  2 = colour 1 (black) and colour 2 (white)
 EQUB 2 << 2            \ Shape  3 = colour 2 (white) and colour 1 (black)
 EQUB 2 << 2            \ Shape  4 = colour 2 (white) and colour 2 (white)
 EQUB 2 << 2            \ Shape  5 = colour 2 (white) and colour 0 (blue)
 EQUB 1 << 2            \ Shape  6 = colour 1 (black) and colour 2 (white)
 EQUB 2 << 2            \ Shape  7 = colour 2 (white) and colour 1 (black)
 EQUB 0 << 2            \ Shape  8 = unused
 EQUB 1 << 2            \ Shape  9 = colour 1 (black) and colour 0 (blue)
 EQUB 2 << 2            \ Shape 10 = colour 2 (white) and colour 1 (black)
 EQUB 1 << 2            \ Shape 11 = colour 1 (black) and colour 2 (white)
 EQUB 1 << 2            \ Shape 12 = colour 1 (black) and colour 1 (black)
 EQUB 2 << 2            \ Shape 13 = colour 2 (white) and colour 0 (blue)
 EQUB 2 << 2            \ Shape 14 = colour 2 (white) and colour 1 (black)
 EQUB 1 << 2            \ Shape 15 = colour 1 (black) and colour 2 (white)
 
 EQUB 0 << 2            \ Shape  0 = colour 3 (green) and colour 0 (blue)
 EQUB 0 << 2            \ Shape  1 = colour 1 (black) and colour 0 (blue)
 EQUB 2 << 2            \ Shape  2 = colour 1 (black) and colour 2 (white)
 EQUB 1 << 2            \ Shape  3 = colour 2 (white) and colour 1 (black)
 EQUB 2 << 2            \ Shape  4 = colour 2 (white) and colour 2 (white)
 EQUB 0 << 2            \ Shape  5 = colour 2 (white) and colour 0 (blue)
 EQUB 2 << 2            \ Shape  6 = colour 1 (black) and colour 2 (white)
 EQUB 1 << 2            \ Shape  7 = colour 2 (white) and colour 1 (black)
 EQUB 0 << 2            \ Shape  8 = unused
 EQUB 0 << 2            \ Shape  9 = colour 1 (black) and colour 0 (blue)
 EQUB 1 << 2            \ Shape 10 = colour 2 (white) and colour 1 (black)
 EQUB 2 << 2            \ Shape 11 = colour 1 (black) and colour 2 (white)
 EQUB 1 << 2            \ Shape 12 = colour 1 (black) and colour 1 (black)
 EQUB 0 << 2            \ Shape 13 = colour 2 (white) and colour 0 (blue)
 EQUB 1 << 2            \ Shape 14 = colour 2 (white) and colour 1 (black)
 EQUB 2 << 2            \ Shape 15 = colour 1 (black) and colour 2 (white)

\ ******************************************************************************
\
\       Name: L2D03
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L2D03

 EQUB &00, &00, &00, &00, &00, &00, &01, &01
 EQUB &00, &00, &00, &00, &00, &00, &01, &01

\ ******************************************************************************
\
\       Name: sub_C2D36
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   L0045               ???
\
\   polygonType         The polygon type, in which we know bit 7 is set
\
\   V flag              Set according to bit 6 of polygonType
\
\ ******************************************************************************

.C2D13

 LDY L0045

 BVC C2D1E              \ If bit 6 of polygonType is clear then we are drawing
                        \ the first triangle in a two-face tile, so jump to
                        \ C2D1E to do this

                        \ If we get here then bit 6 and 7 of polygonType are
                        \ both set, so we are drawing the first triangle in a
                        \ two-face file

 CLC
 ADC #&21
 AND #&3F
 INY
 INY

.C2D1E

 STA L0C40
 STA L0C43
 EOR #&20
 STA L0C41
 CLC
 ADC L2CDF,Y
 AND #&3F
 STA L0C42
 LDX #&03
 BNE C2D58

.sub_C2D36

 LDA xTileToDraw
 ORA drawingTableOffset

 BIT polygonType        \ If bit 7 of polygonType is set then we are drawing a
 BMI C2D13              \ two-face tile as a pair of triangles, so jump to C2D13
                        \ to do this

 BVS C2D93              \ If bit 7 of polygonType is clear and bit 6 is set then
                        \ we are drawing an object, so jump to C2D93 to do this

                        \ If we get here then both bits 6 and 7 of polygonType
                        \ are clear, so we are drawing a tile as a four-sided
                        \ shape (quadrilateral)

 STA L0C40
 STA L0C44
 EOR #&20
 STA L0C41
 CLC
 ADC #&01
 STA L0C42
 EOR #&20
 STA L0C43
 LDX #&04

.C2D58

 STX polygonPointCount
 JMP C2D93

.C2D5D

 LDA #&C0
 STA L006C
 LDY polygonPointCount

.C2D63

 LDA (drawViewAngles),Y
 TAX
 LDA drawViewYawLo,X
 CLC
 ADC L0029
 STA T
 LDA drawViewYawHi,X
 ADC L0011
 ASL T
 ROL A
 ROL T
 ROL A
 ROL T
 ROL A
 STA L54A0,X
 LDA T
 ROL A
 AND #&07
 CMP #&04
 BCC C2D8A
 ORA #&F8

.C2D8A

 STA L0B40,X
 DEY
 BPL C2D63
 JMP C2DBC

.C2D93

 LDA #0
 STA L006C
 LDY polygonPointCount

.C2D99

 LDA (drawViewAngles),Y
 TAX
 LDA drawViewYawLo,X
 CLC
 ADC L0029
 STA T
 LDA drawViewYawHi,X
 ADC L0011
 CMP #&20
 BCS C2D5D
 ASL T
 ROL A
 ASL T
 ROL A
 ASL T
 ROL A
 STA L54A0,X
 DEY
 BPL C2D99

.C2DBC

 LDA #0
 STA tileAltitude
 STA zVectorLo
 STA L001E
 LDA #&FF
 STA L0004
 STA yVectorLo
 STA L007F
 LDY #0

.C2DCE

 STY L004A
 LDA (drawViewAngles),Y
 TAX
 INY
 LDA (drawViewAngles),Y
 TAY
 LDA #&5A
 STA L0002
 LDA drawViewPitchLo,Y
 SEC
 SBC drawViewPitchLo,X
 STA L000C
 LDA drawViewPitchHi,Y
 SBC drawViewPitchHi,X
 BPL C2E03
 STA V
 INC L0002
 STX T
 STY U
 LDX U
 LDY T
 LDA #0
 SEC
 SBC L000C
 STA L000C
 LDA #0
 SBC V

.C2E03

 STA V
 BIT L006C
 BVC C2E1C
 LDA L0B40,Y
 ORA L0B40,X
 BEQ C2E1C
 LDA V
 BNE C2E19
 LDA L000C
 BEQ C2E56

.C2E19

 JMP C2FCC

.C2E1C

 LDA V
 BEQ C2E2B
 LDA #0
 STA L0B40,Y
 STA L0B40,X
 JMP C2FCC

.C2E2B

 LDA L000C
 BEQ C2E96
 LDA drawViewPitchHi,Y
 STA vectorYawAngleHi
 LDA drawViewPitchLo,Y
 STA L001A
 LDA drawViewPitchHi,X
 STA vectorPitchAngleLo
 LDA drawViewPitchLo,X
 STA L0016
 LDA L54A0,Y
 STA L0018
 LDA L54A0,X
 STA L0039
 LDA #0
 STA L0041
 STA L0042
 JSR sub_C2EAE

.C2E56

 LDY L004A
 INY
 CPY polygonPointCount
 BEQ C2E60
 JMP C2DCE

.C2E60

 LDA L001E
 CMP polygonPointCount
 BNE C2E88
 LDA drawViewPitchHi,X
 BNE C2E88
 LDY drawViewPitchLo,X
 CPY minPitchAngle
 BCC C2E88
 CPY maxPitchAngle
 BCS C2E88
 STY L0004
 STY tileAltitude
 LDA yVectorLo
 STA L5A00,Y
 LDA zVectorLo
 STA L5B00,Y
 LDA #0
 STA L007F

.C2E88

 LDA L007F
 BNE C2E94
 LDA tileAltitude
 CMP L0004
 BCC C2E94
 CLC
 RTS

.C2E94

 SEC
 RTS

.C2E96

 LDA L54A0,X
 CMP zVectorLo
 BCC C2E9F
 STA zVectorLo

.C2E9F

 CMP yVectorLo
 BCS C2EA5
 STA yVectorLo

.C2EA5

 INC L001E
 JMP C2E56

.C2EAA

 JMP C3087

.CRE25

 RTS

\ ******************************************************************************
\
\       Name: sub_C2EAE
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C2EAE

 LDA vectorPitchAngleLo
 BMI C2EC2
 BNE CRE25
 LDA L0016
 CMP maxPitchAngle
 BCS CRE25
 CMP L0004
 BCS C2EC6
 CMP minPitchAngle
 BCS C2EC4

.C2EC2

 LDA minPitchAngle

.C2EC4

 STA L0004

.C2EC6

 LDA vectorYawAngleHi
 BMI CRE25
 BNE C2EDA
 LDA L001A
 CMP minPitchAngle
 BCC CRE25
 CMP tileAltitude
 BCC C2EE1
 CMP maxPitchAngle
 BCC C2EDF

.C2EDA

 LDA maxPitchAngle
 SEC
 SBC #&01

.C2EDF

 STA tileAltitude

.C2EE1

 LDA L0041
 ORA L0042
 BNE C2EAA
 LDA L0018
 SEC
 SBC L0039
 BCS C2EF9
 EOR #&FF
 CLC
 ADC #&01
 STA L000D
 LDX #&E8
 BNE C2EFD

.C2EF9

 STA L000D
 LDX #&CA

.C2EFD

 LDY L000D
 CPY L000C
 LDY L001A
 LDA L0002
 BCS C2F3B
 STA L2F2B
 STY L2F2A
 STX C2F28
 LDY L000C
 INY
 LDA L000C
 LSR A
 EOR #&FF
 CLC
 LDX vectorYawAngleHi
 BNE C2F80
 LDX L0018
 JMP C2F29

.P2F22

 ADC L000D
 BCC C2F29
 SBC L000C

.C2F28

 INX

.C2F29

L2F2A = C2F29+1
L2F2B = C2F29+2

 STX xTileMaxAltitude+63
 DEC L2F2A
 BEQ C2F37

.C2F31

 DEY
 BNE P2F22

.C2F34

 STY L007F

.CRE26

 RTS

.C2F37

 LDY #0
 BEQ C2F34

.C2F3B

 STA L2F79
 STY L2F78
 STX C2F6B
 LDY #&07
 CMP #&5A
 BEQ C2F50
 CPX #&CA
 BEQ C2F54
 BNE C2F56

.C2F50

 CPX #&CA
 BEQ C2F56

.C2F54

 LDY #&0A

.C2F56

 STY L2F6F
 LDY L000D
 INY
 LDA L000D
 LSR A
 EOR #&FF
 CLC
 LDX vectorYawAngleHi
 BNE C2FA6
 LDX L0018
 JMP C2F77

.C2F6B

 DEX
 ADC L000C

.C2F6E

L2F6F = C2F6E+1

 BCC C2F7A
 SBC L000D
 DEC L2F78
 BEQ C2F37

.C2F77

L2F78 = C2F77+1
L2F79 = C2F77+2

 STX xTileMaxAltitude+62

.C2F7A

 DEY
 BNE C2F6B
 JMP C2F34

.C2F80

 INC L2F2A
 LDX C2F28
 STX C2F94
 LDX L0018
 JMP C2F95

.P2F8E

 ADC L000D
 BCC C2F95
 SBC L000C

.C2F94

 INX

.C2F95

 DEC L2F2A
 BEQ C2FA0
 DEY
 BNE P2F8E
 JMP CRE26

.C2FA0

 DEC L2F2A
 JMP C2F31

.C2FA6

 INC L2F78
 LDX C2F6B
 STX C2FB4
 LDX L0018
 JMP C2FC0

.C2FB4

 INX
 ADC L000C
 BCC C2FC0
 SBC L000D
 DEC L2F78
 BEQ C2FC6

.C2FC0

 DEY
 BNE C2FB4
 JMP CRE26

.C2FC6

 DEC L2F78
 JMP C2F7A

.C2FCC

 STX L000E
 LDA #0
 STA vectorPitchAngleHi
 LDA L54A0,Y
 SEC
 SBC L54A0,X
 STA T
 LDA L0B40,Y
 SBC L0B40,X
 STA L000A

 JSR Absolute16Bit      \ Set (A T) = |A T|

 STA U
 ORA V
 BEQ C2FFA

.C2FEC

 LSR V
 ROR L000C
 LSR U
 ROR T
 SEC
 ROL vectorPitchAngleHi
 LSR A
 BNE C2FEC

.C2FFA

 LDX L000C
 CPX #&FF
 BEQ C2FEC
 LDX T
 CPX #&FF
 BEQ C2FEC
 LDA U
 BIT L000A

 JSR Absolute16Bit      \ Set (A T) = |A T|

 STA L0043
 LDA T
 STA xCoordHi
 LDA L54A0,Y
 STA L0039
 LDA L0B40,Y
 STA L0042
 LDA drawViewPitchHi,Y
 STA vectorPitchAngleLo
 LDA drawViewPitchLo,Y
 STA L0016
 LDA vectorPitchAngleHi
 BEQ C3054

.C302B

 LDA L0016
 STA L001A
 SEC
 SBC L000C
 STA L0016
 LDA vectorPitchAngleLo
 STA vectorYawAngleHi
 SBC #&00
 STA vectorPitchAngleLo
 LDA L0039
 STA L0018
 SEC
 SBC xCoordHi
 STA L0039
 LDA L0042
 STA L0041
 SBC L0043
 STA L0042
 JSR sub_C2EAE
 DEC vectorPitchAngleHi
 BNE C302B

.C3054

 LDA L0016
 STA L001A
 LDA vectorPitchAngleLo
 STA vectorYawAngleHi
 LDA L0039
 STA L0018
 LDA L0042
 STA L0041
 LDX L000E
 LDA drawViewPitchLo,X
 STA L0016
 LDA drawViewPitchHi,X
 STA vectorPitchAngleLo
 LDA L54A0,X
 STA L0039
 LDA L0B40,X
 STA L0042
 LDA L001A
 SEC
 SBC L0016
 STA L000C
 JSR sub_C2EAE
 JMP C2E56

.C3087

 LDA L0018
 SEC
 SBC L0039
 STA L000D
 LDA L0041
 SBC L0042
 BPL C30A4
 LDA #0
 SEC
 SBC L000D
 STA L000D
 LDX #&E8
 LDA #0
 LDY #&E6
 JMP C30AA

.C30A4

 LDX #&CA
 LDA #&FF
 LDY #&C6

.C30AA

 STY T
 STA V
 LDY L000D
 CPY L000C
 LDY L001A
 LDA L0002
 BCS C3112
 STA L30EB
 STX C30E3
 LDA vectorYawAngleHi
 BEQ C30C3
 INY

.C30C3

 STY L30EA
 LDA T
 STA C310A
 LDY L000C
 TYA
 LSR A
 EOR #&FF
 CLC
 INY
 STY U
 LDX L0018
 JSR sub_C316E
 JMP C30E9

.P30DD

 ADC L000D
 BCC C30E9
 SBC L000C

.C30E3

 INX
 CPX V
 CLC
 BEQ C310A

.C30E9

L30EA = C30E9+1
L30EB = C30E9+2

 STX L5A00
 DEC L30EA
 BEQ C30F8

.C30F1

 DEC U
 BNE P30DD
 JMP CRE26

.C30F8

 DEC vectorYawAngleHi
 BPL C30FF
 JMP CRE26

.C30FF

 BNE C30F1
 DEC L30EA
 JSR sub_C316E
 JMP C30F1

.C310A

 INC L0041
 JSR sub_C316E
 JMP C30E9

.C3112

 STA L314A
 STX C3137
 LDA vectorYawAngleHi
 BEQ C311D
 INY

.C311D

 STY L3149
 LDA T
 STA C3164
 LDY L000D
 TYA
 LSR A
 EOR #&FF
 CLC
 INY
 STY U
 LDX L0018
 JSR sub_C316E
 JMP C3148

.C3137

 INX
 CPX V
 CLC
 BEQ C3164

.C313D

 ADC L000C
 BCC C3148
 SBC L000D
 DEC L3149
 BEQ C3152

.C3148

L3149 = C3148+1
L314A = C3148+2

 STX L5A00
 DEC U
 BNE C3137
 JMP CRE26

.C3152

 DEC vectorYawAngleHi
 BPL C3159
 JMP CRE26

.C3159

 BNE C3148
 DEC L3149
 JSR sub_C316E
 JMP C3148

.C3164

 INC L0041
 JSR sub_C316E
 JMP C313D

\ ******************************************************************************
\
\       Name: CorruptSecretCode
\       Type: Subroutine
\   Category: Cracker protection
\    Summary: Corrupt the generation process for the landscape's secret code by
\             fetching one more seed number than necessary
\
\ ******************************************************************************

.CorruptSecretCode

 BCC GetNextSeedNumber  \ We only jump here with the C flag clear, so this
                        \ generates the next number from the landscape's
                        \ sequence of seed numbers, thus corrupting the
                        \ generation of the landscape's secret code
                        \
                        \ We then return to the caller using a tail call, so the
                        \ player doesn't know anything has gone wrong

\ ******************************************************************************
\
\       Name: sub_C316E
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C316E

 PHA
 LDA vectorYawAngleHi
 BEQ C3177
 LDA #&2C
 BNE C318C

.C3177

 STA L007F
 LDA L0041
 BNE C3181
 LDA #&8E
 BNE C318C

.C3181

 BPL C3188
 LDY #0
 JMP C318A

.C3188

 LDY #&FF

.C318A

 LDA #&8C

.C318C

 STA C30E9
 STA C3148
 PLA
 RTS

\ ******************************************************************************
\
\       Name: GetNextSeedNumber
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Set A to a seed number
\
\ ------------------------------------------------------------------------------
\
\ Seed numbers in The Sentinel are produced using a five-byte (40-bit) linear
\ feedback shift register (LFSR) with EOR feedback.
\
\ Specifically, to generate a new seed number, we shift the LFSR left by eight
\ places, and on each shift we insert the EOR of bits 19 and 32 into bit 0 of
\ the register. After eight shifts, the top byte is our next seed number.
\
\ ******************************************************************************

.GetNextSeedNumber

 STY yStoreNextSeed     \ Store Y in yStoreNextSeed so it can be preserved
                        \ across calls to the routine

                        \ We generate a new seed number by shifting the
                        \ five-byte linear feedback shift register in
                        \ seedNumberLFSR(4 3 2 1 0) by eight places, inserting
                        \ EOR feedback as we do so

 LDY #8                 \ Set a shift counter in Y

.rand1

 LDA seedNumberLFSR+2   \ Apply EOR feedback to the linear feedback shift
 LSR A                  \ register by taking the middle byte seedNumberLFSR+2,
 LSR A                  \ shifting it right by three places, EOR'ing it with
 LSR A                  \ seedNumberLFSR+4 in the output end of the shift
 EOR seedNumberLFSR+4   \ register and rotating bit 0 of the result into the C
 ROR A                  \ flag
                        \
                        \ This is the same as taking bit 3 of seedNumberLFSR+2
                        \ and EOR'ing it with bit 0 of seedNumberLFSR+4 into the
                        \ C flag
                        \
                        \ We now use the C flag as the next input bit into the
                        \ shift register
                        \
                        \ So this is the same as EOR'ing bits 19 and 32 of our
                        \ 40-bit register and shifting the result into bit 0 of
                        \ the register

 ROL seedNumberLFSR     \ Shift seedNumberLFSR(4 3 2 1 0) to the left by one
 ROL seedNumberLFSR+1   \ place, inserting the C flag into bit 0 of the input
 ROL seedNumberLFSR+2   \ end of the shift register in seedNumberLFSR
 ROL seedNumberLFSR+3
 ROL seedNumberLFSR+4

 DEY                    \ Decrement the shift counter

 BNE rand1              \ Loop back until we have shifted eight times

 LDY yStoreNextSeed     \ Restore the value of Y from yStoreNextSeed that we
                        \ stored at the start of the routine, so that it's
                        \ preserved

 LDA seedNumberLFSR+4   \ Set A to the output end of the shift register in
                        \ seedNumberLFSR+4 to give us our next seed number

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: yStoreNextSeed
\       Type: Variable
\   Category: Maths (Arithmetic)
\    Summary: Temporary storage for Y so it can be preserved through calls to
\             GetNextSeedNumber
\
\ ******************************************************************************

.yStoreNextSeed

 EQUB 0

\ ******************************************************************************
\
\       Name: PrintNumber
\       Type: Subroutine
\   Category: Text
\    Summary: Print a number as a single digit, printing zero as a capital "O"
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number to be printed (0 to 9)
\
\ ******************************************************************************

.PrintNumber

 CLC                    \ Convert the number in A into an ASCII digit by adding
 ADC #'0'               \ ASCII "0"

                        \ Fall into PrintDigit to print the digit in A

\ ******************************************************************************
\
\       Name: PrintDigit
\       Type: Subroutine
\   Category: Text
\    Summary: Print a numerical digit, printing zero as a capital "O"
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The numerical digit to be printed as an ASCII code
\
\ ******************************************************************************

.PrintDigit

 CMP #'0'               \ If the character in A is not a zero, jump to zero1 to
 BNE zero1              \ skip the following

 LDA #'O'               \ The character in A is a zero, so set A to ASCII "O" so
                        \ we print zero as capital "O" instead

.zero1

 BIT printTextIn3D      \ If bit 7 of printTextIn3D is set then we are printing
 BMI SpawnCharacter3D   \ 3D text, so jump to SpawnCharacter3D to spawn the
                        \ character in 3D text blocks

 JMP PrintCharacter     \ Otherwise jump to PrintCharacter to print the single-
                        \ byte VDU command or character in A, returning from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: SpawnCharacter3D (Part 1 of 2)
\       Type: Subroutine
\   Category: Title screen
\    Summary: Spawn a character on the landscape in large 3D blocks for drawing
\             on the main title screen or secret code screen
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The character to be spawned or the tile coordinates of
\                       the character on the landscape:
\
\                         * %00xxxxxx = bits 0-5 contain the ASCII code of the
\                                       character to spawn
\
\                         * %10xxxxxx = bits 0-4 contain the tile x-coordinate
\                                       of the character on the landscape
\
\                         * %11xxxxxx = bits 0-4 contain the tile z-coordinate
\                                       of the character on the landscape
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   X is preserved
\
\   Y                   Y is preserved
\
\ ******************************************************************************

.SpawnCharacter3D

 PHA                    \ Store the character on the stack so we can retrieve it
                        \ below

 STA characterDef       \ Store the character in the first byte of the OSWORD
                        \ block at characterDef, so we can extract the operating
                        \ system's character definition (if this is a printable
                        \ character)

 AND #%11000000         \ Clear all bits of the character except for bits 6 and 7

 BPL spac2              \ If bit 7 is clear then this is a printable character,
                        \ so jump to spac2 to spawn the character in 3D text
                        \ blocks

 ASL A                  \ Bit 7 is set so this is a tile coordinate, so extract
 ASL A                  \ bit 6 of the character number into the C flag

 PLA                    \ Retrieve the character number from the stack and
 AND #%00011111         \ extract bits 0-4 to get the coordinate value

 BCS spac1              \ If bit 6 of the original character number is set then
                        \ this is a tile z-coordinate, so jump to spac1 to set
                        \ zTileCharacter

 STA xTileCharacter     \ Bit 6 of the original character number is clear, so
                        \ store bits 0-4 in xTileCharacter, so we can spawn the
                        \ next printable character that's passed to the routine
                        \ in the right place

 RTS                    \ Return from the subroutine

.spac1

 STA zTileCharacter     \ Bit 6 of the original character number is set, so
                        \ store bits 0-4 in zTileCharacter, so we can spawn the
                        \ next printable character that's passed to the routine
                        \ in the right place

 RTS                    \ Return from the subroutine

.spac2

                        \ If we get here then we have a printable character in A

 TXA                    \ Store X and Y on the stack to we can preserve them
 PHA
 TYA
 PHA

 LDY #HI(characterDef)  \ Call OSWORD with A = 10 to extract the operating
 LDX #LO(characterDef)  \ system's character definition into the block at
 LDA #10                \ characterDef
 JSR OSWORD             \
                        \ The first byte of the block contains the ASCII code
                        \ of the character (which we stored above), and the call
                        \ returns the character definition from the second byte
                        \ onwards

 LDA zTileCharacter     \ Set zTile to the z-coordinate where we want to spawn
 STA zTile              \ the character

 LDX #7                 \ We now loop through the top seven rows of the
                        \ character definition, so set a row counter in X
                        \
                        \ We actually loop through the character definition
                        \ from the bottom to top, ignoring the very bottom row
                        \ of the definition as this is always blank for the
                        \ capital letters and digits that we are displaying
                        \ (the bottom row is only used for descenders, and
                        \ "THE SENTINEL" and landscape digits don't have them)
                        \
                        \ Instead we insert a blank pixel row at the top of the
                        \ definition, on the iteration when X is zero

                        \ We now have a short interlude to check some of the
                        \ anti-cracker code, so we can corrupt the secret code
                        \ being drawn on-screen if this landscape has not been
                        \ played through properly

\ ******************************************************************************
\
\       Name: CheckCrackerSeed
\       Type: Subroutine
\   Category: Cracker protection
\    Summary: Check whether the anti-cracker seed-related data is correctly set
\             up, as part of the anti-cracker code
\
\ ******************************************************************************

.CheckCrackerSeed

 LDA alteredSeed-7,X    \ Set A to the value of alteredSeed, which we set in
                        \ the AlterCrackerSeed routine

 CMP CrackerSeed+1-7,X  \ If A >= the contents of CrackerSeed+1 then the code
 BCS spac3              \ in AlterCrackerSeed was correctly run (which only
                        \ happens if the gameplay routines are run, i.e. when
                        \ the landscape has been played), so jump to spac3 to
                        \ skip the following

                        \ If we get here then the AlterCrackerSeed routine has
                        \ not been correctly run, which means the landscape was
                        \ not played properly, so we now corrupt the secret code
                        \ that's being drawn on-screen (if that's why we are
                        \ here)

 JSR CorruptSecretCode  \ At this point A < the contents of CrackerSeed+1 and
                        \ the C flag is clear, so CorruptSecretCode will call
                        \ the GetNextSeedNumber routine, which will in turn
                        \ corrupt the generation of the landscape's secret code
                        \ by moving one step too far in the landscape's sequence
                        \ of seed numbers

                        \ Fall through into part 2 of SpawnCharacter3D to
                        \ continue with the character-spawning process

\ ******************************************************************************
\
\       Name: SpawnCharacter3D (Part 2 of 2)
\       Type: Subroutine
\   Category: Title screen
\    Summary: Spawn large 3D blocks for the extracted character definition
\
\ ******************************************************************************

                        \ We now loop through the top seven rows in the
                        \ character definition, using X as the row counter
                        \
                        \ We draw the character from the bottom up on the
                        \ landscape, so that's drawing the character rows on
                        \ the landscape from front the back as we work through
                        \ the character definition from bottom to top
                        \
                        \ The row counter in X therefore iterates from 7 down
                        \ to 0, with row 7 spawning the blocks for the
                        \ penultimate row in the character definition, and row 0
                        \ spawning a blank row (as this moves the blank row in
                        \ the character definition from the bottom to the top,
                        \ as discussed in part 1)

.spac3

 ASL characterDef,X     \ The leftmost column of each character definition is
                        \ blank, so that characters are spaced out, so this
                        \ shifts the character definition row to the left to
                        \ move this blank column to the right side of the
                        \ character definition, so the character's 3D blocks
                        \ start at the correct tile coordinate

 LDA xTileCharacter     \ Set xTile to the x-coordinate where we want to spawn
 STA xTile              \ the character

                        \ Each row in the character definition consists of eight
                        \ bits (where each bit will be represented by a block on
                        \ the landscape)
                        \
                        \ In order to get tall characters on-screen, rather than
                        \ the rather square characters in the operating system's
                        \ font, we actually draw each character so that it's
                        \ four tiles wide and eight tiles tall, so each tile
                        \ contains a pair of blocks that represents a pair of
                        \ bits in the character definition

 LDA #4                 \ Set a loop counter in loopCounter to work through the
 STA loopCounter        \ four pairs in the eight-block row

.spac4

 ASL characterDef,X     \ Shift the character definition row to the left by two
 ROL A                  \ places and extract the top two bits into bits 0 and 1
 ASL characterDef,X     \ of A, so this is the leftmost block pair from this row
 ROL A

 AND #%00000011         \ Clear bits 2 to 7 of A and store the result in Y, so
 TAY                    \ Y contains the bit pattern for the two leftmost bits
                        \ in the character row
                        \
                        \ We can now use this as an index into the table that
                        \ maps bit patterns to object numbers in objBlockNumber

 LDA objBlockNumber,Y   \ Fetch the object number of the 3D text block object
                        \ that matches the bit pair that we just extracted
                        \
                        \ This actually fetches the object number + 32, though
                        \ the 32 part is removed when the block is drawn in the
                        \ DrawTileAndObjects, so this doesn't seem to have any
                        \ effect

 PHA                    \ Store the object number on the stack, as follows:
                        \
                        \   * 32 + 0 for no blocks in the pair
                        \
                        \   * 32 + 7 for no block (left), block (right)
                        \
                        \   * 32 + 8 for block (left), no block (right)
                        \
                        \   * 32 + 9 for block (left), no block (right)
                        \
                        \ This maps the pair to one of the three 3D text block
                        \ objects

 JSR GetTileData        \ Set A to the tile data for the tile anchored at
                        \ (xTile, zTile), which we ignore, but this also sets
                        \ the tile page in tileDataPage and the index in Y, so
                        \ tileDataPage+Y now points to the tile data entry in
                        \ the tileData table

 PLA                    \ Retrieve the object number for the 3D text block pair
 STA (tileDataPage),Y   \ and store it in the tile data for the tile where we
                        \ want to spawn this part of the character definition
                        \
                        \ Note that the DrawTileAndObjects routine has separate
                        \ logic when drawing 3D text, so this doesn't follow the
                        \ normal tile data rules, and instead we just need the
                        \ object number in the low nibble, which we fetched from
                        \ the objBlockNumber above

 INC xTile              \ Increment the x-coordinate to move on to the next tile
                        \ to the right, for the next bit pair

 DEC loopCounter        \ Decrement the loop counter to move onto the next bit
                        \ pair in the character definition

 BNE spac4              \ Loop back to spawn the next bit pair's objects until
                        \ we have done all four pairs in the character row

 INC zTile              \ Increment the z-coordinate to move backwards to the
                        \ tile row behind in the landscape

 DEX                    \ Decrement the character row counter in X

 BMI spac5              \ If we just spawned row 0 then X will noe be negative,
                        \ so jump to spac5 to finish off as we have spawned all
                        \ eight character rows

 BNE spac3              \ Otherwise loop back until we have spawned rows 7 to 1

                        \ If we get here then we just spawned row 1, so now we
                        \ need to spawn a blank for for row 0

 LDA #0                 \ Zero the character definition row that we will use
 STA characterDef       \ when X is 0, so we don't spawn any blocks for the top
                        \ row of the 3D text block character

 BEQ spac3              \ Jump to spac3 to spawn row 0 (this BEQ is effectively
                        \ a JMP as A is always zero)

.spac5

 LDA xTileCharacter     \ We just spawned a character in the landscape, so add 4
 CLC                    \ to xTileCharacter so the next character gets spawned
 ADC #4                 \ to the right of the one we just spawned
 STA xTileCharacter

 PLA                    \ Pull A from the stack to reverse the push that we did
                        \ at the start of the routine

 TAY                    \ Retrieve X and Y from the stack so they are preserved
 PLA
 TAX
 PLA

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: objBlockNumber
\       Type: Variable
\   Category: Title screen
\    Summary: A lookup table to convert bit pairs into object numbers for
\             spawning 3D text blocks on the landscape
\
\ ******************************************************************************

.objBlockNumber

 EQUB 32 + 0            \ %00 = no block (left), no block (right)
                        \
                        \ No 3D text blocks are required, so set the object
                        \ number to 0 to indicate no object

 EQUB 32 + 7            \ %01 = no block (left), block (right)
                        \
                        \ This is the shape of 3D text block 1, which is object
                        \ type 7

 EQUB 32 + 8           \ %10 = block (left), no block (right)
                        \
                        \ This is the shape of 3D text block 2, which is object
                        \ type 8

 EQUB 32 + 9            \ %11 = block (left), no block (right)
                        \
                        \ This is the shape of 3D text block 3, which is object
                        \ type 9

\ ******************************************************************************
\
\       Name: DrawTitleScreen
\       Type: Subroutine
\   Category: Title screen
\    Summary: Draw the title screen or the screen showing the secret code
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Determines the type of screen to draw:
\
\                         * If bit 7 = 0 then draw the title screen
\
\                         * If bit 7 = 1 then draw the secret code screen
\
\ ******************************************************************************

.DrawTitleScreen

 STA screenType         \ Store the screen type in A in screenType, so we can
                        \ refer to it below

 LDA #128               \ Set objectYawAngle+63 = 128
 STA objectYawAngle+63  \
                        \ The degree system in the Sentinel looks like this:
                        \
                        \            0
                        \      -32   |   +32         Overhead view of object
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ So this makes object #63 face directly out of the
                        \ screen

 LDA #&E0               \ For object #63, set the following:
 STA yObjectLo+63       \
 LDA #&02               \   (yObjectHi yObjectLo) = &2E0
 STA yObjectHi+63       \
                        \ So this sets the altitude of object #63 to just under
                        \ three full block heights (2.875, to be precise)
                        \
                        \ We use object #63 for drawing the 3D text blocks in
                        \ the game title in the main title screen, or the code
                        \ in the secret code screen, so this ensures that the
                        \ text blocks are drawn at the correct height to get the
                        \ title effect

 SEC                    \ Set bit 7 of drawingTitleScreen to indicate that we
 ROR drawingTitleScreen \ are drawing a title screen

 LDA #0                 \ Call ProcessTileData with A = 0 to zero the tile data
 JSR ProcessTileData    \ for the whole landscape

 BIT screenType         \ If bit 7 of the screen type is clear, jump to titl1 to
 BPL titl1              \ draw "THE SENTINEL" in large 3D text for the main title
                        \ screen

                        \ If we get here then bit 7 of the argument is set, so
                        \ we now draw the secret code

 JSR SpawnSecretCode3D  \ Spawn the secret code in large 3D text blocks

 LDX #3                 \ Set X = 3 to pass to DrawTitleView so the background
                        \ of the secret code screen is black with stars

 LDA #0                 \ Set A = 0 so the call to DrawTitleView draws a robot
                        \ on the right of the screen

 BEQ titl3              \ Jump to titl3 to skip the following and draw the robot
                        \ (this BEQ is effectively a JMP as A is always zero)

.titl1

 LDX #0                 \ We now look through all the characters in the title
                        \ text, drawing each one in turn, so set X as a
                        \ character index

.titl2

 LDA titleText,X        \ Set A to the X-th character in the title text

 JSR SpawnCharacter3D   \ Spawn the 3D text blocks for drawing the character in
                        \ A in large 3D text

 INX                    \ Increment the character index

 CPX #15                \ Loop back until we have drawn all 15 characters in the
 BCC titl2              \ title text

 LDX #1                 \ Set X = 1 to pass to DrawTitleView so the background
                        \ of the landscape preview is solid blue

 LDA #5                 \ Set A = 5 so the call to DrawTitleView draws the
                        \ Sentinel on the right of the screen

.titl3

 LDY #1                 \ Set Y = 1 to pass to DrawTitleView so it draws the
                        \ screen with the correct perspective for the title
                        \ screen

 JSR DrawTitleView      \ Draw the title screen with the object and background
                        \ defined in A and X

 LSR drawingTitleScreen \ Clear bit 7 of drawingTitleScreen to indicate we are
                        \ no longer drawing a title screen

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: screenType
\       Type: Variable
\   Category: Title screen
\    Summary: A variable that determines whether we are drawing the title screen
\             or the secret code screen in the DrawTitleScreen routine
\
\ ******************************************************************************

.screenType

 EQUB 0

\ ******************************************************************************
\
\       Name: titleText
\       Type: Variable
\   Category: Title screen
\    Summary: The text to draw on the title screen
\
\ ******************************************************************************

.titleText

 EQUB %10000000 + 4     \ Move to tile coordinate (4, 21), towards the back of
 EQUB %11000000 + 21    \ the landscape

 EQUS "THE"             \ Draw "THE" in 3D text blocks

 EQUB %10000000 + 0     \ Move to tile coordinate (0, 7), which is further
 EQUB %11000000 + 7     \ forward and a bit to the left

 EQUS "SENTINEL"        \ Draw "SENTINEL" in 3D text blocks

\ ******************************************************************************
\
\       Name: ReadNumber
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Read a number from the keyboard into the input buffer
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The maximum number of digits to read
\
\ ******************************************************************************

.ReadNumber

 STA T                  \ Set T to the maximum number of digits to read

 JSR EnableKeyboard     \ Select the keyboard as the input stream and flush the
                        \ keyboard buffer

                        \ We start by clearing the input buffer by filling it
                        \ with spaces

 LDY #7                 \ The input buffer is eight bytes long, so set a byte
                        \ counter in Y

 LDA #' '               \ Set A to the space character for use when clearing the
                        \ input buffer

.rkey1

 STA inputBuffer,Y      \ Reset the Y-th byte of the input buffer to contain a
                        \ space character

 DEY                    \ Decrement the byte counter

 BPL rkey1              \ Loop back until we have cleared the whole input buffer

 JSR PrintInputBuffer   \ Print the contents of the keyboard input buffer, which
                        \ will erase any existing text on-screen as we just
                        \ filled the input buffer with spaces

.rkey2

 LDY #0                 \ We now read the specified number of key presses, so
                        \ set Y as a counter for the number of valid characters
                        \ in the input buffer, starting from zero (as the buffer
                        \ is empty at the start)

.rkey3

 JSR ReadCharacter      \ Read a character from the keyboard into A, so A is set
                        \ to the ASCII code of the pressed key

 CMP #13                \ If RETURN was pressed then jump to rkey9 to return
 BEQ rkey9              \ from the subroutine, as RETURN terminates the input

 CMP #'0'               \ If the key pressed is less than ACSII "0" then it is a
 BCC rkey3              \ control code, so jump back to rkey3 to keep listening
                        \ for key presses, as control codes are not valid input

 CMP #127               \ If the key pressed is less than ASCII 127 then it is
 BCC rkey5              \ a printable ASCII character, so jump to rkey5 to
                        \ process it

 BNE rkey3              \ If the key pressed is not the DELETE key then jump
                        \ back to rkey3 to keep listening for key presses, as
                        \ this is not a valid input

                        \ If we get here then DELETE has been pressed, so we
                        \ need to delete the most recently entered character
                        \
                        \ Because the input buffer is stored as an ascending
                        \ stack, this means we need to delete the character at
                        \ inputBuffer, which is the top of the buffer stack,
                        \ and shuffle the rest of the stack to the left to
                        \ close up the gap (so that's shuffling then down in
                        \ memory)

 DEY                    \ Decrement Y to reduce the character count by one, as
                        \ we are about to delete a character from the buffer

 BMI rkey2              \ If we just decremented Y past zero then the buffer is
                        \ empty, so jump to rkey2 to reset Y to zero and keep
                        \ reading characters, as there is nothing to delete

 LDX #0                 \ Otherwise we want to delete the character from the top
                        \ of the buffer stack at inputBuffer and shuffle the
                        \ rest of the stack along to the left, so set an index
                        \ in X to work through the buffer from left to right

.rkey4

 LDA inputBuffer+1,X    \ Shuffle the character at index X + 1 to the left and
 STA inputBuffer,X      \ into index X

 INX                    \ Increment the buffer index to point to the next
                        \ character in the buffer as we work from left to right

 CPX #7                 \ Loop back until we have shuffled all seven characters
 BNE rkey4              \ to the left

 LDA #' '               \ Set the last character in the input buffer to a space
 STA inputBuffer+7      \ as the bottom of the stack at inputBuffer+7 is now
                        \ empty

 BNE rkey8              \ Jump to rkey8 to print the updated contents of the
                        \ input buffer, so we can see the character being
                        \ deleted, and loop back to listen for more key presses
                        \ (this BNE is effectively a JMP as A is never zero)

.rkey5

                        \ If we get here then the key press in A is a printable
                        \ ASCII character

 CMP #':'               \ If the character in A is ASCII ":" or greater then it
 BCS rkey3              \ is not a number, so jump to rkey3 to keep listening
                        \ for key presses, as we are only interested in numbers

 CPY T                  \ If Y <> T then the buffer does not yet contain the
 BNE rkey6              \ maximum number of digits allowed, so jump to rkey6 to
                        \ process the number key press

 LDA #7                 \ Otherwise the buffer is already full, so perform a
 JSR OSWRCH             \ VDU 7 command to make a system beep

 JMP rkey3              \ Jump back to rkey3 to listen for more key presses

.rkey6

                        \ If we get here then the key press in A is a number key
                        \ and the input buffer is not full

 INY                    \ Increment Y to increase the character count by one, as
                        \ we are about to add a character to the buffer

 PHA                    \ Store the key number in A on the stack, so we can
                        \ retrieve it after the following loop

 LDX #6                 \ We now want to insert the new character into the top
                        \ of the buffer stack at inputBuffer and shuffle the
                        \ stack along to the right (so that's shuffling then up
                        \ in memory), so set an index in X to work through the
                        \ buffer from right to left

.rkey7

 LDA inputBuffer,X      \ Shuffle the character at index X to the right and into
 STA inputBuffer+1,X    \ index X + 1

 DEX                    \ Decrement the buffer index to point to the next
                        \ character in the buffer as we work from right to left

 BPL rkey7              \ Loop back until we have shuffled all seven characters
                        \ to the right

 PLA                    \ Restore the key number that we stored on the stack
                        \ above

 STA inputBuffer        \ Store the key press at the top of the stack, in
                        \ inputBuffer

.rkey8

 JSR PrintInputBuffer   \ Print the contents of the keyboard input buffer so we
                        \ we can see the characters being entered or deleted

 JMP rkey3              \ Jump back to rkey3 to listen for more key presses

.rkey9

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintInputBuffer
\       Type: Subroutine
\   Category: Text
\    Summary: Print the contents of the keyboard input buffer
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   T                   The size of the input buffer
\
\ ******************************************************************************

.PrintInputBuffer

 SEC                    \ Set bit 7 of textDropShadow so the following text is
 ROR textDropShadow     \ printed without a drop shadow

                        \ We now print the contents of the input buffer
                        \
                        \ Key presses are stored in the input buffer using an
                        \ ascending stack, with new input being pushed into
                        \ inputBuffer, so to print the contents of the buffer,
                        \ we need to print it backwards, from the oldest input
                        \ at index T - 1 down to the most recent input at
                        \ index 0

 LDX T                  \ Set X = T - 1 so we can use X as an index into the
 DEX                    \ buffer, starting from the oldest input

.pinb1

 LDA inputBuffer,X      \ Set A to the X-th entry in the input buffer

 JSR PrintDigit         \ Print the numerical digit in A

 DEX                    \ Decrement the buffer index

 BPL pinb1              \ Loop back until we have printed the whole buffer

                        \ We now want to backspace by the number of characters
                        \ we just printed, to leave the cursor at the start of
                        \ the printed number

 LDX T                  \ Set X to the size of the input buffer, which we can
                        \ use as a character counter in the following loop to
                        \ ensure we backspace by the correct number of
                        \ characters to reach the start of printed number

 LDA #8                 \ Set A = 8 to perform a series of VDU 8 commands, each
                        \ of which will backspace the cursor by one character

.pinb2

 JSR PrintDigit         \ Print the character in A, which performs a VDU 8 to
                        \ backspace the cursor by one character

 DEX                    \ Decrement the character counter

 BNE pinb2              \ Loop back until we have backspaced to the start of the
                        \ buffer contents that we just printed

 LSR textDropShadow     \ Clear bit 7 of textDropShadow so text tokens are once
                        \ again printed with drop shadows

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: StringToNumber
\       Type: Subroutine
\   Category: Text
\    Summary: Convert a string of ASCII digits in the input buffer in-place into
\             a multi-byte BCD number
\
\ ******************************************************************************

.StringToNumber

 LDY #0                 \ We want to work through the input buffer, converting
                        \ each character in turn from an ASCII digit into a
                        \ number, so set an index in Y to work through the
                        \ buffer, one ASCII digit at a time

 LDX #0                 \ Each pair of ASCII digits gets converted into a value
                        \ that will fit into a single BCD byte, which we store
                        \ in-place, so set an index in X to work through the
                        \ buffer, so we can store the resulting BCD number one
                        \ byte at a time (i.e. two ASCII digits at a time)

.snum1

                        \ We now fetch two digits from the input buffer and
                        \ convert them into a single BCD number, remembering
                        \ that the input buffer is stored as an ascending stack,
                        \ so the digits on the left of the stack (i.e. those
                        \ that were typed first) are lower significance than
                        \ those on the right of the stack (i.e. those that were
                        \ typed last)
                        \
                        \ Effectively the stack is little-endian, just like the
                        \ 6502 processor
                        \
                        \ The calls to DigitToNumber will backfill the input
                        \ buffer with &FF if we are reading from the last four
                        \ characters of the input buffer, so the final result
                        \ will have four BCD numbers at the start of inputBuffer
                        \ (from inputBuffer to inputBuffer+3), and the rest of
                        \ the buffer will be padded out with four &FF bytes
                        \ (from inputBuffer+4 to inputBuffer+7)

 JSR DigitToNumber      \ Set T to the numerical value of the character at index
 STA T                  \ Y in the input buffer, which is the low significance
                        \ digit of the number we are fetching, and in the range
                        \ 0 to 9

 INY                    \ Increment Y to the next character in the input buffer

 JSR DigitToNumber      \ Set A to the numerical value of the character at index
                        \ Y in the input buffer, which is the high significance
                        \ digit of the number we are fetching, and in the range
                        \ 0 to 9

 ASL A                  \ Shift the high significance digit in A into bits 4-7,
 ASL A                  \ so A contains the first digit of the BCD number
 ASL A
 ASL A

 ORA T                  \ Insert the high significance digit in T into bits 0-3,
                        \ so A now contains both the first and second digits of
                        \ the BCD number

 STA inputBuffer,X      \ Store the BCD number in-place at index X

 INX                    \ Increment the result index in X to move on to the next
                        \ BCD number

 INY                    \ Increment the buffer index in Y to move on to the next
                        \ pair of digits

 CPY #8                 \ Loop back until we have converted the whole string
 BNE snum1              \ into a multi-byte BCD number

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DigitToNumber
\       Type: Subroutine
\   Category: Text
\    Summary: Convert a digit from the input buffer into a number
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The offset into the input buffer of the digit to convert
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   The numerical value of the digit (0 to 9), where spaces
\                       are converted to 0
\
\ ******************************************************************************

.DigitToNumber

 LDA inputBuffer,Y      \ Set A to the ASCII digit from the input buffer that we
                        \ want to convert

 CPY #4                 \ If Y < 4 then jump to dnum1 to skip the following
 BCC dnum1

                        \ Y is 4 or more, so we set this character in the input
                        \ buffer to &FF so that as we work through the buffer in
                        \ the StringToNumber routine, converting pairs of ASCII
                        \ digits into single-byte BCD numbers, we backfill the
                        \ buffer with &FF

 PHA                    \ Set the Y-th character in the input buffer to &FF,
 LDA #&FF               \ making sure not to corrupt the value of A
 STA inputBuffer,Y
 PLA

.dnum1

 CMP #' '               \ If the character in the input buffer is not a space
 BNE dnum2              \ then it must be a digit, so jump to dmum2 to convert
                        \ it into a number

 LDA #'0'               \ Otherwise the character from the input buffer is a
                        \ space, so set A to ASCII "0" so we return a value of
                        \ zero in the following subtraction

.dnum2

 SEC                    \ Convert the ASCII digit into a number by subtracting
 SBC #'0'               \ ASCII "0"

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: Print2DigitBCD
\       Type: Subroutine
\   Category: Text
\    Summary: Print a binary coded decimal (BCD) number using two digits
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number to print (in BCD)
\
\ ******************************************************************************

.Print2DigitBCD

 PHA                    \ Store A on the stack so we can retrieve it later

 LSR A                  \ Shift the high nibble of A into bits 0-3, so A
 LSR A                  \ contains the first digit of the BCD number
 LSR A
 LSR A

 JSR PrintNumber        \ Print the number in A as a single digit

 PLA                    \ Retrieve the original value of A, which contains the
                        \ BCD number to print

 AND #%00001111         \ Extract the low nibble of the BCD number into A

 JMP PrintNumber        \ Print the number in A as a single digit and return
                        \ from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: GetNextSeedAsBCD
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Set A to the next number from the landscape's sequence of seed
\             numbers, converted to a binary coded decimal (BCD) number
\
\ ******************************************************************************

.GetNextSeedAsBCD

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers

                        \ We now convert this into a binary coded decimal (BCD)
                        \ number by ensuring that both the low nibble and high
                        \ nibble are in the range 0 to 9

 PHA                    \ Store A on the stack so we can retrieve it below

 AND #%00001111         \ Extract the low nibble of A, so it's in the range 0 to
                        \ 15

 CMP #10                \ If A >= 10 then set A = A - 6
 BCC rbcd1              \
 SBC #6                 \ This reduces the number in A to the range 0 to 9, so
                        \ it's suitable for the second digit in a BCD number
                        \
                        \ The subtraction will work because the C flag is set by
                        \ the time we reach the SBC instruction

.rbcd1

 STA lowNibbleBCD       \ Store the low nibble of the result in lowNibbleBCD

 PLA                    \ Retrieve the original value of A that we stored on the
                        \ stack above

 AND #%11110000         \ Extract the high nibble of A, so it's in the range 0
                        \ to 15

 CMP #10<<4             \ If the high nibble in A >= 10 then subtract 6 from the
 BCC rbcd2              \ high nibble
 SBC #6<<4              \
                        \ This reduces the high nibble of the number in A to the
                        \ range 0 to 9, so it's suitable for the first digit in
                        \ a BCD number
                        \
                        \ The subtraction will work because the C flag is set by
                        \ the time we reach the SBC instruction

.rbcd2

 ORA lowNibbleBCD       \ By this point A contains a BCD digit in the high
                        \ nibble and lowNibbleBCD contains a BCD digit in the
                        \ low nibble, so we can OR them together to produce a
                        \ BCD number in A, which we can return as our result

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: lowNibbleBCD
\       Type: Variable
\   Category: Maths (Arithmetic)
\    Summary: Storage for the low nibble when constructing a BCD seed number in
\             the GetNextSeedAsBCD routine
\
\ ******************************************************************************

.lowNibbleBCD

 EQUB 0

\ ******************************************************************************
\
\       Name: SpawnSecretCode3D
\       Type: Subroutine
\   Category: Title screen
\    Summary: Draw the landscape's secret code by spawning a set of large 3D
\             text block objects
\
\ ******************************************************************************

.SpawnSecretCode3D

 LDA #%10000000 + 0     \ Set bit 7 of printTextIn3D so we print the landscape's
 STA printTextIn3D      \ secret code in 3D text when we call Print2DigitBCD
                        \ below

 JSR SpawnCharacter3D   \ Call SpawnCharacter3D with A = #%10000000 + 0 to set
                        \ the tile x-coordinate of the large 3D secret code text
                        \ to zero

 LDA #%11000000 + 7     \ Call SpawnCharacter3D with A = #%11000000 + 7 to set
 JSR SpawnCharacter3D   \ the tile z-coordinate of the large 3D secret code text
                        \ to 7
                        \
                        \ So we draw the secret code in large 3D text blocks at
                        \ tile coordinate (0, 7) on the landscape, so that's
                        \ starting at the left edge of the landscape and seven
                        \ tile rows from the front

 LSR playerIsOnTower    \ If we got here legally (i.e. without crackers getting
                        \ involved, then the ProcessActionKeys will have set
                        \ playerIsOnTower to 6 when the player transferred into
                        \ the robot on the Sentinel's tower, so this sets the
                        \ value of playerIsOnTower to 3

 LDX playerIsOnTower    \ Set X = 3 to use as a loop in the following code
                        \
                        \ If crackers have jumped straight here instead of
                        \ playing the game properly, then X will not be 3 (it
                        \ will probably be 64, as playerIsOnTower is initialised
                        \ to 128 at the start of each level)
                        \
                        \ The following code picks up where the CheckSecretCode
                        \ routine ends, for when bit 7 of doNotPlayLandscape is
                        \ set
                        \
                        \ In this case, CheckSecretCode only iterates up to the
                        \ point where the secret code is about to be generated,
                        \ and then it stops, so we can finish the generation
                        \ process here
                        \
                        \ For this to work, we need to set X = 3 so we can
                        \ generate the next four BCD numbers in the landscape's
                        \ sequence of seed numbers, as these will give us the
                        \ secret code
                        \
                        \ If X is 64, then the secret code that is generated
                        \ will be incorrect

.dsec1

 JSR GetNextSeedAsBCD   \ Set A to the next number from the landscape's sequence
                        \ of seed numbers, converted to a binary coded decimal
                        \ (BCD) number

 CPX #4                 \ If X >= 4, skip printing the BCD number, so that we
 BCS dsec2              \ skip printing the four correct secret code numbers if
                        \ X starts the loop at 64

 JSR Print2DigitBCD     \ Draw the binary coded decimal (BCD) number in A in
                        \ large 3D text

.dsec2

 DEX                    \ Decrement the loop counter

 BPL dsec1              \ Loop back until we have printed the four BCD numbers
                        \ in the landscape's secret code

 STX playerIsOnTower    \ Set playerIsOnTower = &FF to overwrite the correct
                        \ value, to make it harder for crackers to work out why
                        \ their secret codes aren't valid

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers

 LSR printTextIn3D      \ Clear bit 7 of printTextIn3D to return to printing
                        \ normal text

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: PrintLandscapeNum
\       Type: Subroutine
\   Category: Text
\    Summary: Print the four-digit landscape number (0000 to 9999)
\
\ ******************************************************************************

.PrintLandscapeNum

 LDA landscapeNumberHi  \ Print the high byte of the binary coded decimal (BCD)
 JSR Print2DigitBCD     \ landscape number as a two-digit number

 LDA landscapeNumberLo  \ Print the low byte of the binary coded decimal (BCD)
 JMP Print2DigitBCD     \ landscape number as a two-digit number and return from
                        \ the subroutine using a tail call

\ ******************************************************************************
\
\       Name: InitialiseSeeds
\       Type: Subroutine
\   Category: Landscape
\    Summary: Initialise the seed number generator so it generates the sequence
\             of seed numbers for a specific landscape number
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   (Y X)               A landscape number in BCD (0000 to 9999)
\
\ ******************************************************************************

.InitialiseSeeds

 STY seedNumberLFSR+1   \ Initialise the seed number generator by setting bits
 STX seedNumberLFSR     \ 0-15 of the five-byte linear feedback shift register
                        \ to the landscape number
                        \
                        \ This ensures that the GetNextSeedNumber routine (and
                        \ related routines) will generate a unique sequence of
                        \ pseudo-random numbers for this landscape, and which
                        \ will be the exact same sequence every time we need to
                        \ generate this landscape
                        \
                        \ It also ensures that the third number to be generated
                        \ by the shift register is the high byte of the
                        \ landscape number that we put into seedNumberLFSR+1, as
                        \ at this early stage of the process the EOR feedback
                        \ does not affect this byte as it passes through the
                        \ shift register, so after three 8-bit shifts the high
                        \ byte reaches seedNumberLFSR+4 and is returned as the
                        \ next seed number
                        \
                        \ This fact is exploited by the anti-cracker code in the
                        \ SetCrackerSeed routine

 STY landscapeNumberHi  \ Set (landscapeNumberHi landscapeNumberLo) = (Y X)
 STX landscapeNumberLo

 STY landscapeZero      \ If the high byte of the landscape number is non-zero,
 TYA                    \ then set landscapeZero to this non-zero value (to
 BNE seed1              \ indicate that we are not playing landscape 0000) and
                        \ jump to seed1 to set maxNumberOfEnemies to 8

 TXA                    \ Set landscapeZero to the low byte of the landscape,
 STA landscapeZero      \ so this sets landscapeZero to zero if we are playing
                        \ landscape 0000, and it sets it to a non-zero value if
                        \ we are not
                        \
                        \ So landscapeZero is now correctly set to indicate
                        \ whether or not we are playing landscape 0000

 LSR A                  \ Set A to the high byte of the BCD landscape number
 LSR A                  \ plus 1, which is the same as saying:
 LSR A                  \
 LSR A                  \   A = 1 + (landscapeNumber div 10)
 CLC                    \
 ADC #1                 \ Or A is 1 plus the "tens" digit of the landscape
                        \ number

 CMP #9                 \ If A < 9 then A is in the range 1 to 8, so jump to
 BCC seed2              \ seed2 to set maxNumberOfEnemies to this value

                        \ Otherwise A is 9 or higher, so we now cap A to 8 as
                        \ the maximum allowed value for maxNumberOfEnemies

.seed1

 LDA #8                 \ Set A = 8 to use as the maximum number of enemies

.seed2

 STA maxNumberOfEnemies \ Set maxNumberOfEnemies to the value in A, so we get
                        \ the following cap on the number of enemies:
                        \
                        \   min(8, 1 + (landscapeNumber div 10))
                        \
                        \ So landscapes 0000 to 0009 have a maximum enemy count
                        \ of 1, landscapes 0010 to 0019 have a maximum enemy
                        \ count of 2, and so on up to landscapes 0070 and up,
                        \ which have a maximum enemy count of 8

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ProcessCharacter
\       Type: Subroutine
\   Category: Text
\    Summary: Process and print a character from a text token, which can encode
\             another text token or be a one-byte character or VDU command
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The text token character to be printed
\
\   Y                   The offset of the current character within the text
\                       token being printed
\
\ ******************************************************************************

.ProcessCharacter

 CMP #200               \ If the character in A >= 200 then it represents a text
 BCS char1              \ token, so jump to char1 to print the token

 JMP PrintVduCharacter  \ Otherwise the character in A is a simple one-byte
                        \ character or VDU command, so jump to PrintVduCharacter
                        \ to print it

.char1

 SBC #200               \ Set A = A - 200
                        \
                        \ As we store recursive tokens within other tokens by
                        \ encoding then as 200 + the token number, this extracts
                        \ the recursive token number into A, so we can print it
                        \
                        \ This subtraction works because we jumped here with a
                        \ BCS, so we know that the C flag is set

 TAX                    \ Set X to the token we want to print, to pass to the
                        \ PrintTextToken routine

 TYA                    \ Store Y on the stack so we can retrieve it below
 PHA

 JSR PrintTextToken     \ Print the text token in X

 PLA                    \ Retrieve Y from the stack, so Y now contains the
 TAY                    \ offset of the token we just printed within the parent
                        \ token that we are still printing

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetEnemyCount
\       Type: Subroutine
\   Category: Landscape
\    Summary: Calculate the number of enemies for the current landscape
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   The enemy count for the landscape (in the range 1 to 8,
\                       with higher values for higher landscape numbers)
\
\ ******************************************************************************

.GetEnemyCount

 LDA landscapeNumberHi  \ Set T = (landscapeNumberHi / 4) + 2
 LSR A                  \
 LSR A                  \ Because the landscape number is in BCD and in the form
 LSR A                  \ 0000 to 9999, this extracts the top digit and adds 2
 LSR A                  \
 CLC                    \ So T is in the range 2 to 11, with higher values of T
 ADC #2                 \ for higher landscape numbers
 STA T

.enem1

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers, which we now use to calculate the
                        \ enemy count for this landscape (so the same number is
                        \ calculated for the same landscape number each time)

 LDY #7                 \ Set Y = 7 to use as the count of clear bits in A when
                        \ A is zero

 ASL A                  \ Set the C flag from bit 7 of this landscape's seed
                        \ number and clear bit 0 of A, leaving bits 6 to 0 of
                        \ the original A in bits 7 to 1

 PHP                    \ Store the status flags on the stack, so we can use the
                        \ C flag below to decide whether to negate the result

                        \ We now count the number of continuous clear bits at
                        \ the top of A, ignoring bit 0, so we count zeroes from
                        \ bit 7 down until we hit a 1, and put the result into Y

 BEQ enem3              \ If A = 0 then jump to enem3 with Y = 7, as we have a
                        \ continuous run of seven clear bits in bits 7 to 1

 LDY #&FF               \ Otherwise set Y = -1 so the following loop counts the
                        \ number of zeroes correctly

.enem2

 INY                    \ Increment the zero counter in Y

 ASL A                  \ Shift A to the left, moving the top bit into the C
                        \ flag

 BCC enem2              \ Loop back to keep shifting and counting zeroes until
                        \ we shift a 1 out of bit 7, at which point Y contains
                        \ the length of the run of zeroes in bits 6 to 0 of the
                        \ landscape's original seed number

.enem3

 TYA                    \ At this point Y contains a number in the range 0 to 7,
                        \ so copy this into A

 PLP                    \ If the C flag we stored on the stack above was set,
 BCC enem4              \ invert A, so this flips the result into the range -1
 EOR #%11111111         \ to -8 if bit 7 of the landscape's original seed number
                        \ was set

.enem4

                        \ At this point A is in the range -8 to 7

 CLC                    \ Set A = A + T
 ADC T                  \
                        \ T is in the range 2 to 11, so A is now in the range
                        \ -6 to 18

 CMP #8                 \ If A < 0 or A >= 8 then loop back to enem1 to try
 BCS enem1              \ again

                        \ If we get here then A is now in the range 0 to 7, with
                        \ higher values for higher landscape numbers

 ADC #1                 \ Set A = A + 1
                        \
                        \ This addition works as we know the C flag is clear
                        \ because we just passed through a BCS

                        \ So A is now a number in the range 1 to 8, with higher
                        \ values for higher landscape numbers, which we can use
                        \ as our enemy count (after capping it to the value of
                        \ maxNumberOfEnemies after we return from the
                        \ subroutine)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetNextSeed0To22
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Set A to the next number from the landscape's sequence of seed
\             numbers, converted to the range 0 to 22
\
\ ******************************************************************************

.GetNextSeed0To22

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers

 PHA                    \ Set T to bits 0-2 of A
 AND #%00000111         \
 STA T                  \ So T is a number in the range 0 to 7
 PLA

 LSR A                  \ Set A to bits 3-6 of A and clear the C flag
 LSR A                  \
 AND #%00011110         \ So T is a number in the range 0 to 15
 LSR A

 ADC T                  \ Set A = A + T
                        \
                        \ So A is a number in the range 0 to 22

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetPlayerEnergyBCD
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Fetch the player's energy in binary coded decimal (BCD)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   The player's energy in BCD
\
\ ******************************************************************************

.GetPlayerEnergyBCD

 LDA #0                 \ Set A = 0 to use as the player's energy in binary
                        \ coded decimal (BCD)

 LDX playerEnergy       \ Set X to the player's energy level

 BEQ plen2              \ If X = 0 then jump to plen2 to return A = 0 as the
                        \ player's energy in BCD

                        \ Otherwise we convert X into BCD by simply adding 1 to
                        \ A and repeating this X times
                        \
                        \ This works because we only call this routine when the
                        \ D flag is set to switch arithmetic to BCD
.plen1

 CLC                    \ Increment the BCD number we are building in A
 ADC #1

 DEX                    \ Decrement the player's energy level in S

 BNE plen1              \ Loop back until we have added 1 to A, X times, so A
                        \ now contains the original value of X but in BCD

.plen2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MakeSound
\       Type: Subroutine
\   Category: Sound
\    Summary: Make a sound
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number of the sound to make (0 to 6):
\
\                         * 0 = ??? (two-part)
\
\                         * 1 = ??? (two-part)
\
\                         * 2 = ???
\
\                         * 3 = ???
\
\                         * 4 = ???
\
\                         * 5 = ping
\
\                         * 6 = ??? (two-part)
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   MakeSound-6         Make a two-part sound at the pitches defined in X and Y,
\                       where X is the pitch for sound data block #0 and Y is
\                       the pitch for sound data block #1
\
\ ******************************************************************************

 STX soundData+4        \ Set the third parameter of sound data block #0 to X,
                        \ to set the pitch of the first sound

 STY soundData+12       \ Set the third parameter of sound data block #1 to X,
                        \ to set the pitch of the second sound

.MakeSound

 PHA                    \ Store the sound number on the stack

 SEC                    \ Decrement A, keeping the result positive
 SBC #1
 BCS soun1
 ADC #1

.soun1

 JSR DefineEnvelope     \ Define envelope data A from the envelopeData table, so
                        \ sounds #0 and #1 both define envelope data 0, while
                        \ sounds #2 to #6 define envelope data 1 to 5

 PLA                    \ Retrieve the sound number from the stack and put it
 TAX                    \ into X, so we can use it as an index

 LDA soundNumberData,X  \ Set A to the corresponding entry from soundNumberData
                        \ for the sound number in X, which tells us which blocks
                        \ of sound data to use from the soundData table when
                        \ making the sound

 CMP #1                 \ If A <> 1 then jump to soun2 to make the sound using
 BNE soun2              \ the sound data in soundData block number A

                        \ If A = 1 then this is a two-part sound, with the first
                        \ part using the sound data in soundData block number A
                        \ and the second using the sound data in soundData block
                        \ zero

 JSR soun2              \ Call soun2 to make the first sound using the sound
                        \ data in soundData block number A

 LDA #0                 \ Set A = 0 and fall through into soun2 to make the
                        \ second sound using the sound data in soundData block
                        \ zero

.soun2

                        \ At this point we have the number of a soundData block
                        \ in A, in the range 0 to 4, so now we make the sound
                        \ using that sound data

 ASL A                  \ Set (Y X) = soundData + A * 8
 ASL A                  \
 ASL A                  \ starting with the low byte (we set the high byte in
 ADC #LO(soundData)     \ MakeSoundEnvelope)
 TAX                    \
                        \ Each sound data block in soundData contains 8 bytes
                        \ of data, so this sets (Y X) to the address within
                        \ the soundData table of the data block specified in A

 LDA #7                 \ Set A = 7 for the OSWORD command to make a sound

 BNE MakeSoundEnvelope  \ Jump to MakeSoundEnvelope to set up Y and apply the
                        \ OSWORD command to the (Y X) block, which makes the
                        \ relevant sound (this BNE is effectively a JMP as A is
                        \ never zero)

\ ******************************************************************************
\
\       Name: DefineEnvelope
\       Type: Subroutine
\   Category: Sound
\    Summary: Define a sound envelope
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number of the sound envelope data block to define in
\                       the envelopeData table (0 to 5)
\
\ ******************************************************************************

.DefineEnvelope

 STA aStoreEnvelope     \ Set (Y X) = envelopeData + (A * 8 - A) * 2
 ASL A                  \           = envelopeData + A * 7 * 2
 ASL A                  \           = envelopeData + A * 14
 ASL A                  \
 SEC                    \ starting with the low byte (we set the high byte in
 SBC aStoreEnvelope     \ MakeSoundEnvelope)
 ASL A                  \
 ADC #LO(envelopeData)  \ Each envelope definition in envelopeData contains 14
 TAX                    \ bytes of data, so this sets A to the address within
                        \ the envelopeData table of the data for the envelope
                        \ number in A

 LDA #8                 \ Set A = 8 for the OSWORD command to define an envelope

                        \ Fall through into MakeSoundEnvelope to set up Y and
                        \ apply the OSWORD command to the (Y X) block, which
                        \ defines the relevant sound envelope

\ ******************************************************************************
\
\       Name: MakeSoundEnvelope
\       Type: Subroutine
\   Category: Sound
\    Summary: Either make a sound or set up an envelope
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The action:
\
\                         * A = 7 to make a sound
\
\                         * A = 8 to define a sound envelope
\
\   X                   The low byte of the address of the OSWORD block
\
\ ******************************************************************************

.MakeSoundEnvelope

 LDY #HI(soundData)     \ Set Y to the high byte of the soundData block address,
                        \ which is the same as the high byte of the envelopeData
                        \ block address, so (Y X) now points to the relevant
                        \ envelope or sound or sound data block

 JMP OSWORD             \ Call OSWORD with action A, as follows:
                        \
                        \  * A = 7 to make the sound at (Y X)
                        \
                        \  * A = 8 to set up the sound envelope at (Y X)
                        \
                        \ and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: aStoreEnvelope
\       Type: Variable
\   Category: Sound
\    Summary: Temporary storage for use in the DefineEnvelope routine
\
\ ******************************************************************************

.aStoreEnvelope

 EQUB 0

\ ******************************************************************************
\
\       Name: soundNumberData
\       Type: Variable
\   Category: Sound
\    Summary: A table to map a sound number (0 to 6) to the sound data block(s)
\             that are used to make the sound
\
\ ******************************************************************************

.soundNumberData

 EQUB 1                 \ Sound #0 = sound data block #1 then block #0

 EQUB 1                 \ Sound #1 = sound data block #1 then block #0

 EQUB 4                 \ Sound #2 = sound data block #4

 EQUB 2                 \ Sound #3 = sound data block #2

 EQUB 2                 \ Sound #4 = sound data block #2

 EQUB 3                 \ Sound #5 = sound data block #3

 EQUB 1                 \ Sound #6 = sound data block #1 then block #0

\ ******************************************************************************
\
\       Name: ProcessVolumeKeys
\       Type: Subroutine
\   Category: Sound
\    Summary: Adjust the volume of the sound envelopes when the volume keys are
\             pressed
\
\ ******************************************************************************

.ProcessVolumeKeys

 LDA focusOnKeyAction   \ If bit 7 of focusOnKeyAction is set then the game is
 BMI volk6              \ focusing effort on a key action such as a landscape
                        \ pan, so jump to volk6 to return from the subroutine
                        \ without checking for volume-related key presses

 LDA volumeLevel        \ Set A to the current volume level

 LDX keyLogger+3        \ Set X to the key logger entry for "7", "8", COPY and
                        \ DELETE (volume down, volume up, pause, unpause)

 BEQ volk1              \ If X = 0 then "7" (volume down) has been pressed, so
                        \ jump to volk1 ???

                        \ If we get here then X must be 1, 2 or 3 (for "8",
                        \ COPY and DELETE)

 DEX                    \ If X - 1 <> 0 then the original key logger entry must
 BNE volk6              \ be 2 or 3 (COPY or DELETE), so jump to volk6 to
                        \ return from the subroutine

                        \ If we get here then the key logger entry must be 1,
                        \ so "8" (volume up) has been pressed

 CMP #120               \ If A >= 120 then the volume level is already at the
 BCS volk2              \ maximum level of 120, so jump to volk2 without
                        \ changing it

 ADC #8                 \ Otherwise we can turn the volume up, so add 8 to the
                        \ volume level in A (the addition works because we know
                        \ we just passed through a BCS, so we know the C flag is
                        \ clear)

 BNE volk2              \ Jump to volk1 to update the volume level

.volk1

                        \ If we get here then "7" (volume down) has been pressed

 CMP #0                 \ If A = 0 then the volume level is already at the
 BEQ volk2              \ minimum level of 0, so jump to volk2 without changing
                        \ it

 SBC #8                 \ Otherwise we can turn the volume down, so subtract 8
                        \ from the volume level in A (the subtraction works
                        \ because we know that A > 0, so the CMP above will have
                        \ set the C)

.volk2

 LDX soundCounter       \ If soundCounter >= 2 then a sound is currently being
 CPX #2                 \ made (such as the confirmation ping we make when
 BCS ProcessVolumeKeys  \ changing the volume level) and it hasn't finished yet,
                        \ so loop back to the start of the routine to keep
                        \ checking for key presses and without changing the
                        \ volume, as we only want to change the volume when we
                        \ can make a pinging sound so the player can hear the
                        \ effect of the volume change

 STA volumeLevel        \ Update the volume level in volumeLevel to the new
                        \ value

 TAY                    \ Set Y to 0 (if the volume has been turned right down)
 BEQ volk3              \ or to 8 (if the volume level is non-zero)
 LDY #8

.volk3

 STY envelopeData+42+13 \ Set parameter #13 of envelope 3 to Y, to set the ALD
                        \ for the sound (the amplitude target level at the end
                        \ of the decay phase)

 STY envelopeData+28+13 \ Set parameter #13 of envelope 2 to Y, to set the ALD
                        \ for the sound (the amplitude target level at the end
                        \ of the decay phase)

 LDY #11                \ We now work through the envelopeVolumes table, which
                        \ contains offsets into the envelopeData table of the
                        \ bytes that control the volume of each envelope
                        \
                        \ We update each of the bytes to reflect the new volume
                        \ level, so set a counter in Y to work through all 12
                        \ bytes of envelope data

.volk4

 LDX envelopeVolumes,Y  \ Fetch the Y-th entry of the envelopeVolumes table into
                        \ X, so it contains the offset within the envelopeData
                        \ table that we need to update

 CPX #79                \ If this is not the entry at the beginning of the table
 BNE volk5              \ (which will be the last to be processed), jump to
                        \ volk5 to set the envelope byte to the new volume level

 EOR #%11111111         \ If this is the entry at the beginning of the table,
 ADC #0                 \ negate the volume level in A, as this entry is for the
                        \ AD parameter (the change of amplitude per step during
                        \ the decay phase), and we want this aspect to drop more
                        \ quickly at higher volume levels

.volk5

 STA envelopeData,X     \ Set the X-th byte of the envelope data to the volume
                        \ level in A

 DEY                    \ Decrement the envelope byte counter

 BPL volk4              \ Loop back until we have updated all 12 bytes with the
                        \ new volume level

 LDA #12                \ Set soundCounter = 12 to count down while the ping
 STA soundCounter       \ sound is made

 LDA #5                 \ Make sound #5 (ping) so the player can hear the new
 JSR MakeSound          \ volume level

 JMP ProcessVolumeKeys  \ Loop back to the start of the routine to keep checking
                        \ for key presses

.volk6

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: volumeLevel
\       Type: Variable
\   Category: Sound
\    Summary: The volume level, which can be changed by pressing "7" and "8"
\
\ ******************************************************************************

.volumeLevel

 EQUB 88

\ ******************************************************************************
\
\       Name: envelopeVolumes
\       Type: Variable
\   Category: Sound
\    Summary: A table of offsets into the envelope data for bytes that control
\             the volume of each envelope, so we can change their volume levels
\
\ ******************************************************************************

.envelopeVolumes

 EQUB 5 * 14 + 9        \ Offset for parameter #9 of envelope 5
                        \
                        \ AD (change of amplitude per step during decay phase)

 EQUB 0 * 14 + 12       \ Offset for parameter #12 of envelope 0
                        \
                        \ ALA (target amplitude level at end of attack phase)

 EQUB 0 * 14 + 13       \ Offset for parameter #13 of envelope 0
                        \
                        \ ALD (target amplitude level at end of decay phase)

 EQUB 1 * 14 + 12       \ Offset for parameter #12 of envelope 1
                        \
                        \ ALA (target amplitude level at end of attack phase)

 EQUB 1 * 14 + 13       \ Offset for parameter #13 of envelope 1
                        \
                        \ ALD (target amplitude level at end of decay phase)

 EQUB 2 * 14 + 8        \ Offset for parameter #8 of envelope 2
                        \
                        \ AA (change of amplitude per step during attack phase)

 EQUB 2 * 14 + 12       \ Offset for parameter #12 of envelope 2
                        \
                        \ ALA (target amplitude level at end of attack phase)

 EQUB 3 * 14 + 12       \ Offset for parameter #12 of envelope 3
                        \
                        \ ALA (target amplitude level at end of attack phase)

 EQUB 4 * 14 + 8        \ Offset for parameter #8 of envelope 5
                        \
                        \ AA (change of amplitude per step during attack phase)

 EQUB 4 * 14 + 12       \ Offset for parameter #12 of envelope 4
                        \
                        \ ALA (target amplitude level at end of attack phase)

 EQUB 5 * 14 + 8        \ Offset for parameter #8 of envelope 5
                        \
                        \ AA (change of amplitude per step during attack phase)

 EQUB 5 * 14 + 12       \ Offset for parameter #12 of envelope 5
                        \
                        \ ALA (target amplitude level at end of attack phase)

\ ******************************************************************************
\
\       Name: ProcessPauseKeys
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Pause or unpause the game when COPY or DELETE are pressed
\
\ ******************************************************************************

.ProcessPauseKeys

 LDA keyLogger+3        \ Set A to the key logger entry for "7", "8", COPY and
                        \ DELETE (volume down, volume up, pause, unpause)

 BMI paws2              \ If there is no key press in the key logger entry, jump
                        \ to paws2 to return from the subroutine

 CMP #2                 \ If A <> 2 then COPY is not being pressed, so jump to
 BNE paws2              \ paws2 to check for DELETE

                        \ If we get here then COPY is being pressed, so we need
                        \ to pause the game

 ROR gamePaused         \ Set bit 7 of gamePaused to indicate that the game is
                        \ paused (this works because the CMP above returned an
                        \ equality, so the C flag is set and ready to be rotated
                        \ into bit 7 of gamePaused)

 LDA #8                 \ Update the scanner so it's filled with green, to show
 JSR UpdateScannerNow   \ that the game is paused (calling UpdateScannerNow
                        \ ensures the scanner is updated irrespective of whether
                        \ the scanner is currently enabled in-game)

 JSR FlushSoundBuffers  \ Flush all four sound channel buffers

.paws1

 LDA keyLogger+3        \ Set A to the key logger entry for "7", "8", COPY and
                        \ DELETE (volume down, volume up, pause, unpause)

 CMP #3                 \ If A <> 3 then DELETE is not being pressed, so jump
 BNE paws1              \ paws1 to check for key presses (or wait until no key
                        \ is being pressed)

 LDA #0                 \ Update the scanner so it's filled with black, so the
 JSR UpdateScannerNow   \ game can resume with a blank scanner (calling
                        \ UpdateScannerNow ensures the scanner is updated
                        \ irrespective of whether the scanner is currently
                        \ enabled in-game)

 LSR gamePaused         \ Clear bit 7 of gamePaused to indicate that the game is
                        \ unpaused

.paws2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ProcessMusic
\       Type: Subroutine
\   Category: Sound
\    Summary: ???
\
\ ******************************************************************************

.ProcessMusic

 LDX musicCounter       \ Set X to the music counter, which points to the
                        \ current place in the music data
       
 BMI musi4              \ If bit 7 of musicCounter is set then there is no music
                        \ playing, so jump to musi4 to return from the
                        \ subroutine

 INC musicCounter       \ Otherwise there is some music being played, so
                        \ increment the music counter to move through the music
                        \ data

 LDA musicData,X        \ Set A to the next byte of music data

 CMP #&FF               \ If A = &FF then we just reached the end of this piece
 BEQ musi3              \ of music, so jump to musi3 to stop playing music

                        \ If we get here then we need to process the byte of
                        \ music data in A

 CMP #200               \ If A < 200 then jump to musi1 to make the sound
 BCC musi1

                        \ If we get here then A contains the sound counter to
                        \ set for all following notes, with the form 200 + x
                        \ setting the counter to 4 * x

 SBC #200               \ Set noteCounter = (A - 200) * 4
 ASL A                  \
 ASL A                  \ This subtraction works because we just passed through
 STA noteCounter        \ a BCC, so we know the C flag is set

 JMP ProcessMusic       \ Loop back to the start of the routine to process the
                        \ next byte of music data

.musi1

 STA soundData+20       \ Set the third parameter of sound data block #2 to A,
                        \ to set the pitch

 LDA noteCounter        \ Set soundCounter to the note duration so the note
 STA soundCounter       \ plays for the correct amount of time
                        \
                        \ This means that the ProcessSound routine will do
                        \ nothing until this counter has run down, so we can
                        \ play three-note chords by setting the delay to zero
                        \ for the first two notes in the chord, so that there is
                        \ no delay between them, and then setting the delay for
                        \ the last note to the duration of the chord, so the
                        \ three chord notes play together for that period
                        \
                        \ All we need to do is ensure that the three notes can
                        \ play together, which is what we do next

 LDA soundData+16       \ Set A to the first parameter of sound data block #2,
                        \ which contains the channel
                        \
                        \ This is in the form &1x for sound channel x, and it
                        \ starts out at &12 for channel 2
                        \
                        \ Channels 1 to 3 are for tones, so we work our way
                        \ through channels &11 to &13, playing each note on the
                        \ next channel number
                        \
                        \ This plays the music with the last three notes being
                        \ sustained, which lets us play three-note chords as
                        \ described above, giving the game music its distinctive
                        \ chord style

 CLC                    \ Add 1 to move A onto the number of the next channel
 ADC #1

 CMP #&14               \ If A < &14 then we are still in the range &11 to &13,
 BCC musi2              \ so jump to musi2 to use this channel

 LDA #&11               \ Otherwise warp around to channel &11

.musi2

 STA soundData+16       \ Set the first parameter of sound data block #2 to A,
                        \ which sets the channel

 LDA #4                 \ Set the second parameter of sound data block #2 to 4,
 STA soundData+18       \ which sets the amplitude

 LDA #3                 \ Make sound #3 (music), which plays the next note of
 JMP MakeSound          \ music, returning from the subroutine using a tail call

.musi3

                        \ If we get here then we just reached the end of the
                        \ piece of music and A = &FF

 STA musicCounter       \ Set bit 7 of the music counter to flag that we are no
                        \ longer playing any music

.musi4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FlushSoundBuffers
\       Type: Subroutine
\   Category: Sound
\    Summary: Flush all four sound channel buffers
\
\ ******************************************************************************

.FlushSoundBuffers

 LDX #7                 \ To flush all four sound channel buffers we need to
                        \ pass the values 4, 5, 6 and 7 to the FlushBuffer
                        \ routine, so set X to loop through those values

.fbuf1

 JSR FlushBuffer        \ Call FlushBuffer to flush the buffer specified in X

 DEX                    \ Decrement the loop counter

 CPX #4                 \ Loop back until we have flushed the buffers for all
 BCS fbuf1              \ four sound channels

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: FlushSoundBuffer0
\       Type: Subroutine
\   Category: Sound
\    Summary: Flush the sound channel 0 buffer
\
\ ******************************************************************************

.FlushSoundBuffer0

 LDX #4                 \ Set X = 4 to denote the sound channel 0 buffer

                        \ Fall through into FlushBuffer to flush the sound
                        \ channel 0 buffer

\ ******************************************************************************
\
\       Name: FlushBuffer
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Flush the specified buffer
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of the buffer to flush:
\
\                         * 4 = sound channel 0 buffer
\
\                         * 5 = sound channel 1 buffer
\
\                         * 6 = sound channel 2 buffer
\
\                         * 7 = sound channel 3 buffer
\
\ ******************************************************************************

.FlushBuffer

 LDA #21                \ Call OSBYTE with A = 21 to flush buffer X, returning
 JMP OSBYTE             \ from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: ProcessSound
\       Type: Subroutine
\   Category: Sound
\    Summary: Process any sound effects that have been configured so they play
\             in the background (this is called regularly throughout gameplay)
\
\ ******************************************************************************

.ProcessSound

 LDA soundCounter       \ If soundCounter is non-zero then a sound is already
 BNE psou1              \ being made, so jump to psou1 to return from the
                        \ subroutine

 LDA soundEffect        \ Set A to the type of sound effect we need to apply,
                        \ which is specified in the soundEffect variable when
                        \ the sound is made

 CMP #4                 \ If A = 4 then this is the scanner sound, so jump to
 BEQ psou3              \ psou3 to process the scanner sound ???

 CMP #3                 \ If A = 3 then this is music, so jump to ProcessMusic
 BEQ psou2              \ via psou2 to process the music being played

 CMP #6                 \ If A <> 6 then there is no sound effect to apply, so
 BNE psou1              \ jump to psou1 to return from the subroutine

                        \ If we get here then soundEffect = 6, so this is the
                        \ game over sound

 LDX #7                 \ Set X = 7 to pass to MakeSound-6 as the pitch of the
                        \ first part of the game over sound

 LDY gameOverSoundPitch \ Set Y to the pitch for the second part of the game
                        \ over sound, which starts in the ShowGameOverScreen
                        \ routine at 250 and counts down towards 80

 CPY #80                \ If Y < 80 then the game over sound has finished, so
 BCC psou1              \ jump to psou1 to return from the subroutine without
                        \ making a sound

 LDA #6                 \ Make sound #6 (game over) with the pitches in X and Y
 JSR MakeSound-6

 JSR GetNextSeedNumber  \ Set A to the next number from the landscape's sequence
                        \ of seed numbers, which by this point in the game is
                        \ effectigvely a random number

 AND #3                 \ Convert the random number in A into a random number in
 CLC                    \ the range 1 to 4
 ADC #1

 STA soundCounter       \ Set soundCounter to a random number between 1 and 4 to
                        \ control the length of the noise we just made

 DEC gameOverSoundPitch \ Decrement the pitch of the game over sound so the
                        \ overall effect is of a slowly decaying sound effect

.psou1

 RTS                    \ Return from the subroutine

.psou2

                        \ If we get here then soundEffect = 3, so the sound
                        \ effect is music

 JMP ProcessMusic       \ Jump to ProcessMusic to play the music

.psou3

                        \ If we get here then soundEffect = 4, so this is some
                        \ kind of scanner sound ???

 LDA #50                \ Set soundCounter = 50 to count down while the next
 STA soundCounter       \ sound is made

 LDA #34                \ Set the third parameter of sound data block #2 to 34,
 STA soundData+20       \ to set the pitch

 LDA #3                 \ Set the second parameter of sound data block #2 to 3,
 STA soundData+18       \ to set the amplitude

 LDA #4                 \ Make sound #4 (???)
 JSR MakeSound

 RTS                    \ Return from the subroutine

 EQUB &B9               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: PlayGame
\       Type: Subroutine
\   Category: Main game loop
\    Summary: Start playing the generated landscape
\
\ ******************************************************************************

.PlayGame

 LDA #&83               \ Set the palette to the first set of colours from the
 JSR SetColourPalette   \ colourPalettes table, which the SpawnEnemies routine
                        \ set to the correct palette for playing the game (so
                        \ for landscape 0000 that would be blue, black, white
                        \ and green, for example)
                        \
                        \ So this displays the landscape preview screen that we
                        \ drew in PreviewLandscape with an all-blue palette
                        \ before jumping here

 JSR ReadKeyboard       \ Enable the keyboard, flush the keyboard buffer and
                        \ read a character from it (so this waits for a key
                        \ press before starting the game, following the "PRESS
                        \ ANY KEY" message on the landscape preview screen)

 LSR gameInProgress     \ Clear bit 7 of gameInProgress to indicate that a game
                        \ now in progress and we are no longer in the title and
                        \ preview screens (so the interrupt handler can now
                        \ update the game)

\ ******************************************************************************
\
\       Name: MainGameLoop
\       Type: Subroutine
\   Category: Main game loop
\    Summary: The main game loop for playing a landscape
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   game10              Jump to MainTitleLoop to restart the game
\
\ ******************************************************************************

.MainGameLoop

                        \ If we get here then we have either started a brand new
                        \ game or we jumped here from game11 below when one of
                        \ the following occured:
                        \
                        \   * The Sentinel has won
                        \
                        \   * The player has moved to a new tile
                        \
                        \   * The player has pressed the quit game key

 JSR FlushSoundBuffers  \ Flush all four sound channel buffers

 LDA quitGame           \ If bit 7 of quitGame is clear then the player has not
 BPL game1              \ pressed function key f1 to quit the game, so jump to
                        \ game 1 to keep playing the game

 JMP MainTitleLoop      \ The player has pressed function key f1 to quit the
                        \ game, so jump to MainTitleLoop to restart the game

.game1

                        \ If we get here then we have either started a brand new
                        \ landscape or we jumped to MainGameLoop from game11
                        \ below when one of the following occured:
                        \
                        \   * The Sentinel has won
                        \
                        \   * The player has moved to a new tile

 LDA sentinelHasWon     \ If bit 7 of sentinelHasWon is set then the player has
 BMI game6              \ run out of energy either by trying to hyperspace or by
                        \ being absorbed, so jump to game6 to restart the
                        \ landscape

                        \ If we get here then we have either started a brand new
                        \ landscape or we jumped to MainGameLoop from game11
                        \ below when the player moved to a new tile
                        \
                        \ In both cases we need to generate a brand new
                        \ landscape view

 LDA #4                 \ Set all four logical colours to physical colour 4
 JSR SetColourPalette   \ (blue), so this blanks the entire screen to blue

 LDA #0                 \ Set screenOrBuffer = 0 to configure the drawing
 STA screenOrBuffer     \ routines to draw directly onto the screen (as opposed
                        \ to drawing into the screen buffer)

 STA lastPanKeyPressed  \ Zero lastPanKeyPressed to indicate pan right ???

 STA sightsByteCount    \ Set sightsByteCount to zero to reset the sights pixel
                        \ byte stash

 STA sightsAreVisible   \ Clear bit 7 of sightsAreVisible to indicate that the
                        \ sights are not visible

 JSR SetScannerUpdate   \ Set scannerUpdate to zero to prevent scanner updates
                        \
                        \ This routine also performs a delay of 40 empty loops
                        \ of 256 iterations each (i.e. 10,240 loops)

 LDA playerObject       \ Set viewingObject to the object number of the player,
 STA viewingObject      \ so the landscape view gets drawn from the perspective
                        \ of the player

 BIT hyperspaceEndsGame \ If bit 7 of hyperspaceEndsGame is clear then the game
 BPL game2              \ has not ended because of a hyperspace, so jump to
                        \ game2 to draw the landscape

                        \ If we get here then the game has ended because the
                        \ player performed a hyperspace

 BVS game7              \ If bit 6 of hyperspaceEndsGame is set then the game
                        \ has ended because the player has hyperspaced from the
                        \ Sentinel's tower, thus winning the game, so jump to
                        \ game7 to process winning the landscape

                        \ If we get here then bit 6 of hyperspaceEndsGame is
                        \ clear and the player has run out of energy by trying
                        \ to hyperspace without being able to create a robot
                        \ into which they can hyperspace

 JSR ClearScreen        \ Clear the screen

 JMP game4              \ Jump to game4 to skip drawing the landscape view, as
                        \ the game has ended

.game2

 LDA uTurnStatus        \ If bit 7 of uTurnStatus is set then we just performed
 BMI game3              \ a U-turn in the ProcessActionKeys routine, so jump to
                        \ game3 to skip the following instruction, as we don't
                        \ need to recalculate tile visibility if we are turning
                        \ around (as the player hasn't moved)

 JSR GetTileVisibility  \ For each tile in the landscape, calculate whether the
                        \ player can see that tile, to speed up the process of
                        \ drawing the landscape

.game3

 JSR ClearScreen        \ Clear the screen

 JSR DrawLandscapeView  \ Draw the landscape view

 JSR UpdateIconsScanner \ Update the icons in the top-left corner of the screen
                        \ to show the player's current energy level and redraw
                        \ the scanner box

.game4

 LDA #25                \ Set screenOrBuffer = 25 to configure the drawing
 STA screenOrBuffer     \ routines to draw into the screen buffer (as opposed
                        \ to drawing directly onto the screen)

 LDA #2                 \ Call ConfigureBuffer with A = 2 to set up the screen
 JSR ConfigureBuffer    \ buffer for use as a column buffer

.game5

 JSR ProcessSound       \ Process any sounds or music that are being made in the
                        \ background

 LDA musicCounter       \ Loop back to keep calling ProcessSound until bit 7 of
 BPL game5              \ musicCounter is clear, so if any music is being
                        \ played, we wait until it has finished

 LDA #&83               \ Set the palette to the first set of colours from the
 JSR SetColourPalette   \ colourPalettes table, which the SpawnEnemies routine
                        \ set to the correct palette for playing the game (so
                        \ for landscape 0000 that would be blue, black, white
                        \ and green, for example)

 LDA hyperspaceEndsGame \ Set A to the hyperspace status flag

 BPL game11             \ If bit 7 of hyperspaceEndsGame is clear then the game
                        \ has not ended because of a hyperspace, so jump to
                        \ game11 to keep going

                        \ If we get here then the game has ended because of a
                        \ hyperspace, and it must be because the player ran out
                        \ of energy, as otherwise we would have taken the branch
                        \ to game7 above

 STA sentinelHasWon     \ Set bit 7 of sentinelHasWon to indicate that the
                        \ player has run out of energy and the Sentinel has won

 LDA #6                 \ Set soundEffect = 6 so the sound is processed as the
 STA soundEffect        \ game over sound

 LDA #5                 \ The Sentinel has won, so display the game over screen
 JSR ShowGameOverScreen \ with A = 5, so we decay the screen to black with a
                        \ mass of 5 * 2400 = 12,000 randomly placed black dots

.game6

                        \ If we get here then we restart the landscape by
                        \ resetting all the game variables, initialising the
                        \ the seed number generator and jumping into the main
                        \ title loop to preview the landscape and play the game

 JSR ResetVariables     \ Reset all the game's main variables

 LDY landscapeNumberHi  \ Set (Y X) = (landscapeNumberHi landscapeNumberLo)
 LDX landscapeNumberLo

 JSR InitialiseSeeds    \ Initialise the seed number generator to generate the
                        \ sequence of seed numbers for the landscape number in
                        \ (Y X) and set maxNumberOfEnemies and the landscapeZero
                        \ flag accordingly

 JMP main4              \ Jump to main4 in the main title loop to restart the
                        \ landscape without having to enter the landscape's
                        \ secret code again

.game7

                        \ If we get here then we have successfully completed
                        \ the landscape, so we display the secret code for the 
                        \ next landscape and go back to the title screen

 LDA #4                 \ Set all four logical colours to physical colour 4
 JSR SetColourPalette   \ (blue), so this blanks the entire screen to blue

                        \ In order to display the secret code for the next
                        \ landscape we need to generate it, so we now reset the
                        \ landscape seed generator, the tile visibility table
                        \ and the object flags, to get ready for the generation
                        \ process in the FinishLandscape routine

 LDX #3                 \ We now zero bits 8 to 40 of the five-byte linear
                        \ feedback shift landscape register, so set a byte
                        \ counter in X to count four bytes

 LDA #0                 \ Set A = 0 so we can zero the four bytes

 STA soundEffect        \ Set soundEffect = 0 to disable sound effect processing
                        \ in the ProcessSound routine

.game8

 STA seedNumberLFSR+1,X \ Zero byte X+1 of seedNumberLFSR(4 3 2 1 0)

 DEX                    \ Decrement the byte counter

 BPL game8              \ Loop back until we have reset all four bytes

 JSR ResetTilesObjects  \ Reset the tile visibility table and deallocate all
                        \ object numbers

 JSR FinishLandscape    \ Add the player's energy to the landscape number to get
                        \ the number of the next landscape and display that
                        \ landscape's secret code as a title screen

 LDA #&87               \ Set the palette to the second set of colours from the
 JSR SetColourPalette   \ colourPalettes table, which contains the fixed palette
                        \ for the title screens (blue, black, red, yellow)

 LDA #10                \ Set soundCounter = 10 to count down while the next
 STA soundCounter       \ sound is made

 LDA #66                \ Call the PlayMusic routine with A = 66 to play the
 JSR PlayMusic          \ music for when the player finishes a landscape

.game9

 JSR ProcessSound       \ Process any sounds or music that are being made in the
                        \ background

 LDA musicCounter       \ Loop back to keep calling ProcessSound until bit 7 of
 BPL game9              \ musicCounter is clear, so if any music is being
                        \ played, we wait until it has finished

 LDX #6                 \ Print text token 6: Print "PRESS ANY KEY" at (64, 100)
 JSR PrintTextToken

 JSR ReadKeyboard       \ Enable the keyboard, flush the keyboard buffer and
                        \ read a character from it (so this waits for a key
                        \ press)

.game10

 JMP MainTitleLoop      \ Jump to MainTitleLoop to restart the game from the
                        \ title screen

.game11

                        \ If we get here then the game is still in progress, so
                        \ we progress the gameplay

 JSR ProcessGameplay    \ Run the gameplay loop that processes all game key
                        \ presses, returning here when the player moves, quits,
                        \ loses or pans

 BCC game12             \ The ProcessGameplay routine will return with the C
                        \ flag clear if we just finished a landscape pan and the
                        \ player is still holding down a pan key, in which case
                        \ jump to game12 to process the pan

 JMP MainGameLoop       \ Otherwise the ProcessGameplay routine returned because
                        \ one of the following is true:
                        \
                        \   * The Sentinel has won
                        \
                        \   * The player has moved to a new tile
                        \
                        \   * The player has pressed the quit game key
                        \
                        \ so jump to MainGameLoop to process these actions

.game12

                        \ If we get here then the player is holding down a pan
                        \ key and wants to pan the screen, so we need to process
                        \ the pan

 LDA panKeyBeingPressed \ Update lastPanKeyPressed with the details of the pan
 STA lastPanKeyPressed  \ key being pressed, so we can check later on whether it
                        \ is still being held down

 LDA #0                 \ Set numberOfScrolls = 0 to reset the scroll counter
 STA numberOfScrolls    \ so the interrupt handler will not scroll the screen
                        \ while we set up the new pan

 STA L0C1E              \ Clear bit 7 of L0C1E ???

 BIT sightsAreVisible   \ If bit 7 of sightsAreVisible is set then the sights
 BMI game13             \ are being shown, so jump to game13 to skip the
                        \ following two instructions
                        \
                        \ This ensures that when we pan the screen as a result
                        \ of the sights moving off the edge of the screen, the
                        \ panning process completes and doesn't get aborted if
                        \ the player releases the pan key

 SEC                    \ The sights are not visible so we are panning the
 ROR keepCheckingPanKey \ screen because the player has pressed a pan key, so
                        \ set bit 7 of keepCheckingPanKey so DrawLandscapeView
                        \ will abort the drawing process if the player releases
                        \ the pan key before the drawing process has finished

.game13

 JSR PanLandscapeView   \ Pan the landscape and update the landscape view

 LSR keepCheckingPanKey \ Clear bit 7 of keepCheckingPanKey so DrawLandscapeView
                        \ will keep drawing the landscape irrespective of the
                        \ pan keys being held down (so this takes the routine
                        \ back to its default behaviour)

 JSR UpdateIconsScanner \ Update the icons in the top-left corner of the screen
                        \ to show the player's current energy level and redraw
                        \ the scanner box

 LDA numberOfScrolls    \ Set scrollCounter to the number of scrolls required,
 STA scrollCounter      \ so the interrupt routine will scroll the screen by
                        \ this many steps in the background

.game14

 LDA scrollCounter      \ Loop around until scrollCounter is zero, so this waits
 BNE game14             \ until the interrupt handler has finished scrolling the
                        \ landscape view, thus implementing the pan on-screen

 BEQ game11             \ Jump to game11 to continue progressing the gameplay
                        \ (this BEQ is effectively a JMP as we just passed
                        \ through a BNE)

\ ******************************************************************************
\
\       Name: ClearIconsScanner
\       Type: Subroutine
\   Category: Scanner and energy icons
\    Summary: Clear the energy icon and scanner row at the top of the screen
\
\ ******************************************************************************

.ClearIconsScanner

 LDA #0                 \ Set xIconCounter = 0 so we start drawing from the left
 STA xIconCounter       \ edge of the screen

.enec1

 LDA #0                 \ Draw a blank icon into the top part of the screen (via
 JSR DrawIcon           \ the icon screen buffer at iconBuffer) and move along
                        \ to the right, incrementing xIconCounter as we do

 LDA xIconCounter       \ Loop back to keep drawing blank icons until we have
 CMP #40                \ cleared column 39, at which point we have cleared the
 BCC enec1              \ entire row

 JMP ShowIconBuffer     \ Display the contents of the icon screen buffer by
                        \ copying it into screen memory, which will clear the
                        \ row on-screen, and return from the subroutine using a
                        \ tail call

\ ******************************************************************************
\
\       Name: PrintTextToken
\       Type: Subroutine
\   Category: Text
\    Summary: Print a recursive text token
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of the text token to print (0 to 17)
\
\ ******************************************************************************

.PrintTextToken

 LDY tokenOffset,X      \ Set Y to the offset for text token X, which we can use
                        \ as a character index to print each character in turn

.text1

 LDA tokenBase,Y        \ Set A to the Y-th character of the text token

 CMP #&FF               \ If A = &FF then we have reached the end of the token,
 BEQ text2              \ so jump to text2 to return from the subroutine

 JSR ProcessCharacter   \ Process the Y-th character of the text token in A, so
                        \ if A is a token number in the format 200 + token, we
                        \ print the text token, otherwise we print A as a simple
                        \ one-byte character

 INY                    \ Increment the character index in Y to point to the
                        \ next character of the text token

 JMP text1              \ Loop back to print the next character

.text2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: clearPixelMask
\       Type: Variable
\   Category: Graphics
\    Summary: A table for converting a pixel number in the range 0 to 3 into a
\             screen mode 5 bit mask with that pixel's bits clear and others set
\
\ ******************************************************************************

.clearPixelMask

 EQUB %01110111         \ Pixel bit mask with all pixels set except pixel 0

 EQUB %10111011         \ Pixel bit mask with all pixels set except pixel 1

 EQUB %11011101         \ Pixel bit mask with all pixels set except pixel 2

 EQUB %11101110         \ Pixel bit mask with all pixels set except pixel 3

 EQUB %10001000         \ These bytes appear to be unused
 EQUB %01000100
 EQUB %00100010
 EQUB %00010001

\ ******************************************************************************
\
\       Name: UpdateIconsScanner
\       Type: Subroutine
\   Category: Scanner and energy icons
\    Summary: Update the icons in the top-left corner of the screen to show the
\             player's current energy level and redraw the scanner box
\
\ ******************************************************************************

.UpdateIconsScanner

 LDA #0                 \ Set A = 0 to pass to DrawIcon

 STA xIconCounter       \ Set xIconCounter = 0 so we start drawing from the left
                        \ edge of the screen

 JSR DrawIcon           \ Draw a blank icon into the top part of the screen (via
                        \ the icon screen buffer at iconBuffer) and move along
                        \ to the right, incrementing xIconCounter as we do

 LDA playerEnergy       \ Set a loop counter to count down through the player's
 STA loopCounter        \ energy, so we can reduce it by the maximum possible
                        \ amount each time to work out the minimum number of
                        \ icons that represent that energy level
                        \
                        \ In other words, loopCounter contains the amount of
                        \ energy that we have yet to draw

.ener1

 LDA loopCounter        \ If loopCounter < 15 then we can't represent it with a
 CMP #15                \ high-energy robot (as that represents 15 energy
 BCC ener2              \ points), so jump to ener2 to skip to the next level
                        \ down

 SBC #15                \ Subtract 15 from the loop counter as we are about to
 STA loopCounter        \ draw a high-energy robot that represents 15 energy
                        \ points (this subtraction works because we just passed
                        \ through a BCC, so the C flag must be set)

 LDA #6                 \ Draw a high-energy robot into the top part of the
 JSR DrawIcon           \ screen (via the icon screen buffer at iconBuffer) and
                        \ move along to the right, incrementing xIconCounter as
                        \ we do

 LDA #0                 \ Draw a blank icon into the top part of the screen (via
 JSR DrawIcon           \ the icon screen buffer at iconBuffer) and move along
                        \ to the right, incrementing xIconCounter as we do

 JMP ener1              \ Loop back to ener1 to draw another high-energy robot,
                        \ if required

.ener2

 LDA loopCounter        \ If loopCounter < 3 then we can't represent it with a
 CMP #3                 \ blue robot (as that represents three energy points),
 BCC ener3              \ so jump to ener3 to skip to the next level down

 SBC #3                 \ Subtract 3 from the loop counter as we are about to
 STA loopCounter        \ draw a high-energy robot that represents three energy
                        \ points (this subtraction works because we just passed
                        \ through a BCC, so the C flag must be set)

 LDA #1                 \ Draw a blue robot into the top part of the screen (via
 JSR DrawIcon           \ the icon screen buffer at iconBuffer) and move along
                        \ to the right, incrementing xIconCounter as we do

 LDA #0                 \ Draw a blank icon into the top part of the screen (via
 JSR DrawIcon           \ the icon screen buffer at iconBuffer) and move along
                        \ to the right, incrementing xIconCounter as we do

 JMP ener2              \ Loop back to ener2 to draw another blue robot, if
                        \ required

.ener3

                        \ If we get here then the value of loopCounter in A must
                        \ be 0, 1 or 2, as otherwise we would still be drawing
                        \ robots

 CMP #1                 \ If A < 1 then A must be zero, so jump to ener4 to move
 BCC ener4              \ on to the scanner as we have no more energy points to
                        \ draw

 ASL A                  \ If we get here then A is 1 or 2, so double it to get
                        \ the correct icon numbers for the left part of the
                        \ two-part tree or boulder icons:
                        \
                        \   * When A = 1, double it to 2 for the left tree icon
                        \
                        \   * When A = 2, double it to 4 for the left boulder
                        \     icon

 JSR DrawIcon           \ Draw the correct left icon into the top part of the
                        \ screen (via the icon screen buffer at iconBuffer) and
                        \ move along to the right, incrementing xIconCounter as
                        \ we do

 CLC                    \ Increment A to get the correct icon number for the
 ADC #1                 \ right part of the tree or boulder

 JSR DrawIcon           \ Draw the correct right icon into the top part of the
                        \ screen (via the icon screen buffer at iconBuffer) and
                        \ move along to the right, incrementing xIconCounter as
                        \ we do

                        \ We have updated the energy icons, so now we blank the
                        \ rest of the top line of the screen before drawing the
                        \ outline of the scanner

.ener4

 LDA #0                 \ Draw a blank icon into the top part of the screen (via
 JSR DrawIcon           \ the icon screen buffer at iconBuffer) and move along
                        \ to the right, incrementing xIconCounter as we do

 LDA xIconCounter       \ Loop back to keep drawing blank icons until we reach
 CMP #29                \ column 29, which is where we want to draw the scanner
 BCC ener4

 LDA #7                 \ Draw the left edge of the scanner box into the top
 JSR DrawIcon           \ part of the screen (via the icon screen buffer at
                        \ iconBuffer) and move along to the right, incrementing
                        \ xIconCounter as we do

.ener5

 LDA #8                 \ Draw the middle part of the scanner box into the top
 JSR DrawIcon           \ part of the screen (via the icon screen buffer at
                        \ iconBuffer) and move along to the right, incrementing
                        \ xIconCounter as we do

 LDA xIconCounter       \ Loop back to keep drawing the middle part of the
 CMP #38                \ scanner box until we reach column 38
 BCC ener5

 LDA #9                 \ Draw the right edge of the scanner box into the top
 JSR DrawIcon           \ part of the screen (via the icon screen buffer at
                        \ iconBuffer) and move along to the right, incrementing
                        \ xIconCounter as we do

 LDA #0                 \ Draw a blank icon into the top part of the screen (via
 JSR DrawIcon           \ the icon screen buffer at iconBuffer) and move along
                        \ to the right

 JMP ShowIconBuffer     \ Display the contents of the icon screen buffer by
                        \ copying it into screen memory, returning from the
                        \ subroutine using a tail call

\ ******************************************************************************
\
\       Name: DrawIcon
\       Type: Subroutine
\   Category: Scanner and energy icons
\    Summary: Draw a single icon in the top-left corner of the screen (via the
\             icon screen buffer at iconBuffer) and move along to the right
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The type of icon to draw:
\
\                         * 0 = Blank
\
\                         * 1 = Robot
\
\                         * 2 = Tree (left)
\
\                         * 3 = Tree (right)
\
\                         * 4 = Boulder (left)
\
\                         * 5 = Boulder (right)
\
\                         * 6 = High-energy robot
\
\                         * 7 = Scanner box (left)
\
\                         * 8 = Scanner box (middle)
\
\                         * 9 = Scanner box (right)
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   A is preserved
\
\ ******************************************************************************

.DrawIcon

 PHA                    \ Store the icon type on the stack so we can preserve it

 ASL A                  \ Set X = (A * 8) + 7
 ASL A                  \
 ASL A                  \ Each icon definition in iconData contains eight bytes,
 ORA #7                 \ so we can use this as an index into iconData, where it
 TAX                    \ points to the last of the eight bytes for icon A (as
                        \ we added 7 to A * 8 with the ORA instruction)

                        \ We now calculate the address of the icon in the screen
                        \ buffer at iconBuffer
                        \
                        \ The icon needs to be drawn in column xIconCounter,
                        \ where each column is eight pixels wide, and because
                        \ the screen is split into 8x8-pixel character blocks of
                        \ eight bytes in each, the icon is in screen memory at
                        \ this address, which we store in (Q P): 
                        \
                        \   (Q P) = iconBuffer + xIconCounter * 8
                        \
                        \ This is calculated by doing half the sum first, and
                        \ then doubling the result, like this:
                        \
                        \   (iconBuffer / 2) + (xIconCounter * 4)
                        \
                        \ The calculation is done this way to cater for values
                        \ of xIconCounter between 32 and 39, as multiplying 32
                        \ by 8 won't fit into one byte, but multiplying by 4
                        \ will fit (and doubling just requires a simple shift)

 LDA xIconCounter       \ Set P = xIconCounter * 4 + LO(iconBuffer / 2)
 ASL A                  \      
 ASL A                  \ so those are the low bytes
 ADC #LO(iconBuffer)/2
 STA P

 LDA #HI(iconBuffer)/2  \ Set A = 0 + HI(iconBuffer / 2)
 ADC #0                 \
                        \ and those are the high bytes, with the result of the
                        \ half sum in (A P)

 ASL P                  \ Set (Q P) = (A P) * 2
 ROL A                  \           = iconBuffer + xIconCounter * 8
 STA Q                  \
                        \ So we now have the address within the icon screen
                        \ buffer for the icon we want to draw

 LDY #7                 \ We now copy eight bytes of icon data into the icon
                        \ screen buffer at iconBuffer

.deni1

 LDA iconData,X         \ Copy the X-th byte of icon data to the Y-th byte of
 STA (P),Y              \ (Q P)

 DEX                    \ Decrement the source byte counter

 DEY                    \ Decrement the destination byte counter

 BPL deni1              \ Loop back until we have copied all eight bytes

 INC xIconCounter       \ Increment the icon counter to move along to the right
                        \ by one column, as we just drew an icon

 PLA                    \ Restore the icon type into A that we stored on the
                        \ stack above

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: IRQHandler
\       Type: Subroutine
\   Category: Main game loop
\    Summary: The main interrupt handler, which gets run 50 times a second to
\             update the game state and check for game key presses
\
\ ------------------------------------------------------------------------------
\
\ This routine is called exactly 50 times a second, and it does the following:
\
\   * Count down the sound timer
\
\   * If a game is not in progress (i.e. we are in the title screen rather than
\     playing a landscape), return from the handler
\
\   * If the Sentinel has won, then call DrawBlackDots (while bit 7 of L0C4D is
\     set), and return from the handler
\
\   * If the game is paused, scan for the pause and volume keys and return from
\     the handler
\
\   * If a game is in progress and the Sentinel has not won and the game is not
\     paused, then:
\
\     * If scrollCounter is non-zero then call ScrollPlayerView (which
\       decrements scrollCounter) and ShowIconBuffer
\
\     * If the Sentinel has been activated, call sub_C12EE and UpdateScanner
\
\     * If bit 7 of focusOnKeyAction is clear then the game is not currently
\       focusing effort on implementing a key action such as a landscape pan, so
\       scan for and process all the game keys
\
\ ******************************************************************************

.irqh1

 JMP (irq1Address)      \ Jump to the original address from IRQ1V to pass
                        \ control to the next interrupt handler

.IRQHandler

 SEI                    \ Disable interrupts so the following process isn't
                        \ interrupted by another interrupt

 LDA SHEILA+&6D         \ Set A to the 6522 User VIA interrupt flag register IFR
                        \ (SHEILA &6D)

 AND #%01000000         \ If bit 6 of the IFR is clear then this interrupt has
 BEQ irqh1              \ not been triggered by the 6522 User VIA timer 1
                        \ reaching zero, so jump to irqh1 to pass the interrupt
                        \ on to the next interrupt handler

                        \ If we get here then bit 6 of the IFR is set, so this
                        \ interrupt has been triggered by the 6522 User VIA
                        \ timer 1 reaching zero

 STA SHEILA+&6D         \ The AND instruction above leaves A containing bit 6
                        \ set and all other bits clear, so we can write this to
                        \ the IFR at SHEILA &6D to clear the timer 1 interrupt

 LDA &FC                \ Set A to the interrupt accumulator save register,
                        \ which restores A to the value it had on entering the
                        \ interrupt

 PHA                    \ Store A, X and Y on the stack so we can preserve them
 TXA                    \ across calls to the interrupt handler
 PHA
 TYA
 PHA

 CLD                    \ Clear the D flag to switch arithmetic to normal, in
                        \ case the interrupt was triggered during any BCD
                        \ calculations

 DEC soundCounter       \ Decrement the sound counter so we can detect when the
 BPL irqh2              \ current sound effect has finished, making sure it
 INC soundCounter       \ doesn't go below zero

.irqh2

 LDA gameInProgress     \ If bit 7 of gameInProgress is set then a game is not
 BMI irqh8              \ currently in progress and we are in the title and
                        \ preview screens, so jump to irqh8 to skip the
                        \ following and return from the interrupt handler
                        \ without updating the game state

 LDA sentinelHasWon     \ If bit 7 of sentinelHasWon is set then the Sentinel
 BMI irqh7              \ has won the game, so jump to irqh7 to ??? and return
                        \ from the interrupt handler

 LDA gamePaused         \ If bit 7 of gamePaused is set then the game is paused,
 BMI irqh5              \ so jump to irqh5 to scan for the unpause and volume
                        \ keys and return from the interrupt handler

 LDA scrollCounter      \ If scrollCounter = 0 then we do not need to scroll the
 BEQ irqh3              \ player's landscape view, so jump to irqh3 to skip the
                        \ scrolling process

                        \ If we get here then we still have scrollCounter steps
                        \ to complete in the current scrolling process, so we
                        \ now do one scrolling step (ScrollPlayerView decrements
                        \ the counter in scrollCounter)

 JSR ScrollPlayerView   \ Scroll the screen and copy data from the view screen
                        \ buffer into screen memory to implement the player's
                        \ scrolling landscape view

 JSR ShowIconBuffer     \ Display the contents of the icon screen buffer by
                        \ copying it into screen memory, as the scrolling
                        \ process will have scrolled this part of the screen, so
                        \ we need to redraw it to prevent the energy icons and
                        \ scanner from moving

.irqh3

 LDA activateSentinel   \ If bit 7 of activateSentinel is set then the Sentinel
 BMI irqh4              \ has not yet been activated at the start of the game,
                        \ so jump to irqh4 to skip the following

 JSR sub_C12EE          \ ???

 JSR UpdateScanner      \ Update the scanner, if required

.irqh4

 LDA focusOnKeyAction   \ If bit 7 of focusOnKeyAction is set then the game is
 BMI irqh8              \ currently focusing effort on implementing a key action
                        \ such as a landscape pan, so jump to irqh8 to skip the
                        \ following keyboard scan

 JSR CheckForKeyPresses \ Check for various game key presses and update the key
                        \ logger and relevant variables

 JMP irqh8              \ Jump to irqh8 to return from the interrupt handler

.irqh5

                        \ If we get here then the game is paused, so we scan for
                        \ key presses and discard them all except for the
                        \ unpause and volume keys

 LDY #13                \ Scan the keyboard for all game keys in the gameKeys
 JSR ScanForGameKeys    \ table except for the last one ("U" for U-turn)

                        \ We now reset the first three entries in the key
                        \ logger (i.e. entries 0 to 2), leaving the last entry
                        \ populated (i.e. entry 3, which records the volume,
                        \ paue and unpause key presses)

 LDX #2                 \ Set a loop counter in X for resetting three entries

 LDA #%10000000         \ Set A = %10000000 to reset the three entries, as the
                        \ set bit 7 indicates an empty entry in the logger

.irqh6

 STA keyLogger,X        \ Reset the X-th entry in the key logger

 DEX                    \ Decrement the loop counter

 BPL irqh6              \ Loop back until we have reset all four entries

 JMP irqh8              \ Jump to irqh8 to return from the interrupt handler

.irqh7

                        \ If we get here then the Sentinel has won the game

 LDA L0C4D              \ If bit 7 of L0C4D is clear, skip the following to
 BPL irqh8              \ return from the interrupt handler ???

 JSR DrawBlackDots      \ Draw 80 randomly positioned dots on the screen in
                        \ colour 1 (black) to fade the screen to black in a
                        \ slowly decaying manner

.irqh8

 PLA                    \ Restore A, X and Y from the stack
 TAY
 PLA
 TAX
 PLA

 RTI                    \ Return from the interrupt handler

\ ******************************************************************************
\
\       Name: ScrollPlayerView
\       Type: Subroutine
\   Category: Graphics
\    Summary: Scroll the screen and copy data from the screen buffer into screen
\             memory to implement the player's scrolling landscape view
\
\ ******************************************************************************

.ScrollPlayerView

 LDY lastPanKeyPressed  \ Set Y to the direction of the last pan key that was
                        \ pressed (which may not still be held down)
                        \
                        \ So this contains the direction of any scrolling that
                        \ we still need to apply, as follows:
                        \
                        \   * 0 = pan right
                        \
                        \   * 1 = pan left
                        \
                        \   * 2 = pan up
                        \
                        \   * 3 = pan down
                        \
                        \ We use this as an index into various tables, to look
                        \ up the correct values for the direction in which we
                        \ want to scroll

                        \ We now scroll the screen in the correct direction to
                        \ pan the player's scrolling landscape view
                        \
                        \ Note that we scroll the screen in the opposite
                        \ direction to the pan direction, so if we are panning
                        \ right we move the screen to the left, for example
                        \
                        \ The screen address of the player's scrolling landscape
                        \ view is stored in viewScreenAddr(1 0), so this is the
                        \ address of the screen just below the energy icon and
                        \ scanner row
                        \
                        \ We therefore start the scrolling process by updating
                        \ the screen address in viewScreenAddr(1 0) to point to
                        \ the new address after scrolling
                        \
                        \ Scrolling is done in individual steps, as follows:
                        \
                        \   * When scrolling horizontally, we scroll by one
                        \     column that's one character block wide (i.e. one
                        \     byte, two pixels wide)
                        \
                        \   * When scrolling vertically, we scroll by one row
                        \     that's one character block tall (i.e. eight bytes,
                        \     eight pixels tall)
                        \
                        \ The amount of change that we need to apply to
                        \ viewScreenAddr(1 0) for each of the four directions is
                        \ given in the tables scrollScreenHi and scrollScreenLo,
                        \ as 16-bit signed values, so we just need to look up
                        \ the correct value and apply it to viewScreenAddr(1 0)
                        \
                        \ For example, we advance viewScreenAddr(1 0) by eight
                        \ bytes when panning right, as we need to scroll the
                        \ screen to the left, so the start of the screen in
                        \ memory moves on by eight bytes (one character block)
                        \
                        \ This would scroll the screen to the left by two pixels
                        \ as each character block is two pixels wide
                        \
                        \ Similarly, we reduce viewScreenAddr(1 0) by 320 bytes
                        \ when panning up, as we need to scroll the screen down,
                        \ so the start of the screen in memory moves on by eight
                        \ bytes (one character row of 40 character blocks with
                        \ eight bytes per character block)
                        \
                        \ This would scroll the screen to down by eight pixels
                        \ as each character row is eight pixels wide

 LDA viewScreenAddr     \ Apply the change in (scrollScreenHi scrollScreenLo)
 CLC                    \ for the current pan direction in Y to the screen
 ADC scrollScreenLo,Y   \ address of the player's scrolling landscape, which is
 STA viewScreenAddr     \ stored in viewScreenAddr(1 0)
 LDA viewScreenAddr+1   \
 ADC scrollScreenHi,Y   \ We start by calculating this:
                        \
                        \   (A viewScreenAddr) = viewScreenAddr(1 0)
                        \                  + (scrollScreenHi+Y scrollScreenLo+Y)

 CMP #&80               \ If the high byte in A >= &80 then the new address is
 BCC scro1              \ past the end of screen memory, so subtract &20 from
 SBC #&20               \ the high byte so the address wraps around within the
                        \ range of screen memory between &6000 and &8000
                        \
                        \ If the high byte is in range, jump to scro1 to check
                        \ the high byte against the start of screen memory

 JMP scro2              \ Jump to scro2 to skip the next check, as we know it
                        \ doesn't apply

.scro1

 CMP #&60               \ If the high byte in A < &60 then the new address is
 BCS scro2              \ before the start of screen memory, so add &20 to the
 ADC #&20               \ high byte so the address wraps around within the range
                        \ of screen memory between &6000 and &8000

.scro2

 STA viewScreenAddr+1   \ Store the high byte of the result, so we now have:
                        \
                        \   viewScreenAddr(1 0) = viewScreenAddr(1 0)
                        \                  + (scrollScreenHi+Y scrollScreenLo+Y)
                        \
                        \ with the address wrapped around as required

                        \ We now reprogram the 6845 CRTC chip to scroll the
                        \ screen in hardware (so-called "hardware scrolling")
                        \ by setting 6845 registers R12 and R13 to the new
                        \ address for the start of screen memory
                        \
                        \ The registers actually require the address to be set
                        \ in terms of character rows, so we need to set R12 and
                        \ R12 to the address divided by 8 (see below)

 JSR GetIconRowAddress  \ Set iconRowAddr(1 0) to the address in screen memory
                        \ of the icon and scanner row at the top of the screen
                        \
                        \ This calculates the address from viewScreenAddr(1 0),
                        \ so the value returned will be the new start of screen
                        \ memory, after the scroll is completed
                        \
                        \ It also sets A to the high byte of the address of
                        \ screen memory in iconRowAddr(1 0)

 STA screenAddrHi       \ Set (screenAddrHi A) = iconRowAddr(1 0) / 8
 LDA iconRowAddr        \
 LSR screenAddrHi       \ So (screenAddrHi A) contains the new address of screen
 ROR A                  \ memory, divided by 8, which is suitable for passing to
 LSR screenAddrHi       \ the 6845 CRTC to change the address of screen memory
 ROR A
 LSR screenAddrHi
 ROR A

 LDX #13                \ Set 6845 register R13 = A, for the low byte
 STX SHEILA+&00         \
 STA SHEILA+&01         \ We do this by writing the register number (13) to
                        \ SHEILA &00, and then the value (A) to SHEILA &01

 LDX #12                \ Set 6845 register R12 = &0F, for the high byte
 STX SHEILA+&00         \
 LDA screenAddrHi       \ We do this by writing the register number (12) to
 STA SHEILA+&01         \ SHEILA &00, and then the value (screenAddrHi) to
                        \ SHEILA &01

                        \ This sets 6845 registers (R12 R13) = (screenAddrHi A)
                        \ to point to the start of screen memory in terms of
                        \ character rows. There are 8 pixel lines in each
                        \ character row, so to get the actual address of the
                        \ start of screen memory, we multiply by 8:
                        \
                        \   (screenAddrHi A) * 8
                        \
                        \ which is iconRowAddr(1 0), as set above
                        \
                        \ So this whole thing sets the start of screen memory to
                        \ the address of iconRowAddr(1 0), which scrolls the
                        \ screen by the required amount

 DEC scrollCounter      \ Decrement the scroll counter, as we have just scrolled
                        \ the screen by one more step

                        \ We now set viewScreenAddr(1 0) to the new address of
                        \ the start of the player's landscape view, so that's
                        \ the address of the top-left corner of the view, just
                        \ below the energy icon and scanner bar at the top of
                        \ the screen
                        \
                        \ We now need to set toAddr(1 0) to the address in
                        \ screen memory that we need to update now that the
                        \ screen has been scrolled
                        \
                        \ Scrolling the screen leads to the following update
                        \ requirements:
                        \
                        \   * When scrolling the screen to the left, we need to
                        \     update the column on the right
                        \
                        \   * When scrolling the screen to the right, we need to
                        \     update the column on the left
                        \
                        \   * When scrolling the screen down, we need to update
                        \     the row along the top
                        \
                        \   * When scrolling the screen up, we need to update
                        \     the row along the bottom
                        \
                        \ We want to set toAddr(1 0) to the address of the area
                        \ in screen memory that we need to update, and the
                        \ offset within screen memory of this area for each of
                        \ the four directions is given in the tables at
                        \ updateOffsetHi and updateOffsetLo, as 16-bit signed
                        \ values, so we just need to look up the correct offset
                        \ and apply it to viewScreenAddr(1 0) to get the address
                        \ of the area of screen memory we need to update

 LDA viewScreenAddr     \ Set toAddr(1 0) to the screen address of the player's
 CLC                    \ scrolling landscape, plus the offset for the current
 ADC updateOffsetLo,Y   \ pan direction from (updateOffsetHi updateOffsetLo)
 STA toAddr             \
 LDA viewScreenAddr+1   \ We start by calculating this:
 ADC updateOffsetHi,Y   \
                        \   (A toAddr) = viewScreenAddr(1 0)
                        \                  + (updateOffsetHi+Y updateOffsetLo+Y)

 CMP #&80               \ If the high byte in A >= &80 then the new address is
 BCC scro3              \ past the end of screen memory, so subtract &20 from
 SBC #&20               \ the high byte so the address wraps around within the
                        \ range of screen memory between &6000 and &8000

.scro3

 STA toAddr+1           \ Store the high byte of the result, so we now have:
                        \
                        \   toAddr(1 0) = viewScreenAddr(1 0)
                        \                  + (updateOffsetHi+Y updateOffsetLo+Y)
                        \
                        \ with the address wrapped around as required

                        \ By this point we have done the following to implement
                        \ the required screen scrolling:
                        \
                        \  * Updated viewScreenAddr(1 0) to the new address of
                        \    the player's scrolling landscape
                        \
                        \  * Updated the 6845 to scroll the screen by changing
                        \    the address of screen memory
                        \
                        \  * Decremented the counter in scrollCounter
                        \
                        \  * Set toAddr(1 0) to the address of the area in
                        \    screen memory that we now need to update
                        \
                        \ We can now fall through into ShowScreenBuffer to copy
                        \ the contents of the screen buffer into the area we
                        \ need to update, so that the scroll reveals the correct
                        \ part of the view

\ ******************************************************************************
\
\       Name: ShowScreenBuffer
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Update the player's scrolling landscape view by copying the
\             relevant parts of the screen buffer into screen memory
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The direction of scrolling that we just applied:
\
\                         * 0 = pan right
\                        
\                         * 1 = pan left
\                        
\                         * 2 = pan up
\                        
\                         * 3 = pan down
\
\   toAddr(1 0)         The address of the area in screen memory that we need to
\                       update with the contents of the screen buffer
\
\ ******************************************************************************

.ShowScreenBuffer

                        \ We start by setting both screenBufferAddr(1 0) and
                        \ fromAddr(1 0) to the address in the screen buffer of
                        \ the content that we need to copy into the screen area
                        \ following the hardware scroll
                        \
                        \ We do this by taking the current value of the address
                        \ in screenBufferAddr(1 0) and applying the change in
                        \ (scrollScreenHi scrollScreenLo) for the current pan
                        \ direction in Y, just as we did when we updated the
                        \ screen address in viewScreenAddr(1 0) in the
                        \ ScrollPlayerView routine

 LDA screenBufferAddr   \ Add (scrollScreenHi scrollScreenLo) for this pan
 CLC                    \ direction to the address in screenBufferAddr(1 0),
 ADC scrollScreenLo,Y   \ starting with the low bytes
 STA screenBufferAddr

 STA fromAddr           \ Store the low byte of the result in fromAddr(1 0)

 LDA screenBufferAddr+1 \ And then add the high bytes
 ADC scrollScreenHi,Y
 STA screenBufferAddr+1

 STA fromAddr+1         \ Store the high byte of the result in fromAddr(1 0), so
                        \ fromAddr(1 0) = screenBufferAddr(1 0) and we copy the
                        \ new screen content from the correct address in the
                        \ screen buffer

 CPY #2                 \ If Y >= 2 then we are panning up or down, and we are
 BCS ShowBufferRow      \ scrolling down or up, so jump to ShowBufferRow to
                        \ update the player's scrolling landscape view by
                        \ copying an eight-pixel high character row from the
                        \ screen buffer into screen memory

                        \ Otherwise we are panning left or right, and we are
                        \ scrolling right or left or up, so fall througn into
                        \ ShowBufferColumn to update the player's scrolling
                        \ landscape view by copying a two-pixel wide column from
                        \ the screen buffer into screen memory

\ ******************************************************************************
\
\       Name: ShowBufferColumn
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Update the player's scrolling landscape view by copying a 2-pixel
\             wide column from the screen buffer into screen memory
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   fromAddr(1 0)       The source address from which we copy the character
\                       column
\
\   toAddr(1 0)         The destination address to which we copy the character
\                       column
\
\ ******************************************************************************

.ShowBufferColumn

 LDX #24                \ The custom screen mode 5 used by the game contains 25
                        \ character rows, each of which is eight pixels high, so
                        \ set a row counter in X to count the character rows in
                        \ the screen buffer, which is one row less than the
                        \ screen height, as the top row is the energy icon and
                        \ scanner row 

.dcol1

 JSR ShowBufferBlock    \ Copy an eight-byte 8x2-pixel character block from the
                        \ screen buffer at fromAddr(1 0) into screen memory at
                        \ toAddr(1 0)

 LDA fromAddr           \ Set (A fromAddr) = fromAddr(1 0) + &140
 CLC                    \                  = fromAddr(1 0) + 320
 ADC #&40               \
 STA fromAddr           \ Each character row in screen mode 5 takes up 320 bytes
 LDA fromAddr+1         \ (40 character blocks of eight bytes each), so this
 ADC #&01               \ sets fromAddr(1 0) to the address of the next row down
                        \ in the screen buffer

 CMP #&53               \ If the result of the addition is less than &5300, then
 BNE dcol2              \ we have not reached the end of the screen buffer, so
                        \ jump to dcol2 to skip the following

                        \ At this point the screen buffer wraps around so the
                        \ buffer entries restart at a lower address
                        \
                        \ Specifically the last buffer address before &5300 is:
                        \
                        \   &51C0 to &51FF for character row 15
                        \
                        \ and we now wrap around as follows:
                        \
                        \   &3FA0 to &3FDF for character row 16
                        \
                        \ The address of the new row is &A0 more than the
                        \ address of the screen buffer, which is &3F00, so we
                        \ can calculate the new address like this:
                        \
                        \   (A fromAddr) = screenBufferAddr(1 0) + &A0
                        \
                        \ So this wraps the address around so we can keep
                        \ drawing content into the screen buffer
                        \
                        \ See bufferRowAddrLo for more information on the
                        \ structure of the screen buffer

 LDA screenBufferAddr   \ Calculate the following:
 CLC                    \
 ADC #&A0               \   (A fromAddr) = screenBufferAddr(1 0) + &A0
 STA fromAddr
 LDA screenBufferAddr+1    
 ADC #&00

.dcol2

 STA fromAddr+1         \ Store the high byte of the result, so we now have:
                        \
                        \   fromAddr(1 0) = fromAddr(1 0) + 320
                        \
                        \ with the address wrapped around as required

 LDA toAddr             \ Set (A toAddr) = toAddr(1 0) + &140
 CLC                    \                = toAddr(1 0) + 320
 ADC #&40
 STA toAddr             
 LDA toAddr+1
 ADC #&01

 CMP #&80               \ If the high byte in A >= &80 then the new address is
 BCC dcol3              \ past the end of screen memory, so subtract &20 from
 SBC #&20               \ the high byte so the address wraps around within the
                        \ range of screen memory between &6000 and &8000

.dcol3

 STA toAddr+1           \ Store the high byte of the result, so we now have:
                        \
                        \   toAddr(1 0) = toAddr(1 0) + 320
                        \
                        \ with the address wrapped around as required

 DEX                    \ Decrement the counter in X to move on to the next
                        \ character row down

 BNE dcol1              \ Loop back until we have copied all 24 character blocks
                        \ in the column from fromAddr(1 0) to toAddr(1 0)

 JMP drow3              \ Jump to drow3 to return from the subroutine, as drow3
                        \ contains an RTS

\ ******************************************************************************
\
\       Name: ShowBufferRow
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Update the player's scrolling landscape view by copying an 8-pixel
\             high character row from the screen buffer into screen memory
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   fromAddr(1 0)       The source address from which we copy the character row
\
\   toAddr(1 0)         The destination address to which we copy the character
\                       row
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   drow3               Contains an RTS
\
\ ******************************************************************************

.ShowBufferRow

 LDX #40                \ Each character row in screen mode 5 contains 40
                        \ character blocks of eight bytes, so set a block
                        \ counter in X to count the character blocks

.drow1

 JSR ShowBufferBlock    \ Copy an eight-byte 8x2-pixel character block from the
                        \ screen buffer at fromAddr(1 0) into screen memory at
                        \ toAddr(1 0)

 LDA fromAddr           \ Set fromAddr(1 0) = fromAddr(1 0) + 8
 CLC                    \
 ADC #8                 \ So this moves the from address to the next character
 STA fromAddr           \ block in the character row
 LDA fromAddr+1
 ADC #0
 STA fromAddr+1

 LDA toAddr             \ Set (A toAddr) = toAddr(1 0) + 8
 CLC
 ADC #8
 STA toAddr
 LDA toAddr+1
 ADC #0

 CMP #&80               \ If the high byte in A >= &80 then the new address is
 BCC drow2              \ past the end of screen memory, so subtract &20 from
 SBC #&20               \ the high byte so the address wraps around within the
                        \ range of screen memory between &6000 and &8000

.drow2

 STA toAddr+1           \ Store the high byte of the result, so we now have:
                        \
                        \   toAddr(1 0) = toAddr(1 0) + 8
                        \
                        \ with the address wrapped around as required

 DEX                    \ Decrement the counter in X to move on to the next
                        \ character block in the row

 BNE drow1              \ Loop back until we have copied all 40 character blocks
                        \ in the character row from fromAddr(1 0) to toAddr(1 0)

.drow3

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ShowBufferBlock
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Update the player's scrolling landscape view by copying an 8-byte
\             character block from the screen buffer into screen memory
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   fromAddr(1 0)       The source address from which we copy the eight-byte
\                       character block
\
\   toAddr(1 0)         The destination address to which we copy the eight-byte
\                       character block
\
\ ******************************************************************************

.ShowBufferBlock

 LDY #0                 \ Copy byte #0 of fromAddr(1 0) to toAddr(1 0)
 LDA (fromAddr),Y
 STA (toAddr),Y

 INY                    \ Copy byte #1 of fromAddr(1 0) to toAddr(1 0)
 LDA (fromAddr),Y
 STA (toAddr),Y

 INY                    \ Copy byte #2 of fromAddr(1 0) to toAddr(1 0)
 LDA (fromAddr),Y
 STA (toAddr),Y

 INY                    \ Copy byte #3 of fromAddr(1 0) to toAddr(1 0)
 LDA (fromAddr),Y
 STA (toAddr),Y

 INY                    \ Copy byte #4 of fromAddr(1 0) to toAddr(1 0)
 LDA (fromAddr),Y
 STA (toAddr),Y

 INY                    \ Copy byte #5 of fromAddr(1 0) to toAddr(1 0)
 LDA (fromAddr),Y
 STA (toAddr),Y

 INY                    \ Copy byte #6 of fromAddr(1 0) to toAddr(1 0)
 LDA (fromAddr),Y
 STA (toAddr),Y

 INY                    \ Copy byte #7 of fromAddr(1 0) to toAddr(1 0)
 LDA (fromAddr),Y
 STA (toAddr),Y

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: updateOffsetLo
\       Type: Variable
\   Category: Screen buffer
\    Summary: The offset within screen memory for the player's landscape view
\             of the area to update following a scroll (low byte)
\
\ ******************************************************************************

.updateOffsetLo

 EQUB LO(320 - 8)       \ Direction 0 = 320 - 8 (pan right, scroll left)
 EQUB LO(0)             \ Direction 1 = 0 (pan left, scroll right)
 EQUB LO(0)             \ Direction 2 = 0 (pan up, scroll down)
 EQUB LO(320 * 23)      \ Direction 3 = 320 * 23 (pan down, scroll up)

\ ******************************************************************************
\
\       Name: updateOffsetHi
\       Type: Variable
\   Category: Screen buffer
\    Summary: The offset within screen memory for the player's landscape view
\             of the area to update following a scroll (high byte)
\
\ ******************************************************************************

.updateOffsetHi

 EQUB HI(320 - 8)       \ Direction 0 = 320 - 8 (pan right, scroll left)
 EQUB HI(0)             \ Direction 1 = 0 (pan left, scroll right)
 EQUB HI(0)             \ Direction 2 = 0 (pan up, scroll down)
 EQUB HI(320 * 23)      \ Direction 3 = 320 * 23 (pan down, scroll up)

\ ******************************************************************************
\
\       Name: scrollScreenLo
\       Type: Variable
\   Category: Screen buffer
\    Summary: The amount to change the start of screen memory in order to scroll
\             the player's landscape view through each direction (low byte)
\
\ ******************************************************************************

.scrollScreenLo

 EQUB LO(+8)            \ Direction 0 = +8 (pan right, scroll left)
 EQUB LO(-8)            \ Direction 1 = -8 (pan left, scroll right)
 EQUB LO(-320)          \ Direction 2 = -320 (pan up, scroll down)
 EQUB LO(+320)          \ Direction 3 = +320 (pan down, scroll up)

\ ******************************************************************************
\
\       Name: scrollScreenHi
\       Type: Variable
\   Category: Screen buffer
\    Summary: The amount to change the start of screen memory in order to scroll
\             the player's landscape view through each direction (high byte)
\
\ ******************************************************************************

.scrollScreenHi

 EQUB HI(+8)            \ Direction 0 = +8 (pan right, scroll left)
 EQUB HI(-8)            \ Direction 1 = -8 (pan left, scroll right)
 EQUB HI(-320)          \ Direction 2 = -320 (pan up, scroll down)
 EQUB HI(+320)          \ Direction 3 = +320 (pan down, scroll up)

\ ******************************************************************************
\
\       Name: screenBufferHi
\       Type: Variable
\   Category: Screen buffer
\    Summary: The value to add to scrollScreenHi for each direction to get the
\             high byte of the screen buffer address of the content to scroll in
\
\ ------------------------------------------------------------------------------
\
\ This table contains the address within the screen buffer from which the
\ interrupt routine should start pulling screen content to scroll onto the
\ screen, depending on the direction of the scroll. The content that should be
\ pulled onto the screen at the start of the scrolling process is as follows:
\
\   * When panning right: The left column of the column-shaped screen buffer
\     appears first as the new content scrolls in from the right
\
\   * When panning left: The right column of the column-shaped screen buffer
\     appears first as the new content scrolls in from the right
\
\   * When panning up: The bottom row of the row-shaped screen buffer appears
\     first as the new content scrolls in from above
\
\   * When panning down: The top row of the row-shaped screen buffer appears
\     first as the new content scrolls in from below
\
\ This table contains the address of the new content for each panning direction,
\ but with a slight complication. The first step in scrolling content onto the
\ screen is to add the scrolling direction in (scrollScreenHi scrollScreenLo),
\ so to make sure the first scroll moves the correct content onto the screen,
\ the values in this table already have the corresponding value of
\ (scrollScreenHi scrollScreenLo) subtracted from them, so when this is added
\ at the start of the scroll, the address correctly points to the address of the
\ new content in the screen buffer.
\
\ The screen buffer is at address &3F00, each character column takes up eight
\ bytes of buffer space, and each character row takes up 320 bytes of buffer
\ space.
\
\ ******************************************************************************

.screenBufferHi

 EQUB HI(&3F00 + 0 * 8 - 8)     \ Direction 0 (pan right, scroll left)
                                \
                                \ &3F00 = base address of screen buffer
                                \
                                \ 0 * 8 = the left column (column 0) of the
                                \         16-column screen buffer
                                \
                                \ -8 = - (scrollScreenHi scrollScreenLo)
                                \    = - +8

 EQUB HI(&3F00 + 15 * 8 + 8)    \ Direction 1 (pan left, scroll right)
                                \
                                \ &3F00 = base address of screen buffer
                                \
                                \ 15 * 8 = the right column (column 15) of the
                                \          16-column screen buffer
                                \
                                \ 8 = - (scrollScreenHi scrollScreenLo)
                                \   = - -8

 EQUB HI(&3F00 + 7 * 320 + 320) \ Direction 2 (pan up, scroll down)
                                \
                                \ &3F00 = base address of screen buffer
                                \
                                \ 8 * 320 = the bottom row (row 7) of the
                                \           8-row screen buffer
                                \
                                \ 320 = - (scrollScreenHi scrollScreenLo)
                                \     = - -320

 EQUB HI(&3F00 + 0 * 320 - 320) \ Direction 3 (pan down, scroll up)
                                \
                                \ &3F00 = base address of screen buffer
                                \
                                \ 8 * 320 = the top row (row 0) of the
                                \           8-row screen buffer
                                \
                                \ -320 = - (scrollScreenHi scrollScreenLo)
                                \      = - +320

\ ******************************************************************************
\
\       Name: screenBufferLo
\       Type: Variable
\   Category: Screen buffer
\    Summary: The value to add to scrollScreenLo for each direction to get the
\             low byte of the screen buffer address of the content to scroll in
\
\ ------------------------------------------------------------------------------
\
\ See screenBufferHi for an explanation of this table.
\
\ ******************************************************************************

.screenBufferLo

 EQUB LO(&3F00 + 0 * 8 - 8)     \ Direction 0 (pan right, scroll left)
                                \
                                \ &3F00 = base address of screen buffer
                                \
                                \ 0 * 8 = the left column (column 0) of the
                                \         16-column screen buffer
                                \
                                \ -8 = - (scrollScreenHi scrollScreenLo)
                                \    = - +8

 EQUB LO(&3F00 + 15 * 8 + 8)    \ Direction 1 (pan left, scroll right)
                                \
                                \ &3F00 = base address of screen buffer
                                \
                                \ 15 * 8 = the right column (column 15) of the
                                \          16-column screen buffer
                                \
                                \ 8 = - (scrollScreenHi scrollScreenLo)
                                \   = - -8

 EQUB LO(&3F00 + 7 * 320 + 320) \ Direction 2 (pan up, scroll down)
                                \
                                \ &3F00 = base address of screen buffer
                                \
                                \ 8 * 320 = the bottom row (row 7) of the
                                \           8-row screen buffer
                                \
                                \ 320 = - (scrollScreenHi scrollScreenLo)
                                \     = - -320

 EQUB LO(&3F00 + 0 * 320 - 320) \ Direction 3 (pan down, scroll up)
                                \
                                \ &3F00 = base address of screen buffer
                                \
                                \ 8 * 320 = the top row (row 0) of the
                                \           8-row screen buffer
                                \
                                \ -320 = - (scrollScreenHi scrollScreenLo)
                                \      = - +320

\ ******************************************************************************
\
\       Name: panAngleToUpdate
\       Type: Variable
\   Category: Drawing the landscape
\    Summary: Pitch and yaw angles for panning the landscape view, so the output
\             of DrawLandscapeView will be the bit we add when updating the view
\
\ ------------------------------------------------------------------------------
\
\ This table contains the angles through which we need to pitch or yaw the
\ landscape view when we need to scroll the landscape view during a pan.
\
\ The DrawLandscapeView routine always renders the full view, and its output is
\ clipped to the size of the screen or screen buffer. This clipping is done on
\ the screen x- and y-coordinates, and the clipping is done from the right or
\ bottom edges of the screen.
\
\ This means that when we pan the screen, we effectively redraw the whole view,
\ which is 20 yaw angles wide and 12 pitch angles tall, and then use the newly
\ drawn portion from the top-left corner of that redrawn view for the new part
\ that we scroll into the screen to complete the pan.
\
\ When panning left, we can simply subtract 8 from the player's current yaw
\ angle to rotate the player's view to the left. This moves the player's gaze to
\ the left, so when we draw the new landscape view into the screen buffer, the
\ portion on the left of the view is the new part that the player is now seeing,
\ so clipping the left portion of the view into the screen buffer will give us
\ the content that we need to scroll in from the left to perform the pan.
\
\ Things are different when panning right. If we simply add 8 to the player's
\ current yaw angle, then the new part of the landscape view will be on the far
\ right of the newly drawn view, so it will be clipped when drawing into the
\ screen buffer. So instead we add 20 to the player's yaw angle to rotate the
\ view to the right by an entire screen's width, so when the view is drawn and
\ clipped, the new portion will be on the left of the newly drawn view, just as
\ it was when panning left. As long as we make sure to set the player's yaw
\ angle correctly after we have finished drawing - by subtracting 12 from the
\ player's yaw angle, leaving them with a net rotation of 8 to the right - then
\ this approach ensures that the new portion of the screen is drawn into the
\ screen buffer correctly.
\ 
\ The same approach is applied when panning vertically. If we pan up, then we
\ simply add 4 to the player's yaw angle so they look up higher. This moves the
\ player's gaze up, so when we draw the new landscape view into the screen
\ buffer, the portion at the top of the view is the new part that the player is
\ now seeing, so clipping the top portion of the view into the screen buffer
\ will give us the content that we need to scroll in from the top to perform the
\ pan.
\
\ However, if we are panning down then we need to jump down a whole screen's
\ height, so we subtract 12 from the player's pitch angle, as this is the height
\ of the screen. We then draw the new view, which puts the new portion of the
\ view into the screen buffer. We then fix the player's pitch angle by adding 8,
\ so the net result is a pitch rotation of -4, as required.
\
\ ******************************************************************************

.panAngleToUpdate

 EQUB 20                \ Direction 0 (pan right, scroll left) 
 EQUB -8                \ Direction 1 (pan left, scroll right)
 EQUB 4                 \ Direction 2 (pan up, scroll down)
 EQUB -12               \ Direction 3 (pan down, scroll up)

\ ******************************************************************************
\
\       Name: StartScrollingView
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Start a scroll process in the background by setting the number of
\             scroll steps and the address to start copying new content from
\
\ ******************************************************************************

.StartScrollingView

 STA numberOfScrolls    \ Store the number of scroll steps required in the
                        \ variable
                        \
                        \ When this variable is non-zero, the interrupt routine
                        \ will scroll the screen by this many steps in the
                        \ background

                        \ Fall through into SetBufferAddress to set the address
                        \ from which the interrupt routine should start fetching
                        \ new content to scroll onto the screen

\ ******************************************************************************
\
\       Name: SetBufferAddress
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Set screenBufferAddr(1 0) to the address from which the interrupt
\             routine should fetch new content to scroll onto the screen
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The direction of scrolling that we are applying:
\
\                         * 0 = pan right
\                        
\                         * 1 = pan left
\                        
\                         * 2 = pan up
\                        
\                         * 3 = pan down
\
\ ******************************************************************************

.SetBufferAddress

 LDA screenBufferLo,Y   \ Set screenBufferAddr(1 0) to the Y-th entry from the
 STA screenBufferAddr   \ screenBufferHi and screenBufferLo lookup tables
 LDA screenBufferHi,Y   \
 STA screenBufferAddr+1 \ This sets screenBufferAddr(1 0) to the address from
                        \ which the interrupt routine should start pulling
                        \ screen content to scroll onto the screen, so:
                        \
                        \   * When panning right: The left column of the
                        \     column-shaped screen buffer appears first as the
                        \     new content scrolls in from the right
                        \
                        \   * When panning left: The right column of the
                        \     column-shaped screen buffer appears first as the
                        \     new content scrolls in from the right
                        \
                        \   * When panning up: The bottom row of the row-shaped
                        \     screen buffer appears first as the new content
                        \     scrolls in from above
                        \
                        \   * When panning down: The top row of the row-shaped
                        \     screen buffer appears first as the new content
                        \     scrolls in from below
                        \
                        \ So this sets screenBufferAddr(1 0) to the address
                        \ where the interrupt routine should start fetching new
                        \ content to scroll onto the screen
                        \
                        \ See the documentation for screenBufferHi for a
                        \ deeper look into the exact values that are set

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: UseRowBuffer
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Configure the row buffer for use
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   rbuf1               Set the minimum and maximum pitch angled for the buffer
\                       type specified in Y (0 = row buffer, 1 = column buffer)
\
\ ******************************************************************************

.UseRowBuffer

 LDA #0                 \ Call ConfigureBuffer with A = 0 to set up the screen
 JSR ConfigureBuffer    \ buffer for use as a row buffer

 LDY #0                 \ Set Y = 0 so we set the maximum and minimum pitch
                        \ angles for the row buffer in the following

.rbuf1

 LDA maxBufferPitch,Y   \ Set maxPitchAngle to the maximum pitch angle allowed
 STA maxPitchAngle      \ in the buffer specified in Y

 LDA minBufferPitch,Y   \ Set minPitchAngle to the minimum pitch angle allowed
 STA minPitchAngle      \ in the buffer specified in Y

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: maxBufferPitch
\       Type: Variable
\   Category: Screen buffer
\    Summary: Maximum allowed pitch angles for points in the screen buffer
\
\ ******************************************************************************

.maxBufferPitch

 EQUB 240               \ Row buffer contains pitch angles from 176 to 240

 EQUB 240               \ Column buffer contains pitch angles from 48 to 240

\ ******************************************************************************
\
\       Name: minBufferPitch
\       Type: Variable
\   Category: Screen buffer
\    Summary: Minimum allowed pitch angles for points in the screen buffer
\
\ ******************************************************************************

.minBufferPitch

 EQUB 176               \ Row buffer contains pitch angles from 176 to 240

 EQUB 48                \ Column buffer contains pitch angles from 48 to 240

\ ******************************************************************************
\
\       Name: UseColumnBuffer
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Configure the column buffer for use
\
\ ******************************************************************************

.UseColumnBuffer

 LDA #2                 \ Call ConfigureBuffer with A = 2 to set up the screen
 JSR ConfigureBuffer    \ buffer for use as a column buffer

                        \ Fall through into SetColumnBufferMax to set the
                        \ maximum and minimum pitch angles for the column buffer

\ ******************************************************************************
\
\       Name: SetColumnBufferMax
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Set the maximum and minimum pitch angles for the column buffer
\
\ ******************************************************************************

.SetColumnBufferMax

 LDY #1                 \ Set Y = 1 so we set the maximum and minimum pitch
                        \ angles for the column buffer when we jump to rbuf1

 BNE rbuf1              \ Jump to rbuf1 to set the maximum and minimum pitch
                        \ angles for the column buffer and return from the
                        \ subroutine using a tail call (this BNE is effectively
                        \ a JMP as Y is never zero)

\ ******************************************************************************
\
\       Name: MoveSights
\       Type: Subroutine
\   Category: Sights
\    Summary: Check for up/down/left/right key presses and move the sights
\             accordingly, pannign the screen if they go past the screen edges
\
\ ******************************************************************************

.MoveSights

 JSR MoveSightsSideways \ Check for the left/right keys and move the sights
                        \ accordingly, panning to the left or right if they go
                        \ past the screen edges

 LDA panKeyBeingPressed \ If panKeyBeingPressed contains a key press then one
 BPL sigh1              \ of the left and right keys is being pressed, so jump
                        \ to sigh1 to skip scanning the up and down keys as we
                        \ can only move the sights in one direction at a time

 JSR MoveSightsUpDown   \ Check for the up/down keys and move the sights
                        \ accordingly, panning up or down if they go past the
                        \ screen edges

.sigh1

 JMP DrawSights         \ Jump to DrawSights to draw the sights in their new
                        \ position, returning from the subroutine using a tail
                        \ call

\ ******************************************************************************
\
\       Name: MoveSightsSideways
\       Type: Subroutine
\   Category: Sights
\    Summary: Check for the left/right keys and move the sights accordingly,
\             panning to the left or right if they go past the screen edges
\
\ ******************************************************************************

.MoveSightsSideways

 LDX keyLogger          \ Set X to the key logger entry for "S" and "D" (pan
                        \ left, pan right), which are used to move the sights

 BMI sisd4              \ If there is no key press in the key logger entry, jump
                        \ to sisd4 to return from the subroutine

                        \ If we get here then "S" or "D" is being pressed, which
                        \ will put 1 or 0 into the key logger respectively

 BNE sisd2              \ If X = 1 then "S" is being pressed, so jump to sisd2
                        \ to process moving the sights left

                        \ If we get here then X = 0, so "D" is being pressed,
                        \ which is the key for moving the sights right

 LDA xSights            \ Increment xSights to move the sights right
 CLC
 ADC #1

 CMP #144               \ If xSights < 144 then skip the following, as the
 BCC sisd1              \ sights have not moved off the right edge of the screen

                        \ If we get here then the sights have just moved off the
                        \ right edge of the screen, so we need to pan the screen
                        \ by moving the sights back towards the centre of the
                        \ screen and starting a pan right by "pressing" the
                        \ relevant pan key

 SBC #64                \ Subtract 64 from A to move the sights to the left by
                        \ 64, as we are about to pan the screen to the right
                        \ (the subtraction works because we passed through a
                        \ BCC so we know the C flag is set)

 STX panKeyBeingPressed \ Set panKeyBeingPressed to the key logger entry for "D"
                        \ to pretend that the "D" key is being pressed to pan
                        \ the screen as well as move the sights
                        \
                        \ This will pan to the right by scrolling the screen to
                        \ the left

.sisd1

 STA xSights            \ Update the x-coordinate of the sights to the updated
                        \ value in A

 AND #%00000011         \ If the x-coordinate is now a multiple of four then the
 BEQ SetSightsAddress   \ sights just moved right into the next character block
                        \ (as each block is four pixels wide), so jump to
                        \ SetSightsAddress with X = 0 to update the screen
                        \ variables for the sights

 JMP sisd4              \ Otherwise jump to sisd4 to return from the subroutine

.sisd2

                        \ If we get here then X = 1, so "S" is being pressed,
                        \ which is the key for moving the sights left

 LDA xSights            \ Decrement xSights to move the sights left
 SEC
 SBC #1

 CMP #16                \ If xSights >= 16 then skip the following, as the
 BCS sisd3              \ sights have not moved off the left edge of the screen

                        \ If we get here then the sights have just moved off the
                        \ left edge of the screen, so we need to pan the screen
                        \ by moving the sights back towards the centre of the
                        \ screen and starting a pan left by "pressing" the
                        \ relevant pan key

 ADC #64                \ Add 64 to A to move the sights to the right by 64, as
                        \ we are about to pan the screen to the left (the
                        \ addition works because we passed through a BCS so we
                        \ know the C flag is clear)

 STX panKeyBeingPressed \ Set panKeyBeingPressed to the key logger entry for "S"
                        \ to pretend that the "S" key is being pressed to pan
                        \ the screen as well as move the sights
                        \
                        \ This will pan to the left by scrolling the screen to
                        \ the right

.sisd3

 STA xSights            \ Update the x-coordinate of the sights to the updated
                        \ value in A

 AND #%00000011         \ If the x-coordinate is now one less than a multiple of
 CMP #%00000011         \ four then the sights just moved left into the previous
 BEQ SetSightsAddress   \ character block (as each block is four pixels wide),
                        \ so jump to SetSightsAddress to update the screen
                        \ variables for the sights

.sisd4

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: MoveSightsUpDown
\       Type: Subroutine
\   Category: Sights
\    Summary: Check for the up/down keys and move the sights accordingly,
\             panning up or down if they go past the screen edges
\
\ ******************************************************************************

.MoveSightsUpDown

 LDX playerObject       \ Set Y to the current pitch angle of the player
 LDY objectPitchAngle,X

 LDX keyLogger+2        \ Set X to the key logger entry for "L" and "," (pan
                        \ up, pan down), which are used to move the sights

 BMI sadr3              \ If there is no key press in the key logger entry, jump
                        \ to sadr3 to return from the subroutine

                        \ If we get here then "L" or "," is being pressed, which
                        \ will put 2 or 3 into the key logger respectively

 CPX #2                 \ If X = 3 then "," is being pressed, so jump to siud2
 BNE siud2              \ to process moving the sights down

                        \ If we get here then X = 2, so "L" is being pressed,
                        \ which is the key for moving the sights up

 LDA ySights            \ Increment ySights to move the sights up
 CLC
 ADC #1

 CMP #160               \ If ySights < 160 then skip the following, as the
 BCC siud1              \ sights have not moved off the top edge of the screen

 CPY highestPitchAngle  \ If the player's pitch angle is already equal to the
 BEQ sadr3              \ the pitch angle of the highest gaze allowed, then jump
                        \ to sadr3 to return from the subroutine without moving
                        \ the sights, as we can't move them any higher

 SEC                    \ Subtract 64 from A to move the sights down by 64, as
 SBC #64                \ we are about to pan the screen up

 STX panKeyBeingPressed \ Set panKeyBeingPressed to the key logger entry for "L"
                        \ to pretend that the "L" key is being pressed to pan
                        \ the screen as well as move the sights
                        \
                        \ This will pan up by scrolling the screen down

.siud1

 STA ySights            \ Update the y-coordinate of the sights to the updated
                        \ value in A

 AND #%00000111         \ If the y-coordinate is not a multiple of eight then
 BNE SetSightsAddress   \ the sights are still within the same character row, so
                        \ jump to SetSightsAddress with X = 2 to update the
                        \ address variables for the sights

 JMP siud4              \ Otherwise jump to sisd4 to increment X to 4 before
                        \ falling into SetSightsAddress to set the address
                        \ variables for the sights

.siud2

                        \ If we get here then X = 3, so "," is being pressed,
                        \ which is the key for moving the sights down

 LDA ySights            \ Decrement ySights to move the sights down
 SEC
 SBC #1

 CMP #32                \ If ySights >= 32 then skip the following, as the
 BCS siud3              \ sights have not moved off the bottom edge of the
                        \ screen

 CPY lowestPitchAngle   \ If the player's pitch angle is already equal to the
 BEQ sadr3              \ the pitch angle of the lowest gaze allowed, then jump
                        \ to sadr3 to return from the subroutine without moving
                        \ the sights, as we can't move them any lower

 CLC                    \ Add 64 to A to move the sights up by 64, as we are
 ADC #64                \ about to pan the screen up

 STX panKeyBeingPressed \ Set panKeyBeingPressed to the key logger entry for ","
                        \ to pretend that the "," key is being pressed to pan
                        \ the screen as well as move the sights
                        \
                        \ This will pan down by scrolling the screen up

.siud3

 STA ySights            \ Update the y-coordinate of the sights to the updated
                        \ value in A

 AND #%00000111         \ If the y-coordinate is not one less than a multiple of
 CMP #%00000111         \ eight then the sights are still within the current
 BNE SetSightsAddress   \ character row, so jump to SetSightsAddress with X = 3
                        \ to update the address variables for the sights

                        \ Otherwise increment X to 5 before falling into
                        \ SetSightsAddress to set the address variables for the
                        \ sights

.siud4

 INX                    \ Increment X by 2, so:
 INX                    \
                        \   * X = 4 if "L" was pressed to move the sights up and
                        \     this moved the sights into the character row above
                        \
                        \   * X = 5 if "," was pressed to move the sights down
                        \     and this moved the sights into the character row
                        \     below

                        \ Fall into SetSightsAddress to set the address
                        \ variables for the sights

\ ******************************************************************************
\
\       Name: SetSightsAddress
\       Type: Subroutine
\   Category: Sights
\    Summary: Update the address variables for the sights when they move into a
\             new character block or row
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   Describes how the sights have moved when they move into
\                       a new character block or row in screen memory:
\
\                         * 0 if the sights moved right into the next character
\                           block
\
\                         * 1 if the sights moved left into the previous
\                           character block
\
\                         * 2 if the sights moved up within the same row
\
\                         * 3 if the sights moved down within the same row
\
\                         * 4 if the sights moved up into the row above
\
\                         * 5 if the sights moved down into the row below
\
\ ------------------------------------------------------------------------------
\
\ Other entry points:
\
\   sadr3               Contains an RTS
\
\ ******************************************************************************

.SetSightsAddress

                        \ We calculate the new screen address for the sights
                        \ after the movement type described in X, by adding the
                        \ relevant address change from entry X in the tables at
                        \ (sightsMoveAddrHi sightsMoveAddrLo)

 LDA sightsScreenAddr   \ Add the address change for the movement type in X to
 CLC                    \ the sights screen address in sightsScreenAddr(1 0)
 ADC sightsMoveAddrLo,X \
 STA sightsScreenAddr   \ We start by calculating this:
 LDA sightsScreenAddr+1 \
 ADC sightsMoveAddrHi,X \   (A sightsScreenAddr) = viewScreenAddr(1 0)
                        \              + (sightsMoveAddrHi+X sightsMoveAddrLo+X)

 CMP #&80               \ If the high byte in A >= &80 then the new address is
 BCC sadr1              \ past the end of screen memory, so subtract &20 from
 SBC #&20               \ the high byte so the address wraps around within the
                        \ range of screen memory between &6000 and &8000
                        \
                        \ If the high byte is in range, jump to sadr1 to check
                        \ the high byte against the start of screen memory

 JMP sadr2              \ Jump to sadr2 to skip the next check, as we know it
                        \ doesn't apply

.sadr1

 CMP #&60               \ If the high byte in A < &60 then the new address is
 BCS sadr2              \ before the start of screen memory, so add &20 to the
 ADC #&20               \ high byte so the address wraps around within the range
                        \ of screen memory between &6000 and &8000

.sadr2

 STA sightsScreenAddr+1 \ Store the high byte of the result, so we now have:
                        \
                        \   sightsScreenAddr(1 0) = viewScreenAddr(1 0)
                        \              + (sightsMoveAddrHi+X sightsMoveAddrLo+X)
                        \
                        \ with the address wrapped around as required

.sadr3

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawSights
\       Type: Subroutine
\   Category: Sights
\    Summary: Draw the sights on the screen, saving the existing screen contents
\             in the sights pixel byte stash
\
\ ******************************************************************************

.DrawSights

 LDA doNotDrawSights    \ If bit 7 of doNotDrawSights is set then we do not draw
 BMI dras2              \ the sights, so jump to dras12 via dras2 to return from
                        \ the subroutine

 JSR RemoveSights       \ First we remove the sights from the screen (if there
                        \ are any sights on-screen), so if we are drawing the
                        \ sights to move them, this removes the old sights
                        \
                        \ This also sets sightsByteCount = 0 to reset the sights
                        \ pixel byte stash

                        \ We now set the coordinates of the "brush" that we're
                        \ going to use to draw the sights
                        \
                        \ The coordinates of the brush are stored relative to
                        \ the top-left corner of the character block containing
                        \ the top of the sights
                        \
                        \ The current coordinate of the brush is stored as
                        \ follows:
                        \
                        \   * sightsByteAddr(1 0) contains the address of the
                        \     character block in which we are dabbing our brush
                        \
                        \   * The x-coordinate is stored in xSightsBrush in the
                        \     form of a pixel offset within the character block
                        \     pointed to by sightsByteAddr(1 0), so this is
                        \     always in the range 0 to 3
                        \
                        \   * The y-coordinate is stored in Y in the form of a
                        \     pixel row offset within the character block
                        \     pointed to by sightsByteAddr(1 0), so this is
                        \     always in the range 0 to 7

 LDA xSights            \ Set xSightsBrush as follows:
 AND #%00000011         \
 STA xSightsBrush       \   xSightsBrush = xSights mod 4
                        \
                        \ Each pixel byte contains four pixels, so this sets
                        \ xSightsBrush to the x-coordinate of the sights within
                        \ the pixel byte in which the sights appear, in the
                        \ range 0 to 3
                        \
                        \ This gives us the x-coordinate of the starting point
                        \ for the brush at the top of the sights, relative to
                        \ the top-left corner of the character block containing
                        \ the top of the sights

 LDA sightsScreenAddr   \ Set Y to bits 0-2 of the address of the sights in
 AND #%00000111         \ screen memory, so Y contains the number of the pixel
 TAY                    \ row within the character block containing the sights
                        \
                        \ This gives us the y-coordinate of the starting point
                        \ for the brush at the top of the sights, relative to
                        \ the top-left corner of the character block containing
                        \ the top of the sights

 LDA sightsScreenAddr   \ Set sightsByteAddr(1 0) to bits 3-15 of the address
 AND #%11111000         \ of the sights in screen memory, so it contains the
 STA sightsByteAddr     \ address of the top-left corner of the character block
 LDA sightsScreenAddr+1 \ containing the top of the sights
 STA sightsByteAddr+1

                        \ We now draw the sights one step at a time, dabbing the
                        \ brush on the screen for each step
                        \
                        \ There are 12 steps when drawing the sights, and we
                        \ draw one screen byte (four pixels) in each step,
                        \ storing the original screen contents in the sights
                        \ pixel byte stash, so we can easily remove the sights
                        \ later
                        \
                        \ We start by placing our brush at the top of the sights
                        \ and dabbing the screen to draw the first pixel byte
                        \
                        \ The top of the sights are at a relative coordinate of
                        \ (xSightsBrush, Y) from the start of the character
                        \ block of the sights, so this is where we start
                        \
                        \ We then apply the steps from the xSightsStep and
                        \ ySightsStep tables to the brush coordinates, dabbing
                        \ the screen at each step, starting from step 0 and
                        \ moving as follows (where steps 10 and 11 are shown as
                        \ A and B):
                        \
                        \        00
                        \        11
                        \        22
                        \   334455667788
                        \        99
                        \        AA
                        \        BB
                        \
                        \ The current step number is stored in sightsByteCount,
                        \ which also tracks the size of the sights pixel byte
                        \ stash

.dras1

                        \ We start by adding the next step to the y-coordinate
                        \ of the brush and updating sightsByteAddr(1 0) and Y
                        \ accordingly

 LDX sightsByteCount    \ Set X to the current step number, which is also the
                        \ current size of the sights pixel byte stash

 TYA                    \ Set A = Y + the X-th entry in ySightsStep
 CLC                    \
 ADC ySightsStep,X      \ So this applies the next step from the ySightsStep
                        \ table to the relative y-coordinate of the brush in Y

 BPL dras3              \ The table at ySightsStep is terminated by %10000000,
                        \ so if bit 7 of the result is clear then we haven't yet
                        \ reached the end of the table, so jump to dras3 to keep
                        \ drawing

                        \ Otherwise we just read the terminator at the end of
                        \ the ySightsStep table, so fall through into dras2 to
                        \ return from the subroutine

.dras2

 JMP dras12             \ Jump to dras12 to return from the subroutine

.dras3

 CMP #8                 \ Compare A and 8 and set the status flags for us to
                        \ check below

 TAY                    \ Set Y to the updated value of A, so Y now contains the
                        \ updated y-coordinate of the brush after applying the
                        \ next step from ySightsStep 

 BCC dras5              \ If A < 8 then the y-coordinate has not moved past the
                        \ bottom of the current character row, so jump to dras5
                        \ to move on to processing the x-coordinate

                        \ We have just stepped down into the next character row,
                        \ so we need to recalculate the values in Y and
                        \ sightsByteAddr(1 0) to point to the correct address
                        \ in the next chadacter row

 SBC #8                 \ Set Y = Y - 8
 TAY                    \
                        \ This resets Y to the number of the pixel row in the
                        \ next character row down, as each character row is
                        \ eight bytes high
                        \
                        \ This subtraction works as we passed through a BCC
                        \ above, so we know the C flag is set

 LDA sightsByteAddr     \ Set (A sightsByteAddr) = sightsByteAddr(1 0) + &140
 CLC                    \                        = sightsByteAddr(1 0) + 320
 ADC #&40               \
 STA sightsByteAddr     \ Each character row in screen mode 5 takes up 320 bytes
 LDA sightsByteAddr+1   \ (40 character blocks of eight bytes each), so this
 ADC #&01               \ sets sightsByteAddr(1 0) to the address of the next
                        \ row down in screen memory

 CMP #&80               \ If the high byte in A >= &80 then the new address is
 BCC dras4              \ past the end of screen memory, so subtract &20 from
 SBC #&20               \ the high byte so the address wraps around within the
                        \ range of screen memory between &6000 and &8000

.dras4

 STA sightsByteAddr+1   \ Store the high byte of the result, so we now have:
                        \
                        \   sightsByteAddr(1 0) = sightsByteAddr(1 0) + 320
                        \
                        \ with the address wrapped around as required

.dras5

                        \ We now need to add the next step to the x-coordinate
                        \ of the brush and update sightsByteAddr(1 0) and
                        \ xSightsBrush accordingly

 LDA xSightsStep,X      \ Set A to the next step from the xSightsStep that we
                        \ need to apply to the relative x-coordinate in
                        \ xSightsBrush

 BEQ dras9              \ If the step is zero then we don't need to change the
                        \ x-coordinate in xSightsBrush, so jump to dras9 to
                        \ move on to the actual drawing step

 CLC                    \ Set xSightsBrush = xSightsBrush + A
 ADC xSightsBrush       \
 STA xSightsBrush       \ So this applies the next step from the xSightsStep
                        \ table to the relative x-coordinate of the brush in
                        \ xSightsBrush

 AND #%11111100         \ Set A = (A * 2) div 8
 ASL A                  \
                        \ All the step values in xSightsStep and ySightsStep
                        \ and the brush coordinates in xSightsBrush and Y are
                        \ in pixels, with each step in the x-coordinate drawing
                        \ two pixels, so these steps:
                        \
                        \        00
                        \        11
                        \        22
                        \   334455667788
                        \        99
                        \        AA
                        \        BB
                        \
                        \ end up drawing pixels like this:
                        \
                        \        x.
                        \        x.
                        \        x.
                        \   x.x.x.x.x.x.
                        \        x.
                        \        x.
                        \        x.
                        \
                        \ Screen mode 5 contains four pixels in each byte, so to
                        \ convert the x-coordinate of the brush offset from step
                        \ pixels into screen pixels, we have to double it
                        \
                        \ We then apply div 8 to the result to give us the
                        \ offset of the start of the character block containing
                        \ the new position of the brush, as each character block
                        \ contains eight bytes

 BPL dras6              \ If A is a negative value then to make the following
 DEC sightsByteAddr+1   \ addition work we would have to add (&FF A) to make
                        \ the 16-bit addition work in signed 16-bit arithmetic,
                        \ but to save having to do this we can simply decrement
                        \ the high byte of sightsByteAddr(1 0) in advance and
                        \ add (0 A) instead

.dras6

 CLC                    \ Set (A sightsByteAddr) = sightsByteAddr(1 0) + A
 ADC sightsByteAddr     \
 STA sightsByteAddr     \ So this applies the step in A to sightsByteAddr(1 0)
 LDA sightsByteAddr+1
 ADC #0

 CMP #&60               \ If the high byte in A < &60 then the new address is
 BCS dras7              \ before the start of screen memory, so add &20 to the
 ADC #&20               \ high byte so the address wraps around within the range
                        \ of screen memory between &6000 and &8000

 JMP dras8              \ Jump to dras8 to skip the next check, as we know it
                        \ doesn't apply

.dras7

 CMP #&80               \ If the high byte in A >= &80 then the new address is
 BCC dras8              \ past the end of screen memory, so subtract &20 from
 SBC #&20               \ the high byte so the address wraps around within the
                        \ range of screen memory between &6000 and &8000

.dras8

 STA sightsByteAddr+1   \ Store the high byte of the result, so we now have:
                        \
                        \   sightsByteAddr(1 0) = sightsByteAddr(1 0) + A
                        \
                        \ with the address wrapped around as required
                        \
                        \ So this applies the next step to sightsByteAddr(1 0)
                        \ to give us the screen address of the character block
                        \ that we need to update to make the next brush stroke

 LDA xSightsBrush       \ Set xSightsBrush as follows:
 AND #%00000011         \
 STA xSightsBrush       \   xSightsBrush = xSightsBrush mod 4
                        \
                        \ Each pixel byte contains four pixels, so this sets
                        \ xSightsBrush to the x-coordinate of the sights within
                        \ the pixel byte in which the sights appear, in the
                        \ range 0 to 3

.dras9

                        \ We have now set up sightsByteAddr(1 0), xSightsBrush
                        \ and Y to the address of the next pixel byte to paint,
                        \ so let's dab the brush for this step
                        \
                        \ The address of the pixel byte we need to paint is
                        \ sightsByteAddr(1 0) + Y
                        \
                        \ The offset of the pixel within that pixel byte (in
                        \ terms of step pixels) is in xSightsBrush

                        \ First, we need to save the current contents of the
                        \ screen in the sights pixel byte stash by adding the
                        \ screen address to the X-th entry of (sightsByteAddrHi
                        \ sightsByteAddrLo) and the existing contents of that
                        \ address to the X-th entry of sightsByte

 TYA                    \ Set the X-th entry in the sights pixel byte stash
 ORA sightsByteAddr     \ address list at (sightsByteAddrHi sightsByteAddrLo)
 STA sightsByteAddrLo,X \ to sightsByteAddr(1 0) + Y, which is the address of
 LDA sightsByteAddr+1   \ the pixel byte we are about to change
 STA sightsByteAddrHi,X

 LDA (sightsByteAddr),Y \ Set A to the current screen contents of the pixel byte
                        \ we are updating

 STA sightsByte,X       \ Store the current screen contents in the X-th entry in
                        \ the sights pixel byte stash at sightsByte

                        \ We now apply the brush to the pixel byte in screen
                        \ memory at sightsByteAddr(1 0) + Y
                        \
                        \ We do this by taking the existing screen pixel byte in
                        \ A and setting the pixel number xSightsBrush to either
                        \ colour 1 or colour 2, depending on the current colour
                        \ in that pixel
                        \
                        \ Specifically, we draw the sights in colour 2 when the
                        \ background is colour 0 or 1, and we draw the sights in
                        \ colour 1 when the background is colour 2 or 3
                        \
                        \ As an example of physical colours, in landscape 0000
                        \ we paint the sights pixels in white (colour 2) when
                        \ the background is blue (colour 0) or black (colour 1),
                        \ and we paint the sights pixels in black (colour 1)
                        \ when the background is white (colour 2) or green
                        \ (colour 3)
                        \
                        \ This ensures that the sights are visible wherever they
                        \ are on-screen, irrespective of the current screen
                        \ contents

 LDX xSightsBrush       \ Convert xSightsBrush from a number in the range 0 to 3
 AND pixelBitMask,X     \ into a bit mask with that pixel number set (where
                        \ pixel 0 is on the left and pixel 3 is on the right)
                        \
                        \ So if xSightsBrush is 2, for example, the resulting
                        \ mask will be %00100010, in which pixel 2 is set

                        \ At this point, A contains the existing contents of the
                        \ screen byte into which we need to draw the sights,
                        \ with all bits zeroed except for those for the pixel we
                        \ want to colour in

 CMP #%00010000         \ Set the status flags on the comparison of A and
 PHP                    \ %00010000 and push the resulting flags on the stack
                        \ so we can retrieve them below

 LDA (sightsByteAddr),Y \ Set A to the current screen contents of the pixel byte
                        \ we are updating

 AND clearPixelMask,X   \ Clear the pixel number in xSightsBrush by applying a
                        \ pixel bit mask from clearPixelMask where the bits for
                        \ every pixel are set except for pixel X

 PLP                    \ Using the status flags that we put on the stack above,
 BCS dras10             \ check whether A >= %00010000, where A contains the
                        \ existing contents of the screen for pixel X
                        \
                        \ If A >= %00010000 then A must have at least one bit
                        \ set in the high nibble, which means the existing
                        \ contents of pixel X on-screen has to have its top bit
                        \ set, so it must either be colour %10 (2) or %11 (3)
                        \
                        \ As the background is colour 2 or 3, jump to dras10 to
                        \ paint the sights pixel in colour 1

                        \ If we get here then the existing screen contents are
                        \ in colour 0 or 1, so we now paint the sights pixel in
                        \ colour 2

 ORA pixelByteColour2,X \ Set the colour of pixel X to colour 2 by OR'ing in a
                        \ pixel mask where pixel X is set to %10 for colour 2

 BCC dras11             \ Jump to dras11 to skip the following instruction (this
                        \ BCC is effectively a JMP as we just passed through a
                        \ BCS)

.dras10

 ORA pixelByteColour1,X \ Set the colour of pixel X to colour 1 by OR'ing in a
                        \ pixel mask where pixel X is set to %01 for colour 1

.dras11

 STA (sightsByteAddr),Y \ Store the updated pixel byte in screen memory to apply
                        \ the brush to the canvas

 INC sightsByteCount    \ Increment sightsByteCount to move on to the next step
                        \ in the drawing process

 JMP dras1              \ Loop back to draw the next step of the sights

.dras12

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: pixelByteColour2
\       Type: Variable
\   Category: Graphics
\    Summary: A table for converting a pixel number in the range 0 to 3 into a
\             screen mode 5 pixel byte with that pixel set to colour 2 (%10)
\
\ ******************************************************************************

.pixelByteColour2

 EQUB %10000000         \ Pixel byte with pixel 0 set to colour 2

 EQUB %01000000         \ Pixel byte with pixel 1 set to colour 2

 EQUB %00100000         \ Pixel byte with pixel 2 set to colour 2

 EQUB %00010000         \ Pixel byte with pixel 3 set to colour 2

\ ******************************************************************************
\
\       Name: xSightsStep
\       Type: Variable
\   Category: Sights
\    Summary: Steps to take along the x-axis when drawing the sights
\
\ ------------------------------------------------------------------------------
\
\ The xSightsStep and ySightsStep tables define a set of 12 steps to follow when
\ drawing the sights, relative to the start position at the top of the sights.
\
\ The steps draw a shape like this, starting at step 0 and showing steps 10 and
\ 11 as A and B):
\
\        00
\        11
\        22
\   334455667788
\        99
\        AA
\        BB
\
\ Each step is made up of two pixels, one filled (e.g. white) and one
\ transparent, to give a shape like this:
\
\        x.
\        x.
\        x.
\   x.x.x.x.x.x.
\        x.
\        x.
\        x.
\
\ In the above, "x" denotes a filled pixel while "." denotes a transparent
\ pixel.
\
\ ******************************************************************************

.xSightsStep

 EQUB 0                 \ Step  0 = ( 0, 0) -> ( 0,  0)
 EQUB 0                 \ Step  1 = ( 0, 2) -> ( 0,  2)
 EQUB 0                 \ Step  2 = ( 0, 2) -> ( 0,  4)
 EQUB -5                \ Step  3 = (-5, 1) -> (-5,  5)
 EQUB 2                 \ Step  4 = ( 2, 0) -> (-3,  5)
 EQUB 2                 \ Step  5 = ( 2, 0) -> (-1,  5)
 EQUB 2                 \ Step  6 = ( 2, 0) -> ( 1,  5)
 EQUB 2                 \ Step  7 = ( 2, 0) -> ( 3,  5)
 EQUB 2                 \ Step  8 = ( 2, 0) -> ( 5,  5)
 EQUB -5                \ Step  9 = (-5, 1) -> ( 0,  6)
 EQUB 0                 \ Step 10 = ( 0, 2) -> ( 0,  8)
 EQUB 0                 \ Step 11 = ( 0, 2) -> ( 0, 10)

\ ******************************************************************************
\
\       Name: ySightsStep
\       Type: Variable
\   Category: Sights
\    Summary: Steps to take along the y-axis when drawing the sights
\
\ ------------------------------------------------------------------------------
\
\ The ySightsStep and xSightsStep tables define a set of 12 steps to follow when
\ drawing the sights, relative to the start position.
\
\ The steps draw a shape like this, starting at step 0 and showing steps 10 and
\ 11 as A and B):
\
\        33
\        44
\        55
\   00112299AABB
\        66
\        77
\        88
\
\ ******************************************************************************

.ySightsStep

 EQUB 0                 \ Step  0 = ( 0, 0) -> ( 0,  0)
 EQUB 2                 \ Step  1 = ( 0, 2) -> ( 0,  2)
 EQUB 2                 \ Step  2 = ( 0, 2) -> ( 0,  4)
 EQUB 1                 \ Step  3 = (-5, 1) -> (-5,  5)
 EQUB 0                 \ Step  4 = ( 2, 0) -> (-3,  5)
 EQUB 0                 \ Step  5 = ( 2, 0) -> (-1,  5)
 EQUB 0                 \ Step  6 = ( 2, 0) -> ( 1,  5)
 EQUB 0                 \ Step  7 = ( 2, 0) -> ( 3,  5)
 EQUB 0                 \ Step  8 = ( 2, 0) -> ( 5,  5)
 EQUB 1                 \ Step  9 = (-5, 1) -> ( 0,  6)
 EQUB 2                 \ Step 10 = ( 0, 2) -> ( 0,  8)
 EQUB 2                 \ Step 11 = ( 0, 2) -> ( 0, 10)

 EQUB %10000000         \ End of table

\ ******************************************************************************
\
\       Name: RemoveSights
\       Type: Subroutine
\   Category: Sights
\    Summary: Remove the sights from the screen
\
\ ******************************************************************************

.RemoveSights

 LDX sightsByteCount    \ If the sights pixel byte stash is empty then there are
 BEQ rems2              \ no pixel bytes to restore to the screen, so jump to
                        \ rems2 to return from the subroutine 

 DEX                    \ Decrement the size of the sights pixel byte stash to
                        \ give us a loop counter to count throught the bytes

 LDY #0                 \ Set Y = 0 so the STA (sightsByteAddr),Y instruction
                        \ below behaves like STA (sightsByteAddr)

.rems1

 LDA sightsByteAddrLo,X \ Set sightsByteAddr(1 0) to the address for the X-th
 STA sightsByteAddr     \ entry in the sights pixel byte stash, which we get
 LDA sightsByteAddrHi,X \ from the (sightsByteAddrHi sightsByteAddrLo) tables
 STA sightsByteAddr+1

 LDA sightsByte,X       \ Copy the X-th pixel byte from the sights pixel byte
 STA (sightsByteAddr),Y \ stash to the address in sightsByteAddr(1 0), to
                        \ restore this byte of screen memory to its original
                        \ contents, thus removing the sights from this byte

 DEX                    \ Decrement the pixel byte counter

 BPL rems1              \ Loop back until we have restored every byte from the
                        \ sights pixel byte stash into its original address in
                        \ screen memory

 LDX #0                 \ Reset the size of the sights pixel byte stash to zero
 STX sightsByteCount    \ as we have just emptied it

.rems2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: sightsMoveAddrLo
\       Type: Variable
\   Category: Sights
\    Summary: The change to apply to the screen address of the sights when they
\             move into a new character block or row (low byte)
\
\ ******************************************************************************

.sightsMoveAddrLo

 EQUB LO(+8)            \ Move right into the next character block

 EQUB LO(-8)            \ Move left into the previous character block

 EQUB LO(-1)            \ Move up within the same character row

 EQUB LO(+1)            \ Move down within the same character row

 EQUB LO(-320 + 7)      \ Move up into the bottom pixel row of the character row
                        \ above

 EQUB LO(320 - 7)       \ Move down into the top pixel row of the character row
                        \ below

\ ******************************************************************************
\
\       Name: sightsMoveAddrHi
\       Type: Variable
\   Category: Sights
\    Summary: The change to apply to the screen address of the sights when they
\             move into a new character block or row (high byte)
\
\ ******************************************************************************

.sightsMoveAddrHi

 EQUB HI(+8)            \ Move right into the next character block

 EQUB HI(-8)            \ Move left into the previous character block

 EQUB HI(-1)            \ Move up within the same character row

 EQUB HI(+1)            \ Move down within the same character row

 EQUB HI(-320 + 7)      \ Move up into the bottom pixel row of the character row
                        \ above

 EQUB HI(320 - 7)       \ Move down into the top pixel row of the character row
                        \ below

\ ******************************************************************************
\
\       Name: GetIconRowAddress
\       Type: Subroutine
\   Category: Scanner and energy icons
\    Summary: Calculate the address in screen memory of the icon and scanner row
\             at the top of the screen
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   The high byte of the address in iconRowAddr(1 0)
\
\ ******************************************************************************

.GetIconRowAddress

 LDA viewScreenAddr     \ Set iconRowAddr(1 0) = viewScreenAddr(1 0) - &0140
 SEC                    \                      = viewScreenAddr(1 0) - 320
 SBC #&40               \
 STA iconRowAddr        \ starting with the low bytes

 LDA viewScreenAddr+1   \ And then the high bytes
 SBC #&01

 CMP #&60               \ If the result of the subtraction is less than &6000,
 BCS gicn1              \ add &2000 to wrap it around so the result is within
 ADC #&20               \ screen memory from &6000 and up

.gicn1

 STA iconRowAddr+1      \ Store the high byte of the result in iconRowAddr(1 0),
                        \ so we have the following:
                        \
                        \   iconRowAddr(1 0) = viewScreenAddr(1 0) - 320
                        \
                        \ Each character row in screen mode 5 takes up 320 bytes
                        \ (40 character blocks of eight bytes each), so this
                        \ sets iconRowAddr(1 0) to the address of the character
                        \ row just above the player's scrolling landscape view,
                        \ which is in screen memory at viewScreenAddr(1 0)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ShowIconBuffer
\       Type: Subroutine
\   Category: Screen buffer
\    Summary: Display the redrawn icon and scanner row by copying the contents
\             of the icon screen buffer into screen memory
\
\ ******************************************************************************

.ShowIconBuffer

 LDA #HI(iconBuffer)    \ Set fromAddr(1 0) = iconBuffer(1 0)
 STA fromAddr+1         \
 LDA #LO(iconBuffer)    \ So the call to ShowBufferRow copies from the icon
 STA fromAddr           \ screen buffer, which contains the redrawn icon and
                        \ scanner row

 LDA iconRowAddr+1      \ Set toAddr(1 0) = iconRowAddr(1 0)
 STA toAddr+1           \
 LDA iconRowAddr        \ So the call to ShowBufferRow copies from the icon
 STA toAddr             \ screen buffer into the screen memory for the icon and
                        \ scanner row at the top of the screen

 JMP ShowBufferRow      \ Jump to ShowBufferRow to copy the contents of the
                        \ icon screen buffer into screen memory

\ ******************************************************************************
\
\       Name: arctanLo
\       Type: Variable
\   Category: Maths (Geometry)
\    Summary: Table for arctan values when calculating yaw angles (low byte)
\
\ ******************************************************************************

.arctanLo

 FOR I%, 0, 256

  EQUB LO(INT(0.5 + 32 * ATN(I% / 256) * 256 / ATN(1)))

 NEXT

\ ******************************************************************************
\
\       Name: arctanHi
\       Type: Variable
\   Category: Maths (Geometry)
\    Summary: Table for arctan values when calculating yaw angles (high byte)
\
\ ******************************************************************************

.arctanHi

 FOR I%, 0, 256

  EQUB HI(INT(0.5 + 32 * ATN(I% / 256) * 256 / ATN(1)))

 NEXT

\ ******************************************************************************
\
\       Name: tanHalfAngle
\       Type: Variable
\   Category: Maths (Geometry)
\    Summary: Table for hypotenuse lengths given the tangent of an angle
\
\ ------------------------------------------------------------------------------
\
\ Given the tangent of an angle, X = tan(theta), this table contains the
\ following at index X:
\
\   tanHalfAngle,X = 2 * tan(theta / 2)
\
\ The table contains lookup values for indexes 0 to 128, which correspond to
\ theta angles of 0 to 45 degrees.
\
\ This allows us to approximate the length of the hypotenuse of a triangle with
\ angle theta, adjacent side a and opposite side b, as follows:
\
\   h =~ a + b * tan(theta / 2)
\
\ ******************************************************************************

.tanHalfAngle

 EQUB 0

 FOR I%, 1, 128

  EQUB INT(0.5 + 2 * 256 * TAN(ATN(I% / 128) / 2))

 NEXT

\ ******************************************************************************
\
\       Name: screenRowAddrLo
\       Type: Variable
\   Category: Screen buffer
\    Summary: Address lookup table for character rows in screen memory (low
\             byte)
\
\ ------------------------------------------------------------------------------
\
\ This table contains addresses for each of the 24 character rows in the
\ player's scrolling landscape view in screen memory.
\
\ In its default, unscrolled state, screen memory starts at &7F80, so the
\ address of the first row in the player's scrolling landscape view (i.e. the
\ second row on-screen below the energy icon and scanner row) is &7F80 + 320,
\ or &60C0 (as screen memory wraps around from &8000 back to &6000).
\
\ See the ResetScreenAddress routine for more details.
\
\ ******************************************************************************

.screenRowAddrLo

 FOR I%, 0, 24

  EQUB LO(&60C0 + (I% * &140))

 NEXT

\ ******************************************************************************
\
\       Name: bufferRowAddrLo
\       Type: Variable
\   Category: Screen buffer
\    Summary: Address lookup table for character rows in the screen buffer (low
\             byte)
\
\ ------------------------------------------------------------------------------
\
\ This table contains addresses for each of the 24 character rows in the screen
\ buffer for the player's scrolling landscape view. There is an additional
\ address for a 25th character row, but this clashes with the object data and
\ is unused.
\
\ The buffer rows wrap around in memory after the 16th row, so they can fit into
\ the program space without overlapping with screen memory or game code. The
\ addresses are as follows:
\
\   &3F00 (screenBufferRow0)
\   &4040 (screenBufferRow1)
\   &4180 (screenBufferRow2)
\   &42C0 (screenBufferRow3)
\   &4400 (screenBufferRow4)
\   &4540 (screenBufferRow5)
\   &4680 (screenBufferRow6)
\   &47C0 (screenBufferRow7)
\   &4900 (screenBufferRow8)
\   &4A40 (screenBufferRow9)
\   &4B80 (screenBufferRow10)
\   &4CC0 (screenBufferRow11)
\   &4E00 (screenBufferRow12)
\   &4F40 (screenBufferRow13)
\   &5080 (screenBufferRow14)
\   &51C0 (screenBufferRow15)
\
\ and then they wrap around to the following locations for rows 16 to 25:
\
\   &3FA0 (screenBufferRow16)
\   &40E0 (screenBufferRow17)
\   &4220 (screenBufferRow18)
\   &4360 (screenBufferRow19)
\   &44A0 (screenBufferRow20)
\   &45E0 (screenBufferRow21)
\   &4720 (screenBufferRow22)
\   &4860 (screenBufferRow23)
\   &49A0 (unused)
\
\ The first batch of locations need to be able to store an entire screen row of
\ 320 bytes, so they can be used to store the screen buffer when scrolling in
\ any direction (and specifically for the up and down scrolling, when we need to
\ be able to store eight full character rows in the buffer).
\
\ We only need to use the second batch of locations when we are drawing the left
\ or right buffers when scrolling sideways, as we then need to fit 24 character
\ rows into the buffer. We can fit the first 16 rows into the first batch of
\ buffer rows, but we need more. Luckily, when scrolling sideways, each row is
\ only eight character blocks wide, so each buffer row only needs to be 64 bytes
\ long rather than the 320 bytes needed when scrolling up or down. This means
\ that we are only using the first 64 bytes of each buffer, so we can stick a
\ second batch of buffers in the latter part of each of the first batch.
\
\ In other words, when the player pans up or down, we need to draw eight
\ full-width character rows of new screen content into the screen buffers, each
\ of which is 320 bytes. So we use the screen buffer space as follows:
\
\   &3F00 to &403F for character row 0
\   &4040 to &417F for character row 1
\   &4180 to &42BF for character row 2
\   &42C0 to &43FF for character row 3
\   &4400 to &453F for character row 4
\   &4540 to &467F for character row 5
\   &4680 to &47BF for character row 6
\   &47C0 to &48FF for character row 7
\
\ And when the player pans left or right, the new screen content that we need to
\ draw into the screen buffers is a strip down the side of the screen that's 24
\ character rows tall and eight character columns wide, so each row is 64 bytes
\ long. So we use the screen buffer space as follows:
\
\   &3F00 to &3F3F for character row 0
\   &4040 to &407F for character row 1
\   &4180 to &41BF for character row 2
\   &42C0 to &42FF for character row 3
\   &4400 to &443F for character row 4
\   &4540 to &457F for character row 5
\   &4680 to &46BF for character row 6
\   &47C0 to &47FF for character row 7
\   &4900 to &493F for character row 8
\   &4A40 to &4A7F for character row 9
\   &4B80 to &4BBF for character row 10
\   &4CC0 to &4CFF for character row 11
\   &4E00 to &4E3F for character row 12
\   &4F40 to &4F7F for character row 13
\   &5080 to &50BF for character row 14
\   &51C0 to &51FF for character row 15
\   &3FA0 to &3FDF for character row 16
\   &40E0 to &411F for character row 17
\   &4220 to &425F for character row 18
\   &4360 to &439F for character row 19
\   &44A0 to &43DF for character row 20
\   &45E0 to &461F for character row 21
\   &4720 to &475F for character row 22
\   &4860 to &489F for character row 23
\   &49A0 to &49DF for character row 24
\
\ This structure ensures that the screen buffer always fits into the range &3F00
\ to &51FF, irrespective of the scrolling direction.
\
\ ******************************************************************************

.bufferRowAddrLo

 FOR I%, 0, 15

  EQUB LO(&3F00 + (I% * &140))

 NEXT

 FOR I%, 0, 8

  EQUB LO(&3FA0 + (I% * &140))

 NEXT

\ ******************************************************************************
\
\       Name: screenRowAddrHi
\       Type: Variable
\   Category: Graphics
\    Summary: Address lookup table for character rows in screen memory (high
\             byte)
\
\ ------------------------------------------------------------------------------
\
\ This table contains addresses for each of the 24 character rows in the
\ player's scrolling landscape view in screen memory.
\
\ In its default, unscrolled state, screen memory starts at &7F80, so the
\ address of the first row in the player's scrolling landscape view (i.e. the
\ second row on-screen below the energy icon and scanner row) is &7F80 + 320,
\ or &60C0 (as screen memory wraps around from &8000 back to &6000).
\
\ See the ResetScreenAddress routine for more details.
\
\ ******************************************************************************

.screenRowAddrHi

 FOR I%, 0, 24

  EQUB HI(&60C0 + (I% * &140))

 NEXT

\ ******************************************************************************
\
\       Name: bufferRowAddrHi
\       Type: Variable
\   Category: Screen buffer
\    Summary: Address lookup table for character rows in the screen buffer (high
\             byte)
\
\ ------------------------------------------------------------------------------
\
\ See bufferRowAddrLo for an explanation of this table.
\
\ ******************************************************************************

.bufferRowAddrHi

 FOR I%, 0, 15

  EQUB HI(&3F00 + (I% * &140))

 NEXT

 FOR I%, 0, 8

  EQUB HI(&3FA0 + (I% * &140))

 NEXT

\ ******************************************************************************
\
\       Name: sightsByte
\       Type: Variable
\   Category: Sights
\    Summary: The sights pixel byte stash, which contains the screen pixel bytes
\             behind the sights, so they can be restored to remove the sights
\
\ ******************************************************************************

.sightsByte

 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: sightsByteAddrHi
\       Type: Variable
\   Category: Sights
\    Summary: The screen addresses of the bytes in the sights pixel byte stash,
\             to which they can be restored to remove the sights (high byte)
\
\ ******************************************************************************

.sightsByteAddrHi

 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00

 EQUB &08               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: L3E00
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L3E00

 EQUB &00, &00, &00, &00, &07, &03, &01, &00
 EQUB &70, &30, &10, &00, &77, &33, &11, &00
 EQUB &08, &04, &02, &01, &0F, &07, &03, &01
 EQUB &78, &34, &12, &01, &7F, &37, &13, &01
 EQUB &80, &40, &20, &10, &87, &43, &21, &10
 EQUB &F0, &70, &30, &10, &F7, &73, &31, &10
 EQUB &88, &44, &22, &11, &8F, &47, &23, &11
 EQUB &F8, &74, &32, &11

.L3E3C

 EQUB &FF, &77, &33, &11
 EQUB &00, &00, &00, &00, &00, &08, &0C, &0E
 EQUB &00, &80, &C0, &E0, &00, &88, &CC, &EE
 EQUB &08, &04, &02, &01, &08, &0C, &0E, &0F
 EQUB &08, &84, &C2, &E1, &08, &8C, &CE, &EF
 EQUB &80, &40, &20, &10, &80, &48, &2C, &1E
 EQUB &80, &C0, &E0, &F0, &80, &C8, &EC, &FE
 EQUB &88, &44, &22, &11, &88, &4C, &2E, &1F
 EQUB &88, &C4, &E2, &F1

.L3E7C

 EQUB &88, &CC, &EE, &FF

\ ******************************************************************************
\
\       Name: tileVisibility
\       Type: Variable
\   Category: Drawing the landscape
\    Summary: A table for storing the visibility of each tile from the player's
\             point of view, with one bit per tile (1 = visible, 0 = hidden)
\
\ ******************************************************************************

.tileVisibility

 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ These values are workspace
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ noise and have no meaning
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF

\ ******************************************************************************
\
\       Name: secretCodeStash
\       Type: Subroutine
\   Category: Landscape
\    Summary: A stash for calculated values for each iteration in the
\             CheckSecretCode routine
\
\ ******************************************************************************

.secretCodeStash

 SKIP 0                 \ The secret code stash shares memory with the first
                        \ part of the screen buffer at screenBufferRow0

\ ******************************************************************************
\
\       Name: screenBufferRow0
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 0
\
\ ******************************************************************************

.screenBufferRow0

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow16
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 16 (as part of a column
\             buffer)
\
\ ******************************************************************************

.screenBufferRow16

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow1
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 1
\
\ ******************************************************************************

.screenBufferRow1

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow17
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 17 (as part of a column
\             buffer)
\
\ ******************************************************************************

.screenBufferRow17

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow2
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 2
\
\ ******************************************************************************

.screenBufferRow2

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow18
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 18 (as part of a column
\             buffer)
\
\ ******************************************************************************

.screenBufferRow18

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow3
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 3
\
\ ******************************************************************************

.screenBufferRow3

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow19
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 19 (as part of a column
\             buffer)
\
\ ******************************************************************************

.screenBufferRow19

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow4
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 4
\
\ ******************************************************************************

.screenBufferRow4

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow20
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 20 (as part of a column
\             buffer)
\
\ ******************************************************************************

.screenBufferRow20

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow5
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 5
\
\ ******************************************************************************

.screenBufferRow5

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow21
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 21 (as part of a column
\             buffer)
\
\ ******************************************************************************

.screenBufferRow21

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow6
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 6
\
\ ******************************************************************************

.screenBufferRow6

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow22
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 22 (as part of a column
\             buffer)
\
\ ******************************************************************************

.screenBufferRow22

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow7
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 7
\
\ ******************************************************************************

.screenBufferRow7

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow23
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 23 (as part of a column
\             buffer)
\
\ ******************************************************************************

.screenBufferRow23

 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ These values are workspace
 EQUB &00, &00, &00, &00, &00, &00, &00, &00        \ noise and have no meaning
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow8
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 8
\
\ ******************************************************************************

.screenBufferRow8

 EQUB &FE, &FE, &FF, &FF, &FF, &FF, &FF, &FF        \ These values are workspace
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ noise and have no meaning
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &10
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF

\ ******************************************************************************
\
\       Name: objPointRange
\       Type: Variable
\   Category: Drawing objects
\    Summary: The first and last point numbers for each object
\
\ ******************************************************************************

.objPointRange

 EQUB 0                 \ Object type 0: Robot                 Points   0 to  28
 EQUB 29                \ Object type 1: Sentry                Points  29 to  50
 EQUB 51                \ Object type 2: Tree                  Points  51 to  67
 EQUB 68                \ Object type 3: Boulder               Points  68 to  75
 EQUB 76                \ Object type 4: Meanie                Points  76 to  93
 EQUB 94                \ Object type 5: The Sentinel          Points  94 to 123
 EQUB 124               \ Object type 6: Sentinel's tower      Points 124 to 135
 EQUB 136               \ Object type 7: 3D text block 1       Points 136 to 143
 EQUB 144               \ Object type 8: 3D text block 2       Points 144 to 151
 EQUB 152               \ Object type 9: 3D text block 3       Points 152 to 159
 EQUB 160

\ ******************************************************************************
\
\       Name: objPolygonRange
\       Type: Variable
\   Category: Drawing objects
\    Summary: The first and last polygon numbers for each object
\
\ ******************************************************************************

.objPolygonRange

 EQUB 0                 \ Object type 0: Robot               Polygons   0 to  26
 EQUB 27                \ Object type 1: Sentry              Polygons  27 to  51
 EQUB 52                \ Object type 2: Tree                Polygons  52 to  66
 EQUB 67                \ Object type 3: Boulder             Polygons  67 to  76
 EQUB 77                \ Object type 4: Meanie              Polygons  77 to 101
 EQUB 102               \ Object type 5: The Sentinel        Polygons 102 to 136
 EQUB 137               \ Object type 6: Sentinel's tower    Polygons 137 to 147
 EQUB 148               \ Object type 7: 3D text block 1     Polygons 148 to 151
 EQUB 152               \ Object type 8: 3D text block 2     Polygons 152 to 155
 EQUB 156               \ Object type 9: 3D text block 3     Polygons 156 to 159
 EQUB 160

\ ******************************************************************************
\
\       Name: objPolygonPhases
\       Type: Variable
\   Category: Drawing objects
\    Summary: The phase configuration for each object
\
\ ------------------------------------------------------------------------------
\
\ Most objects are drawn in one phase, but some are drawn in two phases. This
\ can depend on the relative altitude of the object compared to the viewer (for
\ the robot, the sentry or the Sentinel), or it can depend on the object's gaze
\ direction as given in the object's yaw angle (for the meanie).
\
\ See the DrawObject routine for details.
\
\ ******************************************************************************

.objPolygonPhases

 EQUB %11               \ Object type 0: Robot               Depends on altitude
 EQUB %11               \ Object type 1: Sentry              Depends on altitude
 EQUB %00               \ Object type 2: Tree                          One phase
 EQUB %00               \ Object type 3: Boulder                       One phase
 EQUB %10               \ Object type 4: Meanie                   Depends on yaw
 EQUB %11               \ Object type 5: The Sentinel        Depends on altitude
 EQUB %00               \ Object type 6: Sentinel's tower              One phase
 EQUB %00               \ Object type 7: 3D text block 1               One phase
 EQUB %00               \ Object type 8: 3D text block 2               One phase
 EQUB %00               \ Object type 9: 3D text block 3               One phase

 EQUB &00               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: sightsByteAddrLo
\       Type: Variable
\   Category: Sights
\    Summary: The screen addresses of the bytes in the sights pixel byte stash,
\             to which they can be restored to remove the sights (low byte)
\
\ ******************************************************************************

.sightsByteAddrLo

 EQUB &00, &00, &00, &00, &00, &FF, &FF, &FF        \ These values are workspace
 EQUB &FF, &FF, &FF, &FF                            \ noise and have no meaning

\ ******************************************************************************
\
\       Name: objMeanie
\       Type: Variable
\   Category: Drawing objects
\    Summary: The list of polygons and points for the meanie object (polygons
\             77 to 101, using points 76 to 93)
\
\ ******************************************************************************

.objMeanie

.objPolygon077

 EQUB 64 + 7	\ Polygon 77 points: 83, 88, 87, 82, 83
 EQUB 64 + 12
 EQUB 64 + 11
 EQUB 64 + 6
 EQUB 64 + 7

.objPolygon078

 EQUB 64 + 0	\ Polygon 78 points: 76, 81, 78, 76
 EQUB 64 + 5
 EQUB 64 + 2
 EQUB 64 + 0

.objPolygon079

 EQUB 64 + 1	\ Polygon 79 points: 77, 80, 76, 77
 EQUB 64 + 4
 EQUB 64 + 0
 EQUB 64 + 1

.objPolygon080

 EQUB 64 + 0	\ Polygon 80 points: 76, 80, 79, 76
 EQUB 64 + 4
 EQUB 64 + 3
 EQUB 64 + 0

.objPolygon081

 EQUB 64 + 0	\ Polygon 81 points: 76, 79, 81, 76
 EQUB 64 + 3
 EQUB 64 + 5
 EQUB 64 + 0

.objPolygon082

 EQUB 64 + 2	\ Polygon 82 points: 78, 81, 80, 77, 78
 EQUB 64 + 5
 EQUB 64 + 4
 EQUB 64 + 1
 EQUB 64 + 2

.objPolygon083

 EQUB 64 + 5	\ Polygon 83 points: 81, 82, 85, 81
 EQUB 64 + 6
 EQUB 64 + 9
 EQUB 64 + 5

.objPolygon084

 EQUB 64 + 4	\ Polygon 84 points: 80, 84, 83, 80
 EQUB 64 + 8
 EQUB 64 + 7
 EQUB 64 + 4

.objPolygon085

 EQUB 64 + 5	\ Polygon 85 points: 81, 85, 84, 80, 81
 EQUB 64 + 9
 EQUB 64 + 8
 EQUB 64 + 4
 EQUB 64 + 5

.objPolygon086

 EQUB 64 + 3	\ Polygon 86 points: 79, 82, 81, 79
 EQUB 64 + 6
 EQUB 64 + 5
 EQUB 64 + 3

.objPolygon087

 EQUB 64 + 4	\ Polygon 87 points: 80, 83, 79, 80
 EQUB 64 + 7
 EQUB 64 + 3
 EQUB 64 + 4

.objPolygon088

 EQUB 64 + 3	\ Polygon 88 points: 79, 83, 82, 79
 EQUB 64 + 7
 EQUB 64 + 6
 EQUB 64 + 3

.objPolygon089

 EQUB 64 + 11	\ Polygon 89 points: 87, 86, 82, 87
 EQUB 64 + 10
 EQUB 64 + 6
 EQUB 64 + 11

.objPolygon090

 EQUB 64 + 7	\ Polygon 90 points: 83, 89, 88, 83
 EQUB 64 + 13
 EQUB 64 + 12
 EQUB 64 + 7

.objPolygon091

 EQUB 64 + 11	\ Polygon 91 points: 87, 90, 86, 87
 EQUB 64 + 14
 EQUB 64 + 10
 EQUB 64 + 11

.objPolygon092

 EQUB 64 + 12	\ Polygon 92 points: 88, 89, 91, 88
 EQUB 64 + 13
 EQUB 64 + 15
 EQUB 64 + 12

.objPolygon093

 EQUB 64 + 12	\ Polygon 93 points: 88, 91, 90, 87, 88
 EQUB 64 + 15
 EQUB 64 + 14
 EQUB 64 + 11
 EQUB 64 + 12

.objPolygon094

 EQUB 64 + 6	\ Polygon 94 points: 82, 86, 85, 82
 EQUB 64 + 10
 EQUB 64 + 9
 EQUB 64 + 6

.objPolygon095

 EQUB 64 + 7	\ Polygon 95 points: 83, 84, 89, 83
 EQUB 64 + 8
 EQUB 64 + 13
 EQUB 64 + 7

.objPolygon096

 EQUB 64 + 10	\ Polygon 96 points: 86, 92, 85, 86
 EQUB 64 + 16
 EQUB 64 + 9
 EQUB 64 + 10

.objPolygon097

 EQUB 64 + 8	\ Polygon 97 points: 84, 93, 89, 84
 EQUB 64 + 17
 EQUB 64 + 13
 EQUB 64 + 8

.objPolygon098

 EQUB 64 + 10	\ Polygon 98 points: 86, 90, 92, 86
 EQUB 64 + 14
 EQUB 64 + 16
 EQUB 64 + 10

.objPolygon099

 EQUB 64 + 13	\ Polygon 99 points: 89, 93, 91, 89
 EQUB 64 + 17
 EQUB 64 + 15
 EQUB 64 + 13

.objPolygon100

 EQUB 64 + 9	\ Polygon 100 points: 85, 92, 93, 84, 85
 EQUB 64 + 16
 EQUB 64 + 17
 EQUB 64 + 8
 EQUB 64 + 9

.objPolygon101

 EQUB 64 + 15	\ Polygon 101 points: 91, 93, 92, 90, 91
 EQUB 64 + 17
 EQUB 64 + 16
 EQUB 64 + 14
 EQUB 64 + 15

\ ******************************************************************************
\
\       Name: objRotationSpeed
\       Type: Variable
\   Category: 3D objects
\    Summary: The angle through which each object rotates on each scheduled
\             rotation
\
\ ******************************************************************************

.objRotationSpeed

 EQUB &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00

\ ******************************************************************************
\
\       Name: screenBufferRow9
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 9
\
\ ******************************************************************************

.screenBufferRow9

 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF        \ These values are workspace
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ noise and have no meaning
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &10
 EQUB &FE, &FE, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF

\ ******************************************************************************
\
\       Name: objPointYaw
\       Type: Variable
\   Category: Drawing objects
\    Summary: Polar yaw angles for each of the points in each of the objects
\
\ ******************************************************************************

.objPointYaw

 EQUB 207               \ Point   0: yaw = 207, distance =  20, height = -112
 EQUB  49               \ Point   1: yaw =  49, distance =  20, height = -112
 EQUB  95               \ Point   2: yaw =  95, distance =  27, height = -112
 EQUB 161               \ Point   3: yaw = 161, distance =  27, height = -112
 EQUB 217               \ Point   4: yaw = 217, distance =  31, height =  -56
 EQUB  39               \ Point   5: yaw =  39, distance =  31, height =  -56
 EQUB  87               \ Point   6: yaw =  87, distance =  35, height =  -56
 EQUB 169               \ Point   7: yaw = 169, distance =  35, height =  -56
 EQUB 203               \ Point   8: yaw = 203, distance =  42, height =  -56
 EQUB   0               \ Point   9: yaw =   0, distance =  32, height =  -56
 EQUB  53               \ Point  10: yaw =  53, distance =  42, height =  -56
 EQUB  85               \ Point  11: yaw =  85, distance =  48, height =  -56
 EQUB 171               \ Point  12: yaw = 171, distance =  48, height =  -56
 EQUB 197               \ Point  13: yaw = 197, distance =  52, height =  -18
 EQUB  59               \ Point  14: yaw =  59, distance =  52, height =  -18
 EQUB  82               \ Point  15: yaw =  82, distance =  56, height =  -18
 EQUB 174               \ Point  16: yaw = 174, distance =  56, height =  -18
 EQUB   0               \ Point  17: yaw =   0, distance =   0, height =  -10
 EQUB 236               \ Point  18: yaw = 236, distance =  19, height =  -11
 EQUB  20               \ Point  19: yaw =  20, distance =  19, height =  -11
 EQUB  99               \ Point  20: yaw =  99, distance =  29, height =  -11
 EQUB 157               \ Point  21: yaw = 157, distance =  29, height =  -11
 EQUB 192               \ Point  22: yaw = 192, distance =  12, height =   +8
 EQUB  64               \ Point  23: yaw =  64, distance =  12, height =   +8
 EQUB 105               \ Point  24: yaw = 105, distance =  19, height =   +8
 EQUB 151               \ Point  25: yaw = 151, distance =  19, height =   +8
 EQUB  33               \ Point  26: yaw =  33, distance =  28, height =   -3
 EQUB 223               \ Point  27: yaw = 223, distance =  28, height =   -3
 EQUB   0               \ Point  28: yaw =   0, distance =  32, height =  -21
 EQUB 218               \ Point  29: yaw = 218, distance =  42, height = -112
 EQUB  38               \ Point  30: yaw =  38, distance =  42, height = -112
 EQUB  90               \ Point  31: yaw =  90, distance =  42, height = -112
 EQUB 166               \ Point  32: yaw = 166, distance =  42, height = -112
 EQUB 245               \ Point  33: yaw = 245, distance =  50, height =  -24
 EQUB  11               \ Point  34: yaw =  11, distance =  50, height =  -24
 EQUB  64               \ Point  35: yaw =  64, distance =  54, height =  -27
 EQUB  90               \ Point  36: yaw =  90, distance =  42, height =  -27
 EQUB 166               \ Point  37: yaw = 166, distance =  42, height =  -27
 EQUB 192               \ Point  38: yaw = 192, distance =  54, height =  -27
 EQUB 218               \ Point  39: yaw = 218, distance =  34, height =   -8
 EQUB  38               \ Point  40: yaw =  38, distance =  34, height =   -8
 EQUB  90               \ Point  41: yaw =  90, distance =  34, height =   -8
 EQUB 166               \ Point  42: yaw = 166, distance =  34, height =   -8
 EQUB 245               \ Point  43: yaw = 245, distance =  64, height =   -8
 EQUB  11               \ Point  44: yaw =  11, distance =  64, height =   -8
 EQUB 248               \ Point  45: yaw = 248, distance =  63, height =   +1
 EQUB   8               \ Point  46: yaw =   8, distance =  63, height =   +1
 EQUB 226               \ Point  47: yaw = 226, distance =  34, height =   +8
 EQUB  30               \ Point  48: yaw =  30, distance =  34, height =   +8
 EQUB  92               \ Point  49: yaw =  92, distance =  31, height =   +5
 EQUB 164               \ Point  50: yaw = 164, distance =  31, height =   +5
 EQUB 224               \ Point  51: yaw = 224, distance =  24, height = -112
 EQUB  32               \ Point  52: yaw =  32, distance =  24, height = -112
 EQUB  96               \ Point  53: yaw =  96, distance =  24, height = -112
 EQUB 160               \ Point  54: yaw = 160, distance =  24, height = -112
 EQUB 224               \ Point  55: yaw = 224, distance =  24, height =  -72
 EQUB  32               \ Point  56: yaw =  32, distance =  24, height =  -72
 EQUB  96               \ Point  57: yaw =  96, distance =  24, height =  -72
 EQUB 160               \ Point  58: yaw = 160, distance =  24, height =  -72
 EQUB   0               \ Point  59: yaw =   0, distance = 104, height =  -72
 EQUB  32               \ Point  60: yaw =  32, distance = 104, height =  -72
 EQUB  64               \ Point  61: yaw =  64, distance = 104, height =  -72
 EQUB  96               \ Point  62: yaw =  96, distance = 104, height =  -72
 EQUB 128               \ Point  63: yaw = 128, distance = 104, height =  -72
 EQUB 160               \ Point  64: yaw = 160, distance = 104, height =  -72
 EQUB 192               \ Point  65: yaw = 192, distance = 104, height =  -72
 EQUB 224               \ Point  66: yaw = 224, distance = 104, height =  -72
 EQUB   0               \ Point  67: yaw =   0, distance =   0, height = +120
 EQUB   0               \ Point  68: yaw =   0, distance = 112, height =  -48
 EQUB  32               \ Point  69: yaw =  32, distance = 112, height = -112
 EQUB  64               \ Point  70: yaw =  64, distance = 112, height =  -48
 EQUB  96               \ Point  71: yaw =  96, distance = 112, height = -112
 EQUB 128               \ Point  72: yaw = 128, distance = 112, height =  -48
 EQUB 160               \ Point  73: yaw = 160, distance = 112, height = -112
 EQUB 192               \ Point  74: yaw = 192, distance = 112, height =  -48
 EQUB 224               \ Point  75: yaw = 224, distance = 112, height = -112
 EQUB   0               \ Point  76: yaw =   0, distance =  52, height = -112
 EQUB  89               \ Point  77: yaw =  89, distance =  68, height = -112
 EQUB 167               \ Point  78: yaw = 167, distance =  68, height = -112
 EQUB 128               \ Point  79: yaw = 128, distance =  26, height =  -60
 EQUB 114               \ Point  80: yaw = 114, distance =  41, height =  -60
 EQUB 142               \ Point  81: yaw = 142, distance =  41, height =  -60
 EQUB 225               \ Point  82: yaw = 225, distance =  12, height =  -10
 EQUB  31               \ Point  83: yaw =  31, distance =  12, height =  -10
 EQUB  89               \ Point  84: yaw =  89, distance =  23, height =   +1
 EQUB 167               \ Point  85: yaw = 167, distance =  23, height =   +1
 EQUB 213               \ Point  86: yaw = 213, distance =  46, height =   -8
 EQUB 246               \ Point  87: yaw = 246, distance =  54, height =  -14
 EQUB  10               \ Point  88: yaw =  10, distance =  54, height =  -14
 EQUB  43               \ Point  89: yaw =  43, distance =  46, height =   -8
 EQUB 251               \ Point  90: yaw = 251, distance =  58, height =   -5
 EQUB   5               \ Point  91: yaw =   5, distance =  58, height =   -5
 EQUB 233               \ Point  92: yaw = 233, distance =  34, height =   +6
 EQUB  23               \ Point  93: yaw =  23, distance =  34, height =   +6
 EQUB 218               \ Point  94: yaw = 218, distance =  56, height = -112
 EQUB  38               \ Point  95: yaw =  38, distance =  56, height = -112
 EQUB  90               \ Point  96: yaw =  90, distance =  56, height = -112
 EQUB 166               \ Point  97: yaw = 166, distance =  56, height = -112
 EQUB 218               \ Point  98: yaw = 218, distance =  42, height =  -96
 EQUB  38               \ Point  99: yaw =  38, distance =  42, height =  -96
 EQUB  90               \ Point 100: yaw =  90, distance =  42, height =  -96
 EQUB 166               \ Point 101: yaw = 166, distance =  42, height =  -96
 EQUB 245               \ Point 102: yaw = 245, distance =  50, height =   -8
 EQUB  11               \ Point 103: yaw =  11, distance =  50, height =   -8
 EQUB  64               \ Point 104: yaw =  64, distance =  54, height =  -11
 EQUB  90               \ Point 105: yaw =  90, distance =  42, height =  -11
 EQUB 166               \ Point 106: yaw = 166, distance =  42, height =  -11
 EQUB 192               \ Point 107: yaw = 192, distance =  54, height =  -11
 EQUB 218               \ Point 108: yaw = 218, distance =  34, height =   +8
 EQUB  38               \ Point 109: yaw =  38, distance =  34, height =   +8
 EQUB  90               \ Point 110: yaw =  90, distance =  34, height =   +5
 EQUB 166               \ Point 111: yaw = 166, distance =  34, height =   +5
 EQUB 245               \ Point 112: yaw = 245, distance =  64, height =   +8
 EQUB  11               \ Point 113: yaw =  11, distance =  64, height =   +8
 EQUB  83               \ Point 114: yaw =  83, distance =  70, height =   +2
 EQUB 173               \ Point 115: yaw = 173, distance =  70, height =   +2
 EQUB 248               \ Point 116: yaw = 248, distance =  63, height =  +17
 EQUB   8               \ Point 117: yaw =   8, distance =  63, height =  +17
 EQUB 226               \ Point 118: yaw = 226, distance =  34, height =  +24
 EQUB  30               \ Point 119: yaw =  30, distance =  34, height =  +24
 EQUB 220               \ Point 120: yaw = 220, distance =  19, height =  +39
 EQUB  36               \ Point 121: yaw =  36, distance =  19, height =  +39
 EQUB 102               \ Point 122: yaw = 102, distance =  24, height =  +39
 EQUB 154               \ Point 123: yaw = 154, distance =  24, height =  +39
 EQUB 224               \ Point 124: yaw = 224, distance = 181, height = -112
 EQUB  32               \ Point 125: yaw =  32, distance = 181, height = -112
 EQUB  96               \ Point 126: yaw =  96, distance = 181, height = -112
 EQUB 160               \ Point 127: yaw = 160, distance = 181, height = -112
 EQUB 212               \ Point 128: yaw = 212, distance = 145, height =  +16
 EQUB 236               \ Point 129: yaw = 236, distance = 145, height =  +16
 EQUB  20               \ Point 130: yaw =  20, distance = 145, height =  +16
 EQUB  44               \ Point 131: yaw =  44, distance = 145, height =  +16
 EQUB  84               \ Point 132: yaw =  84, distance = 145, height =  +16
 EQUB 108               \ Point 133: yaw = 108, distance = 145, height =  +16
 EQUB 148               \ Point 134: yaw = 148, distance = 145, height =  +16
 EQUB 172               \ Point 135: yaw = 172, distance = 145, height =  +16
 EQUB 224               \ Point 136: yaw = 224, distance = 192, height = -112
 EQUB 253               \ Point 137: yaw = 253, distance = 136, height = -112
 EQUB 131               \ Point 138: yaw = 131, distance = 136, height = -112
 EQUB 160               \ Point 139: yaw = 160, distance = 192, height = -112
 EQUB 224               \ Point 140: yaw = 224, distance = 192, height = +112
 EQUB 253               \ Point 141: yaw = 253, distance = 136, height = +112
 EQUB 131               \ Point 142: yaw = 131, distance = 136, height = +112
 EQUB 160               \ Point 143: yaw = 160, distance = 192, height = +112
 EQUB   3               \ Point 144: yaw =   3, distance = 136, height = -112
 EQUB  32               \ Point 145: yaw =  32, distance = 192, height = -112
 EQUB  96               \ Point 146: yaw =  96, distance = 192, height = -112
 EQUB 125               \ Point 147: yaw = 125, distance = 136, height = -112
 EQUB   3               \ Point 148: yaw =   3, distance = 136, height = +112
 EQUB  32               \ Point 149: yaw =  32, distance = 192, height = +112
 EQUB  96               \ Point 150: yaw =  96, distance = 192, height = +112
 EQUB 125               \ Point 151: yaw = 125, distance = 136, height = +112
 EQUB 224               \ Point 152: yaw = 224, distance = 192, height = -112
 EQUB  32               \ Point 153: yaw =  32, distance = 192, height = -112
 EQUB  96               \ Point 154: yaw =  96, distance = 192, height = -112
 EQUB 160               \ Point 155: yaw = 160, distance = 192, height = -112
 EQUB 224               \ Point 156: yaw = 224, distance = 192, height = +112
 EQUB  32               \ Point 157: yaw =  32, distance = 192, height = +112
 EQUB  96               \ Point 158: yaw =  96, distance = 192, height = +112
 EQUB 160               \ Point 159: yaw = 160, distance = 192, height = +112

\ ******************************************************************************
\
\       Name: screenBufferRow10
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 10
\
\ ******************************************************************************

.screenBufferRow10

 EQUB &FE, &FE, &FF, &FF, &FF, &FF, &FF, &FF        \ These values are workspace
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ noise and have no meaning
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &10
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF

\ ******************************************************************************
\
\       Name: objPointHeight
\       Type: Variable
\   Category: Drawing objects
\    Summary: The height of each of the points in each of the objects, relative
\             to the object's origin
\
\ ------------------------------------------------------------------------------
\
\ The height is stored as follows:
\
\   * Bit 7 contains the sign bit
\
\   * Bits 0 to 6 contain half the magnitude of the height
\
\ ******************************************************************************

.objPointHeight

 EQUB 240               \ Point   0: yaw = 207, distance =  20, height = -112
 EQUB 240               \ Point   1: yaw =  49, distance =  20, height = -112
 EQUB 240               \ Point   2: yaw =  95, distance =  27, height = -112
 EQUB 240               \ Point   3: yaw = 161, distance =  27, height = -112
 EQUB 184               \ Point   4: yaw = 217, distance =  31, height =  -56
 EQUB 184               \ Point   5: yaw =  39, distance =  31, height =  -56
 EQUB 184               \ Point   6: yaw =  87, distance =  35, height =  -56
 EQUB 184               \ Point   7: yaw = 169, distance =  35, height =  -56
 EQUB 184               \ Point   8: yaw = 203, distance =  42, height =  -56
 EQUB 184               \ Point   9: yaw =   0, distance =  32, height =  -56
 EQUB 184               \ Point  10: yaw =  53, distance =  42, height =  -56
 EQUB 184               \ Point  11: yaw =  85, distance =  48, height =  -56
 EQUB 184               \ Point  12: yaw = 171, distance =  48, height =  -56
 EQUB 146               \ Point  13: yaw = 197, distance =  52, height =  -18
 EQUB 146               \ Point  14: yaw =  59, distance =  52, height =  -18
 EQUB 146               \ Point  15: yaw =  82, distance =  56, height =  -18
 EQUB 146               \ Point  16: yaw = 174, distance =  56, height =  -18
 EQUB 138               \ Point  17: yaw =   0, distance =   0, height =  -10
 EQUB 139               \ Point  18: yaw = 236, distance =  19, height =  -11
 EQUB 139               \ Point  19: yaw =  20, distance =  19, height =  -11
 EQUB 139               \ Point  20: yaw =  99, distance =  29, height =  -11
 EQUB 139               \ Point  21: yaw = 157, distance =  29, height =  -11
 EQUB   8               \ Point  22: yaw = 192, distance =  12, height =   +8
 EQUB   8               \ Point  23: yaw =  64, distance =  12, height =   +8
 EQUB   8               \ Point  24: yaw = 105, distance =  19, height =   +8
 EQUB   8               \ Point  25: yaw = 151, distance =  19, height =   +8
 EQUB 131               \ Point  26: yaw =  33, distance =  28, height =   -3
 EQUB 131               \ Point  27: yaw = 223, distance =  28, height =   -3
 EQUB 149               \ Point  28: yaw =   0, distance =  32, height =  -21
 EQUB 240               \ Point  29: yaw = 218, distance =  42, height = -112
 EQUB 240               \ Point  30: yaw =  38, distance =  42, height = -112
 EQUB 240               \ Point  31: yaw =  90, distance =  42, height = -112
 EQUB 240               \ Point  32: yaw = 166, distance =  42, height = -112
 EQUB 152               \ Point  33: yaw = 245, distance =  50, height =  -24
 EQUB 152               \ Point  34: yaw =  11, distance =  50, height =  -24
 EQUB 155               \ Point  35: yaw =  64, distance =  54, height =  -27
 EQUB 155               \ Point  36: yaw =  90, distance =  42, height =  -27
 EQUB 155               \ Point  37: yaw = 166, distance =  42, height =  -27
 EQUB 155               \ Point  38: yaw = 192, distance =  54, height =  -27
 EQUB 136               \ Point  39: yaw = 218, distance =  34, height =   -8
 EQUB 136               \ Point  40: yaw =  38, distance =  34, height =   -8
 EQUB 136               \ Point  41: yaw =  90, distance =  34, height =   -8
 EQUB 136               \ Point  42: yaw = 166, distance =  34, height =   -8
 EQUB 136               \ Point  43: yaw = 245, distance =  64, height =   -8
 EQUB 136               \ Point  44: yaw =  11, distance =  64, height =   -8
 EQUB   1               \ Point  45: yaw = 248, distance =  63, height =   +1
 EQUB   1               \ Point  46: yaw =   8, distance =  63, height =   +1
 EQUB   8               \ Point  47: yaw = 226, distance =  34, height =   +8
 EQUB   8               \ Point  48: yaw =  30, distance =  34, height =   +8
 EQUB   5               \ Point  49: yaw =  92, distance =  31, height =   +5
 EQUB   5               \ Point  50: yaw = 164, distance =  31, height =   +5
 EQUB 240               \ Point  51: yaw = 224, distance =  24, height = -112
 EQUB 240               \ Point  52: yaw =  32, distance =  24, height = -112
 EQUB 240               \ Point  53: yaw =  96, distance =  24, height = -112
 EQUB 240               \ Point  54: yaw = 160, distance =  24, height = -112
 EQUB 200               \ Point  55: yaw = 224, distance =  24, height =  -72
 EQUB 200               \ Point  56: yaw =  32, distance =  24, height =  -72
 EQUB 200               \ Point  57: yaw =  96, distance =  24, height =  -72
 EQUB 200               \ Point  58: yaw = 160, distance =  24, height =  -72
 EQUB 200               \ Point  59: yaw =   0, distance = 104, height =  -72
 EQUB 200               \ Point  60: yaw =  32, distance = 104, height =  -72
 EQUB 200               \ Point  61: yaw =  64, distance = 104, height =  -72
 EQUB 200               \ Point  62: yaw =  96, distance = 104, height =  -72
 EQUB 200               \ Point  63: yaw = 128, distance = 104, height =  -72
 EQUB 200               \ Point  64: yaw = 160, distance = 104, height =  -72
 EQUB 200               \ Point  65: yaw = 192, distance = 104, height =  -72
 EQUB 200               \ Point  66: yaw = 224, distance = 104, height =  -72
 EQUB 120               \ Point  67: yaw =   0, distance =   0, height = +120
 EQUB 176               \ Point  68: yaw =   0, distance = 112, height =  -48
 EQUB 240               \ Point  69: yaw =  32, distance = 112, height = -112
 EQUB 176               \ Point  70: yaw =  64, distance = 112, height =  -48
 EQUB 240               \ Point  71: yaw =  96, distance = 112, height = -112
 EQUB 176               \ Point  72: yaw = 128, distance = 112, height =  -48
 EQUB 240               \ Point  73: yaw = 160, distance = 112, height = -112
 EQUB 176               \ Point  74: yaw = 192, distance = 112, height =  -48
 EQUB 240               \ Point  75: yaw = 224, distance = 112, height = -112
 EQUB 240               \ Point  76: yaw =   0, distance =  52, height = -112
 EQUB 240               \ Point  77: yaw =  89, distance =  68, height = -112
 EQUB 240               \ Point  78: yaw = 167, distance =  68, height = -112
 EQUB 188               \ Point  79: yaw = 128, distance =  26, height =  -60
 EQUB 188               \ Point  80: yaw = 114, distance =  41, height =  -60
 EQUB 188               \ Point  81: yaw = 142, distance =  41, height =  -60
 EQUB 138               \ Point  82: yaw = 225, distance =  12, height =  -10
 EQUB 138               \ Point  83: yaw =  31, distance =  12, height =  -10
 EQUB   1               \ Point  84: yaw =  89, distance =  23, height =   +1
 EQUB   1               \ Point  85: yaw = 167, distance =  23, height =   +1
 EQUB 136               \ Point  86: yaw = 213, distance =  46, height =   -8
 EQUB 142               \ Point  87: yaw = 246, distance =  54, height =  -14
 EQUB 142               \ Point  88: yaw =  10, distance =  54, height =  -14
 EQUB 136               \ Point  89: yaw =  43, distance =  46, height =   -8
 EQUB 133               \ Point  90: yaw = 251, distance =  58, height =   -5
 EQUB 133               \ Point  91: yaw =   5, distance =  58, height =   -5
 EQUB   6               \ Point  92: yaw = 233, distance =  34, height =   +6
 EQUB   6               \ Point  93: yaw =  23, distance =  34, height =   +6
 EQUB 240               \ Point  94: yaw = 218, distance =  56, height = -112
 EQUB 240               \ Point  95: yaw =  38, distance =  56, height = -112
 EQUB 240               \ Point  96: yaw =  90, distance =  56, height = -112
 EQUB 240               \ Point  97: yaw = 166, distance =  56, height = -112
 EQUB 224               \ Point  98: yaw = 218, distance =  42, height =  -96
 EQUB 224               \ Point  99: yaw =  38, distance =  42, height =  -96
 EQUB 224               \ Point 100: yaw =  90, distance =  42, height =  -96
 EQUB 224               \ Point 101: yaw = 166, distance =  42, height =  -96
 EQUB 136               \ Point 102: yaw = 245, distance =  50, height =   -8
 EQUB 136               \ Point 103: yaw =  11, distance =  50, height =   -8
 EQUB 139               \ Point 104: yaw =  64, distance =  54, height =  -11
 EQUB 139               \ Point 105: yaw =  90, distance =  42, height =  -11
 EQUB 139               \ Point 106: yaw = 166, distance =  42, height =  -11
 EQUB 139               \ Point 107: yaw = 192, distance =  54, height =  -11
 EQUB   8               \ Point 108: yaw = 218, distance =  34, height =   +8
 EQUB   8               \ Point 109: yaw =  38, distance =  34, height =   +8
 EQUB   5               \ Point 110: yaw =  90, distance =  34, height =   +5
 EQUB   5               \ Point 111: yaw = 166, distance =  34, height =   +5
 EQUB   8               \ Point 112: yaw = 245, distance =  64, height =   +8
 EQUB   8               \ Point 113: yaw =  11, distance =  64, height =   +8
 EQUB   2               \ Point 114: yaw =  83, distance =  70, height =   +2
 EQUB   2               \ Point 115: yaw = 173, distance =  70, height =   +2
 EQUB  17               \ Point 116: yaw = 248, distance =  63, height =  +17
 EQUB  17               \ Point 117: yaw =   8, distance =  63, height =  +17
 EQUB  24               \ Point 118: yaw = 226, distance =  34, height =  +24
 EQUB  24               \ Point 119: yaw =  30, distance =  34, height =  +24
 EQUB  39               \ Point 120: yaw = 220, distance =  19, height =  +39
 EQUB  39               \ Point 121: yaw =  36, distance =  19, height =  +39
 EQUB  39               \ Point 122: yaw = 102, distance =  24, height =  +39
 EQUB  39               \ Point 123: yaw = 154, distance =  24, height =  +39
 EQUB 240               \ Point 124: yaw = 224, distance = 181, height = -112
 EQUB 240               \ Point 125: yaw =  32, distance = 181, height = -112
 EQUB 240               \ Point 126: yaw =  96, distance = 181, height = -112
 EQUB 240               \ Point 127: yaw = 160, distance = 181, height = -112
 EQUB  16               \ Point 128: yaw = 212, distance = 145, height =  +16
 EQUB  16               \ Point 129: yaw = 236, distance = 145, height =  +16
 EQUB  16               \ Point 130: yaw =  20, distance = 145, height =  +16
 EQUB  16               \ Point 131: yaw =  44, distance = 145, height =  +16
 EQUB  16               \ Point 132: yaw =  84, distance = 145, height =  +16
 EQUB  16               \ Point 133: yaw = 108, distance = 145, height =  +16
 EQUB  16               \ Point 134: yaw = 148, distance = 145, height =  +16
 EQUB  16               \ Point 135: yaw = 172, distance = 145, height =  +16
 EQUB 240               \ Point 136: yaw = 224, distance = 192, height = -112
 EQUB 240               \ Point 137: yaw = 253, distance = 136, height = -112
 EQUB 240               \ Point 138: yaw = 131, distance = 136, height = -112
 EQUB 240               \ Point 139: yaw = 160, distance = 192, height = -112
 EQUB 112               \ Point 140: yaw = 224, distance = 192, height = +112
 EQUB 112               \ Point 141: yaw = 253, distance = 136, height = +112
 EQUB 112               \ Point 142: yaw = 131, distance = 136, height = +112
 EQUB 112               \ Point 143: yaw = 160, distance = 192, height = +112
 EQUB 240               \ Point 144: yaw =   3, distance = 136, height = -112
 EQUB 240               \ Point 145: yaw =  32, distance = 192, height = -112
 EQUB 240               \ Point 146: yaw =  96, distance = 192, height = -112
 EQUB 240               \ Point 147: yaw = 125, distance = 136, height = -112
 EQUB 112               \ Point 148: yaw =   3, distance = 136, height = +112
 EQUB 112               \ Point 149: yaw =  32, distance = 192, height = +112
 EQUB 112               \ Point 150: yaw =  96, distance = 192, height = +112
 EQUB 112               \ Point 151: yaw = 125, distance = 136, height = +112
 EQUB 240               \ Point 152: yaw = 224, distance = 192, height = -112
 EQUB 240               \ Point 153: yaw =  32, distance = 192, height = -112
 EQUB 240               \ Point 154: yaw =  96, distance = 192, height = -112
 EQUB 240               \ Point 155: yaw = 160, distance = 192, height = -112
 EQUB 112               \ Point 156: yaw = 224, distance = 192, height = +112
 EQUB 112               \ Point 157: yaw =  32, distance = 192, height = +112
 EQUB 112               \ Point 158: yaw =  96, distance = 192, height = +112
 EQUB 112               \ Point 159: yaw = 160, distance = 192, height = +112

\ ******************************************************************************
\
\       Name: screenBufferRow11
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 11
\
\ ******************************************************************************

.screenBufferRow11

 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF        \ These values are workspace
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ noise and have no meaning
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &18
 EQUB &FE, &FE, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF

\ ******************************************************************************
\
\       Name: objPointDistance
\       Type: Variable
\   Category: Drawing objects
\    Summary: Polar distances for each of the points in each of the objects
\
\ ******************************************************************************

.objPointDistance

 EQUB  20               \ Point   0: yaw = 207, distance =  20, height = -112
 EQUB  20               \ Point   1: yaw =  49, distance =  20, height = -112
 EQUB  27               \ Point   2: yaw =  95, distance =  27, height = -112
 EQUB  27               \ Point   3: yaw = 161, distance =  27, height = -112
 EQUB  31               \ Point   4: yaw = 217, distance =  31, height =  -56
 EQUB  31               \ Point   5: yaw =  39, distance =  31, height =  -56
 EQUB  35               \ Point   6: yaw =  87, distance =  35, height =  -56
 EQUB  35               \ Point   7: yaw = 169, distance =  35, height =  -56
 EQUB  42               \ Point   8: yaw = 203, distance =  42, height =  -56
 EQUB  32               \ Point   9: yaw =   0, distance =  32, height =  -56
 EQUB  42               \ Point  10: yaw =  53, distance =  42, height =  -56
 EQUB  48               \ Point  11: yaw =  85, distance =  48, height =  -56
 EQUB  48               \ Point  12: yaw = 171, distance =  48, height =  -56
 EQUB  52               \ Point  13: yaw = 197, distance =  52, height =  -18
 EQUB  52               \ Point  14: yaw =  59, distance =  52, height =  -18
 EQUB  56               \ Point  15: yaw =  82, distance =  56, height =  -18
 EQUB  56               \ Point  16: yaw = 174, distance =  56, height =  -18
 EQUB   0               \ Point  17: yaw =   0, distance =   0, height =  -10
 EQUB  19               \ Point  18: yaw = 236, distance =  19, height =  -11
 EQUB  19               \ Point  19: yaw =  20, distance =  19, height =  -11
 EQUB  29               \ Point  20: yaw =  99, distance =  29, height =  -11
 EQUB  29               \ Point  21: yaw = 157, distance =  29, height =  -11
 EQUB  12               \ Point  22: yaw = 192, distance =  12, height =   +8
 EQUB  12               \ Point  23: yaw =  64, distance =  12, height =   +8
 EQUB  19               \ Point  24: yaw = 105, distance =  19, height =   +8
 EQUB  19               \ Point  25: yaw = 151, distance =  19, height =   +8
 EQUB  28               \ Point  26: yaw =  33, distance =  28, height =   -3
 EQUB  28               \ Point  27: yaw = 223, distance =  28, height =   -3
 EQUB  32               \ Point  28: yaw =   0, distance =  32, height =  -21
 EQUB  42               \ Point  29: yaw = 218, distance =  42, height = -112
 EQUB  42               \ Point  30: yaw =  38, distance =  42, height = -112
 EQUB  42               \ Point  31: yaw =  90, distance =  42, height = -112
 EQUB  42               \ Point  32: yaw = 166, distance =  42, height = -112
 EQUB  50               \ Point  33: yaw = 245, distance =  50, height =  -24
 EQUB  50               \ Point  34: yaw =  11, distance =  50, height =  -24
 EQUB  54               \ Point  35: yaw =  64, distance =  54, height =  -27
 EQUB  42               \ Point  36: yaw =  90, distance =  42, height =  -27
 EQUB  42               \ Point  37: yaw = 166, distance =  42, height =  -27
 EQUB  54               \ Point  38: yaw = 192, distance =  54, height =  -27
 EQUB  34               \ Point  39: yaw = 218, distance =  34, height =   -8
 EQUB  34               \ Point  40: yaw =  38, distance =  34, height =   -8
 EQUB  34               \ Point  41: yaw =  90, distance =  34, height =   -8
 EQUB  34               \ Point  42: yaw = 166, distance =  34, height =   -8
 EQUB  64               \ Point  43: yaw = 245, distance =  64, height =   -8
 EQUB  64               \ Point  44: yaw =  11, distance =  64, height =   -8
 EQUB  63               \ Point  45: yaw = 248, distance =  63, height =   +1
 EQUB  63               \ Point  46: yaw =   8, distance =  63, height =   +1
 EQUB  34               \ Point  47: yaw = 226, distance =  34, height =   +8
 EQUB  34               \ Point  48: yaw =  30, distance =  34, height =   +8
 EQUB  31               \ Point  49: yaw =  92, distance =  31, height =   +5
 EQUB  31               \ Point  50: yaw = 164, distance =  31, height =   +5
 EQUB  24               \ Point  51: yaw = 224, distance =  24, height = -112
 EQUB  24               \ Point  52: yaw =  32, distance =  24, height = -112
 EQUB  24               \ Point  53: yaw =  96, distance =  24, height = -112
 EQUB  24               \ Point  54: yaw = 160, distance =  24, height = -112
 EQUB  24               \ Point  55: yaw = 224, distance =  24, height =  -72
 EQUB  24               \ Point  56: yaw =  32, distance =  24, height =  -72
 EQUB  24               \ Point  57: yaw =  96, distance =  24, height =  -72
 EQUB  24               \ Point  58: yaw = 160, distance =  24, height =  -72
 EQUB 104               \ Point  59: yaw =   0, distance = 104, height =  -72
 EQUB 104               \ Point  60: yaw =  32, distance = 104, height =  -72
 EQUB 104               \ Point  61: yaw =  64, distance = 104, height =  -72
 EQUB 104               \ Point  62: yaw =  96, distance = 104, height =  -72
 EQUB 104               \ Point  63: yaw = 128, distance = 104, height =  -72
 EQUB 104               \ Point  64: yaw = 160, distance = 104, height =  -72
 EQUB 104               \ Point  65: yaw = 192, distance = 104, height =  -72
 EQUB 104               \ Point  66: yaw = 224, distance = 104, height =  -72
 EQUB   0               \ Point  67: yaw =   0, distance =   0, height = +120
 EQUB 112               \ Point  68: yaw =   0, distance = 112, height =  -48
 EQUB 112               \ Point  69: yaw =  32, distance = 112, height = -112
 EQUB 112               \ Point  70: yaw =  64, distance = 112, height =  -48
 EQUB 112               \ Point  71: yaw =  96, distance = 112, height = -112
 EQUB 112               \ Point  72: yaw = 128, distance = 112, height =  -48
 EQUB 112               \ Point  73: yaw = 160, distance = 112, height = -112
 EQUB 112               \ Point  74: yaw = 192, distance = 112, height =  -48
 EQUB 112               \ Point  75: yaw = 224, distance = 112, height = -112
 EQUB  52               \ Point  76: yaw =   0, distance =  52, height = -112
 EQUB  68               \ Point  77: yaw =  89, distance =  68, height = -112
 EQUB  68               \ Point  78: yaw = 167, distance =  68, height = -112
 EQUB  26               \ Point  79: yaw = 128, distance =  26, height =  -60
 EQUB  41               \ Point  80: yaw = 114, distance =  41, height =  -60
 EQUB  41               \ Point  81: yaw = 142, distance =  41, height =  -60
 EQUB  12               \ Point  82: yaw = 225, distance =  12, height =  -10
 EQUB  12               \ Point  83: yaw =  31, distance =  12, height =  -10
 EQUB  23               \ Point  84: yaw =  89, distance =  23, height =   +1
 EQUB  23               \ Point  85: yaw = 167, distance =  23, height =   +1
 EQUB  46               \ Point  86: yaw = 213, distance =  46, height =   -8
 EQUB  54               \ Point  87: yaw = 246, distance =  54, height =  -14
 EQUB  54               \ Point  88: yaw =  10, distance =  54, height =  -14
 EQUB  46               \ Point  89: yaw =  43, distance =  46, height =   -8
 EQUB  58               \ Point  90: yaw = 251, distance =  58, height =   -5
 EQUB  58               \ Point  91: yaw =   5, distance =  58, height =   -5
 EQUB  34               \ Point  92: yaw = 233, distance =  34, height =   +6
 EQUB  34               \ Point  93: yaw =  23, distance =  34, height =   +6
 EQUB  56               \ Point  94: yaw = 218, distance =  56, height = -112
 EQUB  56               \ Point  95: yaw =  38, distance =  56, height = -112
 EQUB  56               \ Point  96: yaw =  90, distance =  56, height = -112
 EQUB  56               \ Point  97: yaw = 166, distance =  56, height = -112
 EQUB  42               \ Point  98: yaw = 218, distance =  42, height =  -96
 EQUB  42               \ Point  99: yaw =  38, distance =  42, height =  -96
 EQUB  42               \ Point 100: yaw =  90, distance =  42, height =  -96
 EQUB  42               \ Point 101: yaw = 166, distance =  42, height =  -96
 EQUB  50               \ Point 102: yaw = 245, distance =  50, height =   -8
 EQUB  50               \ Point 103: yaw =  11, distance =  50, height =   -8
 EQUB  54               \ Point 104: yaw =  64, distance =  54, height =  -11
 EQUB  42               \ Point 105: yaw =  90, distance =  42, height =  -11
 EQUB  42               \ Point 106: yaw = 166, distance =  42, height =  -11
 EQUB  54               \ Point 107: yaw = 192, distance =  54, height =  -11
 EQUB  34               \ Point 108: yaw = 218, distance =  34, height =   +8
 EQUB  34               \ Point 109: yaw =  38, distance =  34, height =   +8
 EQUB  34               \ Point 110: yaw =  90, distance =  34, height =   +5
 EQUB  34               \ Point 111: yaw = 166, distance =  34, height =   +5
 EQUB  64               \ Point 112: yaw = 245, distance =  64, height =   +8
 EQUB  64               \ Point 113: yaw =  11, distance =  64, height =   +8
 EQUB  70               \ Point 114: yaw =  83, distance =  70, height =   +2
 EQUB  70               \ Point 115: yaw = 173, distance =  70, height =   +2
 EQUB  63               \ Point 116: yaw = 248, distance =  63, height =  +17
 EQUB  63               \ Point 117: yaw =   8, distance =  63, height =  +17
 EQUB  34               \ Point 118: yaw = 226, distance =  34, height =  +24
 EQUB  34               \ Point 119: yaw =  30, distance =  34, height =  +24
 EQUB  19               \ Point 120: yaw = 220, distance =  19, height =  +39
 EQUB  19               \ Point 121: yaw =  36, distance =  19, height =  +39
 EQUB  24               \ Point 122: yaw = 102, distance =  24, height =  +39
 EQUB  24               \ Point 123: yaw = 154, distance =  24, height =  +39
 EQUB 181               \ Point 124: yaw = 224, distance = 181, height = -112
 EQUB 181               \ Point 125: yaw =  32, distance = 181, height = -112
 EQUB 181               \ Point 126: yaw =  96, distance = 181, height = -112
 EQUB 181               \ Point 127: yaw = 160, distance = 181, height = -112
 EQUB 145               \ Point 128: yaw = 212, distance = 145, height =  +16
 EQUB 145               \ Point 129: yaw = 236, distance = 145, height =  +16
 EQUB 145               \ Point 130: yaw =  20, distance = 145, height =  +16
 EQUB 145               \ Point 131: yaw =  44, distance = 145, height =  +16
 EQUB 145               \ Point 132: yaw =  84, distance = 145, height =  +16
 EQUB 145               \ Point 133: yaw = 108, distance = 145, height =  +16
 EQUB 145               \ Point 134: yaw = 148, distance = 145, height =  +16
 EQUB 145               \ Point 135: yaw = 172, distance = 145, height =  +16
 EQUB 192               \ Point 136: yaw = 224, distance = 192, height = -112
 EQUB 136               \ Point 137: yaw = 253, distance = 136, height = -112
 EQUB 136               \ Point 138: yaw = 131, distance = 136, height = -112
 EQUB 192               \ Point 139: yaw = 160, distance = 192, height = -112
 EQUB 192               \ Point 140: yaw = 224, distance = 192, height = +112
 EQUB 136               \ Point 141: yaw = 253, distance = 136, height = +112
 EQUB 136               \ Point 142: yaw = 131, distance = 136, height = +112
 EQUB 192               \ Point 143: yaw = 160, distance = 192, height = +112
 EQUB 136               \ Point 144: yaw =   3, distance = 136, height = -112
 EQUB 192               \ Point 145: yaw =  32, distance = 192, height = -112
 EQUB 192               \ Point 146: yaw =  96, distance = 192, height = -112
 EQUB 136               \ Point 147: yaw = 125, distance = 136, height = -112
 EQUB 136               \ Point 148: yaw =   3, distance = 136, height = +112
 EQUB 192               \ Point 149: yaw =  32, distance = 192, height = +112
 EQUB 192               \ Point 150: yaw =  96, distance = 192, height = +112
 EQUB 136               \ Point 151: yaw = 125, distance = 136, height = +112
 EQUB 192               \ Point 152: yaw = 224, distance = 192, height = -112
 EQUB 192               \ Point 153: yaw =  32, distance = 192, height = -112
 EQUB 192               \ Point 154: yaw =  96, distance = 192, height = -112
 EQUB 192               \ Point 155: yaw = 160, distance = 192, height = -112
 EQUB 192               \ Point 156: yaw = 224, distance = 192, height = +112
 EQUB 192               \ Point 157: yaw =  32, distance = 192, height = +112
 EQUB 192               \ Point 158: yaw =  96, distance = 192, height = +112
 EQUB 192               \ Point 159: yaw = 160, distance = 192, height = +112

\ ******************************************************************************
\
\       Name: screenBufferRow12
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 12
\
\ ******************************************************************************

.screenBufferRow12

 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ These values are workspace
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ noise and have no meaning
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FE, &FE, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF

\ ******************************************************************************
\
\       Name: objPolygonData
\       Type: Variable
\   Category: Drawing object
\    Summary: Various data for object polygons (colour, drawing phase)
\
\ ------------------------------------------------------------------------------
\
\ Polygon data is stored as follows:
\
\   * Bit 7 is the phase in which to draw this polygon (0 = first phase,
\     1 = second phase)
\
\   * Bit 6 is unused and is always clear
\
\   * Bits 4-5 contain the edge colour (0 to 3)
\
\   * Bits 2-3 contain the fill colour (0 to 3)
\
\   * Bits 0-1 give the number of sides (0 = three sides, 1 = four sides)
\
\ The individual object tables (such as objTree and objSentinel) list the points
\ that are used to draw each polygon.
\
\ ******************************************************************************

.objPolygonData

 EQUB %00010101         \ Polygon 0 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010100         \ Polygon 1 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010101         \ Polygon 2 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10011001         \ Polygon 3 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10011001         \ Polygon 4 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10100101         \ Polygon 5 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10100101         \ Polygon 6 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010001         \ Polygon 7 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx00xx: Fill colour 0 (blue)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010001         \ Polygon 8 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx00xx: Fill colour 0 (blue)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10011001         \ Polygon 9 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010000         \ Polygon 10 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx00xx: Fill colour 0 (blue)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010000         \ Polygon 11 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx00xx: Fill colour 0 (blue)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010100         \ Polygon 12 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010100         \ Polygon 13 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010000         \ Polygon 14 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx00xx: Fill colour 0 (blue)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010000         \ Polygon 15 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx00xx: Fill colour 0 (blue)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10011100         \ Polygon 16 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10011100         \ Polygon 17 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010000         \ Polygon 18 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx00xx: Fill colour 0 (blue)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010101         \ Polygon 19 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00111100         \ Polygon 20 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00111100         \ Polygon 21 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011001         \ Polygon 22 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011001         \ Polygon 23 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 24 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 25 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00111101         \ Polygon 26 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010101         \ Polygon 27 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010100         \ Polygon 28 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010100         \ Polygon 29 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010101         \ Polygon 30 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10101000         \ Polygon 31 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101000         \ Polygon 32 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101000         \ Polygon 33 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101000         \ Polygon 34 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101000         \ Polygon 35 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101001         \ Polygon 36 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10101000         \ Polygon 37 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101000         \ Polygon 38 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010101         \ Polygon 39 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10101000         \ Polygon 40 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010100         \ Polygon 41 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010100         \ Polygon 42 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010101         \ Polygon 43 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 44 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00101001         \ Polygon 45 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00101001         \ Polygon 46 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 47 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011101         \ Polygon 48 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011101         \ Polygon 49 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011101         \ Polygon 50 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011101         \ Polygon 51 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 52 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 53 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 54 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 55 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011001         \ Polygon 56 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011001         \ Polygon 57 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 58 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011000         \ Polygon 59 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011100         \ Polygon 60 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 61 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011100         \ Polygon 62 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 63 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011100         \ Polygon 64 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 65 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011100         \ Polygon 66 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 67 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 68 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 69 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 70 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 71 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 72 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 73 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 74 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010101         \ Polygon 75 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 76 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 77 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00101000         \ Polygon 78 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00101000         \ Polygon 79 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011100         \ Polygon 80 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011100         \ Polygon 81 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00110101         \ Polygon 82 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10111100         \ Polygon 83 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10111100         \ Polygon 84 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10111001         \ Polygon 85 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010100         \ Polygon 86 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 87 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 88 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 89 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 90 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 91 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 92 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00111101         \ Polygon 93 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011000         \ Polygon 94 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011000         \ Polygon 95 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 96 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 97 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00111100         \ Polygon 98 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00111100         \ Polygon 99 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00110101         \ Polygon 100 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00110101         \ Polygon 101 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 102 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010100         \ Polygon 103 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 104 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010101         \ Polygon 105 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10101001         \ Polygon 106 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010101         \ Polygon 107 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010101         \ Polygon 108 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010101         \ Polygon 109 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010101         \ Polygon 110 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010100         \ Polygon 111 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010100         \ Polygon 112 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010101         \ Polygon 113 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10101000         \ Polygon 114 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101000         \ Polygon 115 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101000         \ Polygon 116 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101000         \ Polygon 117 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101000         \ Polygon 118 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101000         \ Polygon 119 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10101001         \ Polygon 120 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %10010100         \ Polygon 121 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010100         \ Polygon 122 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10111100         \ Polygon 123 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10111100         \ Polygon 124 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %10010101         \ Polygon 125 data:
                        \
                        \   * %1xxxxxxx: Draw polygon in second phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 126 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 127 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010100         \ Polygon 128 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00010100         \ Polygon 129 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00011101         \ Polygon 130 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011101         \ Polygon 131 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011101         \ Polygon 132 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00011101         \ Polygon 133 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 134 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00101001         \ Polygon 135 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00101001         \ Polygon 136 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 137 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00101001         \ Polygon 138 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 139 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00101001         \ Polygon 140 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00111100         \ Polygon 141 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00111100         \ Polygon 142 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00111100         \ Polygon 143 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00111100         \ Polygon 144 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx00: Polygon has three sides (triangle)

 EQUB %00111101         \ Polygon 145 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00111101         \ Polygon 146 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00111101         \ Polygon 147 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 148 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 149 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00101001         \ Polygon 150 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00111101         \ Polygon 151 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 152 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 153 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00101001         \ Polygon 154 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00111101         \ Polygon 155 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 156 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00010101         \ Polygon 157 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx01xxxx: Edge colour 1 (black)
                        \   * %xxxx01xx: Fill colour 1 (black)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00101001         \ Polygon 158 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx10xxxx: Edge colour 2 (white/yellow/cyan/red)
                        \   * %xxxx10xx: Fill colour 2 (white/yellow/cyan/red)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

 EQUB %00111101         \ Polygon 159 data:
                        \
                        \   * %0xxxxxxx: Draw polygon in first phase
                        \   * %xx11xxxx: Edge colour 3 (green/red/yellow/cyan)
                        \   * %xxxx11xx: Fill colour 3 (green/red/yellow/cyan)
                        \   * %xxxxxx01: Polygon has four sides (quadrilateral)

\ ******************************************************************************
\
\       Name: screenBufferRow13
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 13
\
\ ******************************************************************************

.screenBufferRow13

 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF        \ These values are workspace
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ noise and have no meaning
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &12
 EQUB &FE, &FE, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF

\ ******************************************************************************
\
\       Name: objPolygonAddrLo
\       Type: Variable
\   Category: Drawing objects
\    Summary: Addresses for the list of polygons and points for each object
\             (low byte)
\
\ ******************************************************************************

.objPolygonAddrLo

 EQUB LO(objPolygon000) \ Object type 0: Robot (polygons 0 to 26)
 EQUB LO(objPolygon001)
 EQUB LO(objPolygon002)
 EQUB LO(objPolygon003)
 EQUB LO(objPolygon004)
 EQUB LO(objPolygon005)
 EQUB LO(objPolygon006)
 EQUB LO(objPolygon007)
 EQUB LO(objPolygon008)
 EQUB LO(objPolygon009)
 EQUB LO(objPolygon010)
 EQUB LO(objPolygon011)
 EQUB LO(objPolygon012)
 EQUB LO(objPolygon013)
 EQUB LO(objPolygon014)
 EQUB LO(objPolygon015)
 EQUB LO(objPolygon016)
 EQUB LO(objPolygon017)
 EQUB LO(objPolygon018)
 EQUB LO(objPolygon019)
 EQUB LO(objPolygon020)
 EQUB LO(objPolygon021)
 EQUB LO(objPolygon022)
 EQUB LO(objPolygon023)
 EQUB LO(objPolygon024)
 EQUB LO(objPolygon025)
 EQUB LO(objPolygon026)

 EQUB LO(objPolygon027) \ Object type 1: Sentry (polygons 27 to 51)
 EQUB LO(objPolygon028)
 EQUB LO(objPolygon029)
 EQUB LO(objPolygon030)
 EQUB LO(objPolygon031)
 EQUB LO(objPolygon032)
 EQUB LO(objPolygon033)
 EQUB LO(objPolygon034)
 EQUB LO(objPolygon035)
 EQUB LO(objPolygon036)
 EQUB LO(objPolygon037)
 EQUB LO(objPolygon038)
 EQUB LO(objPolygon039)
 EQUB LO(objPolygon040)
 EQUB LO(objPolygon041)
 EQUB LO(objPolygon042)
 EQUB LO(objPolygon043)
 EQUB LO(objPolygon044)
 EQUB LO(objPolygon045)
 EQUB LO(objPolygon046)
 EQUB LO(objPolygon047)
 EQUB LO(objPolygon048)
 EQUB LO(objPolygon049)
 EQUB LO(objPolygon050)
 EQUB LO(objPolygon051)

 EQUB LO(objPolygon052) \ Object type 2: Tree (polygons 52 to 66)
 EQUB LO(objPolygon053)
 EQUB LO(objPolygon054)
 EQUB LO(objPolygon055)
 EQUB LO(objPolygon056)
 EQUB LO(objPolygon057)
 EQUB LO(objPolygon058)
 EQUB LO(objPolygon059)
 EQUB LO(objPolygon060)
 EQUB LO(objPolygon061)
 EQUB LO(objPolygon062)
 EQUB LO(objPolygon063)
 EQUB LO(objPolygon064)
 EQUB LO(objPolygon065)
 EQUB LO(objPolygon066)

 EQUB LO(objPolygon067) \ Object type 3: Boulder (polygons 67 to 76)
 EQUB LO(objPolygon068)
 EQUB LO(objPolygon069)
 EQUB LO(objPolygon070)
 EQUB LO(objPolygon071)
 EQUB LO(objPolygon072)
 EQUB LO(objPolygon073)
 EQUB LO(objPolygon074)
 EQUB LO(objPolygon075)
 EQUB LO(objPolygon076)

 EQUB LO(objPolygon077) \ Object type 4: Meanie (polygons 77 to 101)
 EQUB LO(objPolygon078)
 EQUB LO(objPolygon079)
 EQUB LO(objPolygon080)
 EQUB LO(objPolygon081)
 EQUB LO(objPolygon082)
 EQUB LO(objPolygon083)
 EQUB LO(objPolygon084)
 EQUB LO(objPolygon085)
 EQUB LO(objPolygon086)
 EQUB LO(objPolygon087)
 EQUB LO(objPolygon088)
 EQUB LO(objPolygon089)
 EQUB LO(objPolygon090)
 EQUB LO(objPolygon091)
 EQUB LO(objPolygon092)
 EQUB LO(objPolygon093)
 EQUB LO(objPolygon094)
 EQUB LO(objPolygon095)
 EQUB LO(objPolygon096)
 EQUB LO(objPolygon097)
 EQUB LO(objPolygon098)
 EQUB LO(objPolygon099)
 EQUB LO(objPolygon100)
 EQUB LO(objPolygon101)

 EQUB LO(objPolygon102) \ Object type 5: The Sentinel (polygons 102 to 136)
 EQUB LO(objPolygon103)
 EQUB LO(objPolygon104)
 EQUB LO(objPolygon105)
 EQUB LO(objPolygon106)
 EQUB LO(objPolygon107)
 EQUB LO(objPolygon108)
 EQUB LO(objPolygon109)
 EQUB LO(objPolygon110)
 EQUB LO(objPolygon111)
 EQUB LO(objPolygon112)
 EQUB LO(objPolygon113)
 EQUB LO(objPolygon114)
 EQUB LO(objPolygon115)
 EQUB LO(objPolygon116)
 EQUB LO(objPolygon117)
 EQUB LO(objPolygon118)
 EQUB LO(objPolygon119)
 EQUB LO(objPolygon120)
 EQUB LO(objPolygon121)
 EQUB LO(objPolygon122)
 EQUB LO(objPolygon123)
 EQUB LO(objPolygon124)
 EQUB LO(objPolygon125)
 EQUB LO(objPolygon126)
 EQUB LO(objPolygon127)
 EQUB LO(objPolygon128)
 EQUB LO(objPolygon129)
 EQUB LO(objPolygon130)
 EQUB LO(objPolygon131)
 EQUB LO(objPolygon132)
 EQUB LO(objPolygon133)
 EQUB LO(objPolygon134)
 EQUB LO(objPolygon135)
 EQUB LO(objPolygon136)

 EQUB LO(objPolygon137) \ Object type 6: Sentinel's tower (polygons 137 to 147)
 EQUB LO(objPolygon138)
 EQUB LO(objPolygon139)
 EQUB LO(objPolygon140)
 EQUB LO(objPolygon141)
 EQUB LO(objPolygon142)
 EQUB LO(objPolygon143)
 EQUB LO(objPolygon144)
 EQUB LO(objPolygon145)
 EQUB LO(objPolygon146)
 EQUB LO(objPolygon147)

 EQUB LO(objPolygon148) \ Object type 7: 3D text block 1 (polygons 148 to 151)
 EQUB LO(objPolygon149) \
 EQUB LO(objPolygon150) \ Polygons 148 to 151 use the point list in objTextBlock
 EQUB LO(objPolygon151) \ with a point range of 136 to 143

 EQUB LO(objPolygon148) \ Object type 8: 3D text block 2 (polygons 152 to 155)
 EQUB LO(objPolygon149) \
 EQUB LO(objPolygon150) \ Polygons 152 to 155 use the point list in objTextBlock
 EQUB LO(objPolygon151) \ with a point range of 144 to 151

 EQUB LO(objPolygon148) \ Object type 9: 3D text block 3 (polygons 156 to 159)
 EQUB LO(objPolygon149) \
 EQUB LO(objPolygon150) \ Polygons 156 to 159 use the point list in objTextBlock
 EQUB LO(objPolygon151) \ with a point range of 152 to 159

\ ******************************************************************************
\
\       Name: screenBufferRow14
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 14
\
\ ******************************************************************************

.screenBufferRow14

 EQUB &FE, &FE, &FF, &FF, &FF, &FF, &FF, &FF        \ These values are workspace
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ noise and have no meaning
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FE, &FE, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF

\ ******************************************************************************
\
\       Name: objPolygonAddrHi
\       Type: Variable
\   Category: Drawing objects
\    Summary: Addresses for the list of polygons and points for each object
\             (high byte)
\
\ ******************************************************************************

.objPolygonAddrHi

 EQUB HI(objPolygon000) \ Object type 0: Robot (polygons 0 to 26)
 EQUB HI(objPolygon001)
 EQUB HI(objPolygon002)
 EQUB HI(objPolygon003)
 EQUB HI(objPolygon004)
 EQUB HI(objPolygon005)
 EQUB HI(objPolygon006)
 EQUB HI(objPolygon007)
 EQUB HI(objPolygon008)
 EQUB HI(objPolygon009)
 EQUB HI(objPolygon010)
 EQUB HI(objPolygon011)
 EQUB HI(objPolygon012)
 EQUB HI(objPolygon013)
 EQUB HI(objPolygon014)
 EQUB HI(objPolygon015)
 EQUB HI(objPolygon016)
 EQUB HI(objPolygon017)
 EQUB HI(objPolygon018)
 EQUB HI(objPolygon019)
 EQUB HI(objPolygon020)
 EQUB HI(objPolygon021)
 EQUB HI(objPolygon022)
 EQUB HI(objPolygon023)
 EQUB HI(objPolygon024)
 EQUB HI(objPolygon025)
 EQUB HI(objPolygon026)

 EQUB HI(objPolygon027) \ Object type 1: Sentry (polygons 27 to 51)
 EQUB HI(objPolygon028)
 EQUB HI(objPolygon029)
 EQUB HI(objPolygon030)
 EQUB HI(objPolygon031)
 EQUB HI(objPolygon032)
 EQUB HI(objPolygon033)
 EQUB HI(objPolygon034)
 EQUB HI(objPolygon035)
 EQUB HI(objPolygon036)
 EQUB HI(objPolygon037)
 EQUB HI(objPolygon038)
 EQUB HI(objPolygon039)
 EQUB HI(objPolygon040)
 EQUB HI(objPolygon041)
 EQUB HI(objPolygon042)
 EQUB HI(objPolygon043)
 EQUB HI(objPolygon044)
 EQUB HI(objPolygon045)
 EQUB HI(objPolygon046)
 EQUB HI(objPolygon047)
 EQUB HI(objPolygon048)
 EQUB HI(objPolygon049)
 EQUB HI(objPolygon050)
 EQUB HI(objPolygon051)

 EQUB HI(objPolygon052) \ Object type 2: Tree (polygons 52 to 66)
 EQUB HI(objPolygon053)
 EQUB HI(objPolygon054)
 EQUB HI(objPolygon055)
 EQUB HI(objPolygon056)
 EQUB HI(objPolygon057)
 EQUB HI(objPolygon058)
 EQUB HI(objPolygon059)
 EQUB HI(objPolygon060)
 EQUB HI(objPolygon061)
 EQUB HI(objPolygon062)
 EQUB HI(objPolygon063)
 EQUB HI(objPolygon064)
 EQUB HI(objPolygon065)
 EQUB HI(objPolygon066)

 EQUB HI(objPolygon067) \ Object type 3: Boulder (polygons 67 to 76)
 EQUB HI(objPolygon068)
 EQUB HI(objPolygon069)
 EQUB HI(objPolygon070)
 EQUB HI(objPolygon071)
 EQUB HI(objPolygon072)
 EQUB HI(objPolygon073)
 EQUB HI(objPolygon074)
 EQUB HI(objPolygon075)
 EQUB HI(objPolygon076)

 EQUB HI(objPolygon077) \ Object type 4: Meanie (polygons 77 to 101)
 EQUB HI(objPolygon078)
 EQUB HI(objPolygon079)
 EQUB HI(objPolygon080)
 EQUB HI(objPolygon081)
 EQUB HI(objPolygon082)
 EQUB HI(objPolygon083)
 EQUB HI(objPolygon084)
 EQUB HI(objPolygon085)
 EQUB HI(objPolygon086)
 EQUB HI(objPolygon087)
 EQUB HI(objPolygon088)
 EQUB HI(objPolygon089)
 EQUB HI(objPolygon090)
 EQUB HI(objPolygon091)
 EQUB HI(objPolygon092)
 EQUB HI(objPolygon093)
 EQUB HI(objPolygon094)
 EQUB HI(objPolygon095)
 EQUB HI(objPolygon096)
 EQUB HI(objPolygon097)
 EQUB HI(objPolygon098)
 EQUB HI(objPolygon099)
 EQUB HI(objPolygon100)
 EQUB HI(objPolygon101)

 EQUB HI(objPolygon102) \ Object type 5: The Sentinel (polygons 102 to 136)
 EQUB HI(objPolygon103)
 EQUB HI(objPolygon104)
 EQUB HI(objPolygon105)
 EQUB HI(objPolygon106)
 EQUB HI(objPolygon107)
 EQUB HI(objPolygon108)
 EQUB HI(objPolygon109)
 EQUB HI(objPolygon110)
 EQUB HI(objPolygon111)
 EQUB HI(objPolygon112)
 EQUB HI(objPolygon113)
 EQUB HI(objPolygon114)
 EQUB HI(objPolygon115)
 EQUB HI(objPolygon116)
 EQUB HI(objPolygon117)
 EQUB HI(objPolygon118)
 EQUB HI(objPolygon119)
 EQUB HI(objPolygon120)
 EQUB HI(objPolygon121)
 EQUB HI(objPolygon122)
 EQUB HI(objPolygon123)
 EQUB HI(objPolygon124)
 EQUB HI(objPolygon125)
 EQUB HI(objPolygon126)
 EQUB HI(objPolygon127)
 EQUB HI(objPolygon128)
 EQUB HI(objPolygon129)
 EQUB HI(objPolygon130)
 EQUB HI(objPolygon131)
 EQUB HI(objPolygon132)
 EQUB HI(objPolygon133)
 EQUB HI(objPolygon134)
 EQUB HI(objPolygon135)
 EQUB HI(objPolygon136)

 EQUB HI(objPolygon137) \ Object type 6: Sentinel's tower (polygons 137 to 147)
 EQUB HI(objPolygon138)
 EQUB HI(objPolygon139)
 EQUB HI(objPolygon140)
 EQUB HI(objPolygon141)
 EQUB HI(objPolygon142)
 EQUB HI(objPolygon143)
 EQUB HI(objPolygon144)
 EQUB HI(objPolygon145)
 EQUB HI(objPolygon146)
 EQUB HI(objPolygon147)

 EQUB HI(objPolygon148) \ Object type 7: 3D text block 1 (polygons 148 to 151)
 EQUB HI(objPolygon149)
 EQUB HI(objPolygon150)
 EQUB HI(objPolygon151)

 EQUB HI(objPolygon148) \ Object type 8: 3D text block 2 (polygons 152 to 155)
 EQUB HI(objPolygon149) \
 EQUB HI(objPolygon150) \ Polygons 152 to 155 reuse the points from 148 to 151
 EQUB HI(objPolygon151)

 EQUB HI(objPolygon148) \ Object type 9: 3D text block 3 (polygons 156 to 159)
 EQUB HI(objPolygon149) \
 EQUB HI(objPolygon150) \ Polygons 156 to 159 reuse the points from 148 to 151
 EQUB HI(objPolygon151)

\ ******************************************************************************
\
\       Name: screenBufferRow15
\       Type: Subroutine
\   Category: Landscape
\    Summary: The screen buffer for character row 15
\
\ ******************************************************************************

.screenBufferRow15

 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF        \ These values are workspace
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF        \ noise and have no meaning
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FE, &FE, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF

\ ******************************************************************************
\
\       Name: objSentinel
\       Type: Variable
\   Category: Drawing objects
\    Summary: The list of polygons and points for the Sentinel object (polygons
\             102 to 136, using points 94 to 123)
\
\ ******************************************************************************

.objSentinel

.objPolygon102

 EQUB 64 + 20           \ Polygon 102 points: 114, 110, 111, 115, 114
 EQUB 64 + 16
 EQUB 64 + 17
 EQUB 64 + 21
 EQUB 64 + 20

.objPolygon103

 EQUB 64 + 17           \ Polygon 103 points: 111, 108, 115, 111
 EQUB 64 + 14
 EQUB 64 + 21
 EQUB 64 + 17

.objPolygon104

 EQUB 64 + 20           \ Polygon 104 points: 114, 109, 110, 114
 EQUB 64 + 15
 EQUB 64 + 16
 EQUB 64 + 20

.objPolygon105

 EQUB 64 + 15           \ Polygon 105 points: 109, 113, 112, 108, 109
 EQUB 64 + 19
 EQUB 64 + 18
 EQUB 64 + 14
 EQUB 64 + 15

.objPolygon106

 EQUB 64 + 3            \ Polygon 106 points: 97, 101, 100, 96, 97
 EQUB 64 + 7
 EQUB 64 + 6
 EQUB 64 + 2
 EQUB 64 + 3

.objPolygon107

 EQUB 64 + 0            \ Polygon 107 points: 94, 98, 101, 97, 94
 EQUB 64 + 4
 EQUB 64 + 7
 EQUB 64 + 3
 EQUB 64 + 0

.objPolygon108

 EQUB 64 + 2            \ Polygon 108 points: 96, 100, 99, 95, 96
 EQUB 64 + 6
 EQUB 64 + 5
 EQUB 64 + 1
 EQUB 64 + 2

.objPolygon109

 EQUB 64 + 1            \ Polygon 109 points: 95, 99, 98, 94, 95
 EQUB 64 + 5
 EQUB 64 + 4
 EQUB 64 + 0
 EQUB 64 + 1

.objPolygon110

 EQUB 64 + 7            \ Polygon 110 points: 101, 106, 105, 100, 101
 EQUB 64 + 12
 EQUB 64 + 11
 EQUB 64 + 6
 EQUB 64 + 7

.objPolygon111

 EQUB 64 + 4            \ Polygon 111 points: 98, 107, 101, 98
 EQUB 64 + 13
 EQUB 64 + 7
 EQUB 64 + 4

.objPolygon112

 EQUB 64 + 6            \ Polygon 112 points: 100, 104, 99, 100
 EQUB 64 + 10
 EQUB 64 + 5
 EQUB 64 + 6

.objPolygon113

 EQUB 64 + 5            \ Polygon 113 points: 99, 103, 102, 98, 99
 EQUB 64 + 9
 EQUB 64 + 8
 EQUB 64 + 4
 EQUB 64 + 5

.objPolygon114

 EQUB 64 + 7            \ Polygon 114 points: 101, 107, 106, 101
 EQUB 64 + 13
 EQUB 64 + 12
 EQUB 64 + 7

.objPolygon115

 EQUB 64 + 6            \ Polygon 115 points: 100, 105, 104, 100
 EQUB 64 + 11
 EQUB 64 + 10
 EQUB 64 + 6

.objPolygon116

 EQUB 64 + 4            \ Polygon 116 points: 98, 102, 107, 98
 EQUB 64 + 8
 EQUB 64 + 13
 EQUB 64 + 4

.objPolygon117

 EQUB 64 + 5            \ Polygon 117 points: 99, 104, 103, 99
 EQUB 64 + 10
 EQUB 64 + 9
 EQUB 64 + 5

.objPolygon118

 EQUB 64 + 13           \ Polygon 118 points: 107, 111, 106, 107
 EQUB 64 + 17
 EQUB 64 + 12
 EQUB 64 + 13

.objPolygon119

 EQUB 64 + 11           \ Polygon 119 points: 105, 110, 104, 105
 EQUB 64 + 16
 EQUB 64 + 10
 EQUB 64 + 11

.objPolygon120

 EQUB 64 + 12           \ Polygon 120 points: 106, 111, 110, 105, 106
 EQUB 64 + 17
 EQUB 64 + 16
 EQUB 64 + 11
 EQUB 64 + 12

.objPolygon121

 EQUB 64 + 13           \ Polygon 121 points: 107, 108, 111, 107
 EQUB 64 + 14
 EQUB 64 + 17
 EQUB 64 + 13

.objPolygon122

 EQUB 64 + 10           \ Polygon 122 points: 104, 110, 109, 104
 EQUB 64 + 16
 EQUB 64 + 15
 EQUB 64 + 10

.objPolygon123

 EQUB 64 + 8            \ Polygon 123 points: 102, 108, 107, 102
 EQUB 64 + 14
 EQUB 64 + 13
 EQUB 64 + 8

.objPolygon124

 EQUB 64 + 9            \ Polygon 124 points: 103, 104, 109, 103
 EQUB 64 + 10
 EQUB 64 + 15
 EQUB 64 + 9

.objPolygon125

 EQUB 64 + 9            \ Polygon 125 points: 103, 109, 108, 102, 103
 EQUB 64 + 15
 EQUB 64 + 14
 EQUB 64 + 8
 EQUB 64 + 9

.objPolygon126

 EQUB 64 + 25           \ Polygon 126 points: 119, 121, 120, 118, 119
 EQUB 64 + 27
 EQUB 64 + 26
 EQUB 64 + 24
 EQUB 64 + 25

.objPolygon127

 EQUB 64 + 21           \ Polygon 127 points: 115, 123, 122, 114, 115
 EQUB 64 + 29
 EQUB 64 + 28
 EQUB 64 + 20
 EQUB 64 + 21

.objPolygon128

 EQUB 64 + 14           \ Polygon 128 points: 108, 118, 115, 108
 EQUB 64 + 24
 EQUB 64 + 21
 EQUB 64 + 14

.objPolygon129

 EQUB 64 + 20           \ Polygon 129 points: 114, 119, 109, 114
 EQUB 64 + 25
 EQUB 64 + 15
 EQUB 64 + 20

.objPolygon130

 EQUB 64 + 18           \ Polygon 130 points: 112, 116, 118, 108, 112
 EQUB 64 + 22
 EQUB 64 + 24
 EQUB 64 + 14
 EQUB 64 + 18

.objPolygon131

 EQUB 64 + 15           \ Polygon 131 points: 109, 119, 117, 113, 109
 EQUB 64 + 25
 EQUB 64 + 23
 EQUB 64 + 19
 EQUB 64 + 15

.objPolygon132

 EQUB 64 + 23           \ Polygon 132 points: 117, 119, 118, 116, 117
 EQUB 64 + 25
 EQUB 64 + 24
 EQUB 64 + 22
 EQUB 64 + 23

.objPolygon133

 EQUB 64 + 19           \ Polygon 133 points: 113, 117, 116, 112, 113
 EQUB 64 + 23
 EQUB 64 + 22
 EQUB 64 + 18
 EQUB 64 + 19

.objPolygon134

 EQUB 64 + 27           \ Polygon 134 points: 121, 122, 123, 120, 121
 EQUB 64 + 28
 EQUB 64 + 29
 EQUB 64 + 26
 EQUB 64 + 27

.objPolygon135

 EQUB 64 + 24           \ Polygon 135 points: 118, 120, 123, 115, 118
 EQUB 64 + 26
 EQUB 64 + 29
 EQUB 64 + 21
 EQUB 64 + 24

.objPolygon136

 EQUB 64 + 20           \ Polygon 136 points: 114, 122, 121, 119, 114
 EQUB 64 + 28
 EQUB 64 + 27
 EQUB 64 + 25
 EQUB 64 + 20

 EQUB &10               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: objTree
\       Type: Variable
\   Category: Drawing objects
\    Summary: The list of polygons and points for the tree object (polygons 52
\             to 66, using points 51 to 67)
\
\ ******************************************************************************

.objTree

.objPolygon052

 EQUB 64 + 8            \ Polygon 52 points: 59, 66, 65, 60, 59
 EQUB 64 + 15
 EQUB 64 + 14
 EQUB 64 + 9
 EQUB 64 + 8

.objPolygon053

 EQUB 64 + 9            \ Polygon 53 points: 60, 65, 64, 61, 60
 EQUB 64 + 14
 EQUB 64 + 13
 EQUB 64 + 10
 EQUB 64 + 9

.objPolygon054

 EQUB 64 + 10           \ Polygon 54 points: 61, 64, 63, 62, 61
 EQUB 64 + 13
 EQUB 64 + 12
 EQUB 64 + 11
 EQUB 64 + 10

.objPolygon055

 EQUB 64 + 1            \ Polygon 55 points: 52, 56, 55, 51, 52
 EQUB 64 + 5
 EQUB 64 + 4
 EQUB 64 + 0
 EQUB 64 + 1

.objPolygon056

 EQUB 64 + 2            \ Polygon 56 points: 53, 57, 56, 52, 53
 EQUB 64 + 6
 EQUB 64 + 5
 EQUB 64 + 1
 EQUB 64 + 2

.objPolygon057

 EQUB 64 + 0            \ Polygon 57 points: 51, 55, 58, 54, 51
 EQUB 64 + 4
 EQUB 64 + 7
 EQUB 64 + 3
 EQUB 64 + 0

.objPolygon058

 EQUB 64 + 3            \ Polygon 58 points: 54, 58, 57, 53, 54
 EQUB 64 + 7
 EQUB 64 + 6
 EQUB 64 + 2
 EQUB 64 + 3

.objPolygon059

 EQUB 64 + 8            \ Polygon 59 points: 59, 67, 66, 59
 EQUB 64 + 16
 EQUB 64 + 15
 EQUB 64 + 8

.objPolygon060

 EQUB 64 + 9            \ Polygon 60 points: 60, 67, 59, 60
 EQUB 64 + 16
 EQUB 64 + 8
 EQUB 64 + 9

.objPolygon061

 EQUB 64 + 10           \ Polygon 61 points: 61, 67, 60, 61
 EQUB 64 + 16
 EQUB 64 + 9
 EQUB 64 + 10

.objPolygon062

 EQUB 64 + 11           \ Polygon 62 points: 62, 67, 61, 62
 EQUB 64 + 16
 EQUB 64 + 10
 EQUB 64 + 11

.objPolygon063

 EQUB 64 + 12           \ Polygon 63 points: 63, 67, 62, 63
 EQUB 64 + 16
 EQUB 64 + 11
 EQUB 64 + 12

.objPolygon064

 EQUB 64 + 13           \ Polygon 64 points: 64, 67, 63, 64
 EQUB 64 + 16
 EQUB 64 + 12
 EQUB 64 + 13

.objPolygon065

 EQUB 64 + 14           \ Polygon 65 points: 65, 67, 64, 65
 EQUB 64 + 16
 EQUB 64 + 13
 EQUB 64 + 14

.objPolygon066

 EQUB 64 + 15           \ Polygon 66 points: 66, 67, 65, 66
 EQUB 64 + 16
 EQUB 64 + 14
 EQUB 64 + 15

\ ******************************************************************************
\
\       Name: objBoulder
\       Type: Variable
\   Category: Drawing objects
\    Summary: The list of polygons and points for the boulder object (polygons
\             67 to 76, using points 68 to 75)
\
\ ******************************************************************************

.objBoulder

.objPolygon067

 EQUB 64 + 1            \ Polygon 67 points: 69, 68, 75, 69
 EQUB 64 + 0
 EQUB 64 + 7
 EQUB 64 + 1

.objPolygon068

 EQUB 64 + 3            \ Polygon 68 points: 71, 70, 69, 71
 EQUB 64 + 2
 EQUB 64 + 1
 EQUB 64 + 3

.objPolygon069

 EQUB 64 + 5            \ Polygon 69 points: 73, 72, 71, 73
 EQUB 64 + 4
 EQUB 64 + 3
 EQUB 64 + 5

.objPolygon070

 EQUB 64 + 7            \ Polygon 70 points: 75, 74, 73, 75
 EQUB 64 + 6
 EQUB 64 + 5
 EQUB 64 + 7

.objPolygon071

 EQUB 64 + 1            \ Polygon 71 points: 69, 70, 68, 69
 EQUB 64 + 2
 EQUB 64 + 0
 EQUB 64 + 1

.objPolygon072

 EQUB 64 + 3            \ Polygon 72 points: 71, 72, 70, 71
 EQUB 64 + 4
 EQUB 64 + 2
 EQUB 64 + 3

.objPolygon073

 EQUB 64 + 5            \ Polygon 73 points: 73, 74, 72, 73
 EQUB 64 + 6
 EQUB 64 + 4
 EQUB 64 + 5

.objPolygon074

 EQUB 64 + 7            \ Polygon 74 points: 75, 68, 74, 75
 EQUB 64 + 0
 EQUB 64 + 6
 EQUB 64 + 7

.objPolygon075

 EQUB 64 + 1            \ Polygon 75 points: 69, 75, 73, 71, 69
 EQUB 64 + 7
 EQUB 64 + 5
 EQUB 64 + 3
 EQUB 64 + 1

.objPolygon076

 EQUB 64 + 0            \ Polygon 76 points: 68, 70, 72, 74, 68
 EQUB 64 + 2
 EQUB 64 + 4
 EQUB 64 + 6
 EQUB 64 + 0

\ ******************************************************************************
\
\       Name: objTower
\       Type: Variable
\   Category: Drawing objects
\    Summary: The list of polygons and points for the Sentinel's tower object
\             (polygons 137 to 147, using points 124 to 135)
\
\ ******************************************************************************

.objTower

.objPolygon137

 EQUB 64 + 1            \ Polygon 137 points: 125, 130, 129, 124, 125
 EQUB 64 + 6
 EQUB 64 + 5
 EQUB 64 + 0
 EQUB 64 + 1

.objPolygon138

 EQUB 64 + 2            \ Polygon 138 points: 126, 132, 131, 125, 126
 EQUB 64 + 8
 EQUB 64 + 7
 EQUB 64 + 1
 EQUB 64 + 2

.objPolygon139

 EQUB 64 + 3            \ Polygon 139 points: 127, 134, 133, 126, 127
 EQUB 64 + 10
 EQUB 64 + 9
 EQUB 64 + 2
 EQUB 64 + 3

.objPolygon140

 EQUB 64 + 0            \ Polygon 140 points: 124, 128, 135, 127, 124
 EQUB 64 + 4
 EQUB 64 + 11
 EQUB 64 + 3
 EQUB 64 + 0

.objPolygon141

 EQUB 64 + 0            \ Polygon 141 points: 124, 129, 128, 124
 EQUB 64 + 5
 EQUB 64 + 4
 EQUB 64 + 0

.objPolygon142

 EQUB 64 + 1            \ Polygon 142 points: 125, 131, 130, 125
 EQUB 64 + 7
 EQUB 64 + 6
 EQUB 64 + 1

.objPolygon143

 EQUB 64 + 2            \ Polygon 143 points: 126, 133, 132, 126
 EQUB 64 + 9
 EQUB 64 + 8
 EQUB 64 + 2

.objPolygon144

 EQUB 64 + 3            \ Polygon 144 points: 127, 135, 134, 127
 EQUB 64 + 11
 EQUB 64 + 10
 EQUB 64 + 3

.objPolygon145

 EQUB 64 + 6            \ Polygon 145 points: 130, 131, 132, 133, 130
 EQUB 64 + 7
 EQUB 64 + 8
 EQUB 64 + 9
 EQUB 64 + 6

.objPolygon146

 EQUB 64 + 6            \ Polygon 146 points: 130, 133, 134, 129, 130
 EQUB 64 + 9
 EQUB 64 + 10
 EQUB 64 + 5
 EQUB 64 + 6

.objPolygon147

 EQUB 64 + 5            \ Polygon 147 points: 129, 134, 135, 128, 129
 EQUB 64 + 10
 EQUB 64 + 11
 EQUB 64 + 4
 EQUB 64 + 5

\ ******************************************************************************
\
\       Name: objTextBlock
\       Type: Variable
\   Category: Drawing objects
\    Summary: The list of polygons and points for the 3D text block object
\             (polygons 148 to 151, using points 136 to 143)
\
\ ------------------------------------------------------------------------------
\
\ The three 3D text block objects share the same point lists below, as they have
\ the same basic block shape, but they have different point ranges and so have
\ different dimensions (one for each of the three block pairs we need to draw
\ large 3D text on the title screens).
\
\   * Object 7, 3D text block 1, draws no-block (left), block (right).
\     It is made up of polygons 148 to 151, using points 136 to 143.
\
\   * Object 8, 3D text block 2, draws block (left), no-block (right).
\     It is made up of polygons 152 to 155, using points 144 to 151.
\
\   * Object 9, 3D text block 3, draws block (left), block (right).
\     It is made up of polygons 156 to 159, using points 152 to 159.
\
\ See the SpawnCharacter3D routine for more about the block pairs that are used
\ to draw large 3D text.
\
\ ******************************************************************************

.objTextBlock

.objPolygon148

 EQUB 64 + 0            \ Polygon 148 points: 136, 140, 143, 139, 136
 EQUB 64 + 4            \ Polygon 152 points: 144, 148, 151, 147, 144
 EQUB 64 + 7            \ Polygon 156 points: 152, 156, 159, 155, 152
 EQUB 64 + 3
 EQUB 64 + 0

.objPolygon149

 EQUB 64 + 2            \ Polygon 149 points: 138, 142, 141, 137, 138
 EQUB 64 + 6            \ Polygon 153 points: 146, 150, 149, 145, 146
 EQUB 64 + 5            \ Polygon 157 points: 154, 158, 157, 153, 154
 EQUB 64 + 1
 EQUB 64 + 2

.objPolygon150

 EQUB 64 + 1            \ Polygon 150 points: 137, 141, 140, 136, 137
 EQUB 64 + 5            \ Polygon 154 points: 145, 149, 148, 144, 145
 EQUB 64 + 4            \ Polygon 158 points: 153, 157, 156, 152, 153
 EQUB 64 + 0
 EQUB 64 + 1

.objPolygon151

 EQUB 64 + 5            \ Polygon 151 points: 141, 142, 143, 140, 141
 EQUB 64 + 6            \ Polygon 155 points: 149, 150, 151, 148, 149
 EQUB 64 + 7            \ Polygon 159 points: 157, 158, 159, 156, 157
 EQUB 64 + 4
 EQUB 64 + 5

\ ******************************************************************************
\
\       Name: objRobot
\       Type: Variable
\   Category: Drawing objects
\    Summary: The list of polygons and points for the robot object (polygons 0
\             to 26, using points 0 to 28)
\
\ ******************************************************************************

.objRobot

.objPolygon000

 EQUB 64 + 11           \ Polygon  points: 11, 10, 8, 12, 11
 EQUB 64 + 10
 EQUB 64 + 8
 EQUB 64 + 12
 EQUB 64 + 11

.objPolygon001

 EQUB 64 + 10           \ Polygon 1 points: 10, 9, 8, 10
 EQUB 64 + 9
 EQUB 64 + 8
 EQUB 64 + 10

.objPolygon002

 EQUB 64 + 20           \ Polygon 2 points: 20, 19, 18, 21, 20
 EQUB 64 + 19
 EQUB 64 + 18
 EQUB 64 + 21
 EQUB 64 + 20

.objPolygon003

 EQUB 64 + 0            \ Polygon 3 points: 0, 4, 7, 3, 0
 EQUB 64 + 4
 EQUB 64 + 7
 EQUB 64 + 3
 EQUB 64 + 0

.objPolygon004

 EQUB 64 + 2            \ Polygon 4 points: 2, 6, 5, 1, 2
 EQUB 64 + 6
 EQUB 64 + 5
 EQUB 64 + 1
 EQUB 64 + 2

.objPolygon005

 EQUB 64 + 3            \ Polygon 5 points: 3, 7, 6, 2, 3
 EQUB 64 + 7
 EQUB 64 + 6
 EQUB 64 + 2
 EQUB 64 + 3

.objPolygon006

 EQUB 64 + 1            \ Polygon 6 points: 1, 5, 4, 0, 1
 EQUB 64 + 5
 EQUB 64 + 4
 EQUB 64 + 0
 EQUB 64 + 1

.objPolygon007

 EQUB 64 + 8            \ Polygon 7 points: 8, 13, 16, 12, 8
 EQUB 64 + 13
 EQUB 64 + 16
 EQUB 64 + 12
 EQUB 64 + 8

.objPolygon008

 EQUB 64 + 11           \ Polygon 8 points: 11, 15, 14, 10, 11
 EQUB 64 + 15
 EQUB 64 + 14
 EQUB 64 + 10
 EQUB 64 + 11

.objPolygon009

 EQUB 64 + 12           \ Polygon 9 points: 12, 16, 15, 11, 12
 EQUB 64 + 16
 EQUB 64 + 15
 EQUB 64 + 11
 EQUB 64 + 12

.objPolygon010

 EQUB 64 + 10           \ Polygon 10 points: 10, 28, 9, 10
 EQUB 64 + 28
 EQUB 64 + 9
 EQUB 64 + 10

.objPolygon011

 EQUB 64 + 9            \ Polygon 11 points: 9, 28, 8, 9
 EQUB 64 + 28
 EQUB 64 + 8
 EQUB 64 + 9

.objPolygon012

 EQUB 64 + 10           \ Polygon 12 points: 10, 14, 28, 10
 EQUB 64 + 14
 EQUB 64 + 28
 EQUB 64 + 10

.objPolygon013

 EQUB 64 + 8            \ Polygon 13 points: 8, 28, 13, 8
 EQUB 64 + 28
 EQUB 64 + 13
 EQUB 64 + 8

.objPolygon014

 EQUB 64 + 14           \ Polygon 14 points: 14, 17, 28, 14
 EQUB 64 + 17
 EQUB 64 + 28
 EQUB 64 + 14

.objPolygon015

 EQUB 64 + 28           \ Polygon 15 points: 28, 17, 13, 28
 EQUB 64 + 17
 EQUB 64 + 13
 EQUB 64 + 28

.objPolygon016

 EQUB 64 + 15           \ Polygon 16 points: 15, 17, 14, 15
 EQUB 64 + 17
 EQUB 64 + 14
 EQUB 64 + 15

.objPolygon017

 EQUB 64 + 13           \ Polygon 17 points: 13, 17, 16, 13
 EQUB 64 + 17
 EQUB 64 + 16
 EQUB 64 + 13

.objPolygon018

 EQUB 64 + 16           \ Polygon 18 points: 16, 17, 15, 16
 EQUB 64 + 17
 EQUB 64 + 15
 EQUB 64 + 16

.objPolygon019

 EQUB 64 + 19           \ Polygon 19 points: 19, 26, 27, 18, 19
 EQUB 64 + 26
 EQUB 64 + 27
 EQUB 64 + 18
 EQUB 64 + 19

.objPolygon020

 EQUB 64 + 18           \ Polygon 20 points: 18, 27, 21, 18
 EQUB 64 + 27
 EQUB 64 + 21
 EQUB 64 + 18

.objPolygon021

 EQUB 64 + 20           \ Polygon 21 points: 20, 26, 19, 20
 EQUB 64 + 26
 EQUB 64 + 19
 EQUB 64 + 20

.objPolygon022

 EQUB 64 + 27           \ Polygon 22 points: 27, 22, 25, 21, 27
 EQUB 64 + 22
 EQUB 64 + 25
 EQUB 64 + 21
 EQUB 64 + 27

.objPolygon023

 EQUB 64 + 20           \ Polygon 23 points: 20, 24, 23, 26, 20
 EQUB 64 + 24
 EQUB 64 + 23
 EQUB 64 + 26
 EQUB 64 + 20

.objPolygon024

 EQUB 64 + 21           \ Polygon 24 points: 21, 25, 24, 20, 21
 EQUB 64 + 25
 EQUB 64 + 24
 EQUB 64 + 20
 EQUB 64 + 21

.objPolygon025

 EQUB 64 + 23           \ Polygon 25 points: 23, 24, 25, 22, 23
 EQUB 64 + 24
 EQUB 64 + 25
 EQUB 64 + 22
 EQUB 64 + 23

.objPolygon026

 EQUB 64 + 26           \ Polygon 26 points: 26, 23, 22, 27, 26
 EQUB 64 + 23
 EQUB 64 + 22
 EQUB 64 + 27
 EQUB 64 + 26

\ ******************************************************************************
\
\       Name: objSentry
\       Type: Variable
\   Category: Drawing objects
\    Summary: The list of polygons and points for the sentry object (polygons
\             27 to 51, using points 29 to 50)
\
\ ******************************************************************************

.objSentry

.objPolygon027

 EQUB 64 + 3            \ Polygon 27 points: 32, 37, 36, 31, 32
 EQUB 64 + 8
 EQUB 64 + 7
 EQUB 64 + 2
 EQUB 64 + 3

.objPolygon028

 EQUB 64 + 0            \ Polygon 28 points: 29, 38, 32, 29
 EQUB 64 + 9
 EQUB 64 + 3
 EQUB 64 + 0

.objPolygon029

 EQUB 64 + 2            \ Polygon 29 points: 31, 35, 30, 31
 EQUB 64 + 6
 EQUB 64 + 1
 EQUB 64 + 2

.objPolygon030

 EQUB 64 + 1            \ Polygon 30 points: 30, 34, 33, 29, 30
 EQUB 64 + 5
 EQUB 64 + 4
 EQUB 64 + 0
 EQUB 64 + 1

.objPolygon031

 EQUB 64 + 3            \ Polygon 31 points: 32, 38, 37, 32
 EQUB 64 + 9
 EQUB 64 + 8
 EQUB 64 + 3

.objPolygon032

 EQUB 64 + 2            \ Polygon 32 points: 31, 36, 35, 31
 EQUB 64 + 7
 EQUB 64 + 6
 EQUB 64 + 2

.objPolygon033

 EQUB 64 + 1            \ Polygon 33 points: 30, 35, 34, 30
 EQUB 64 + 6
 EQUB 64 + 5
 EQUB 64 + 1

.objPolygon034

 EQUB 64 + 0            \ Polygon 34 points: 29, 33, 38, 29
 EQUB 64 + 4
 EQUB 64 + 9
 EQUB 64 + 0

.objPolygon035

 EQUB 64 + 9            \ Polygon 35 points: 38, 42, 37, 38
 EQUB 64 + 13
 EQUB 64 + 8
 EQUB 64 + 9

.objPolygon036

 EQUB 64 + 8            \ Polygon 36 points: 37, 42, 41, 36, 37
 EQUB 64 + 13
 EQUB 64 + 12
 EQUB 64 + 7
 EQUB 64 + 8

.objPolygon037

 EQUB 64 + 7            \ Polygon 37 points: 36, 41, 35, 36
 EQUB 64 + 12
 EQUB 64 + 6
 EQUB 64 + 7

.objPolygon038

 EQUB 64 + 6            \ Polygon 38 points: 35, 40, 34, 35
 EQUB 64 + 11
 EQUB 64 + 5
 EQUB 64 + 6

.objPolygon039

 EQUB 64 + 5            \ Polygon 39 points: 34, 40, 39, 33, 34
 EQUB 64 + 11
 EQUB 64 + 10
 EQUB 64 + 4
 EQUB 64 + 5

.objPolygon040

 EQUB 64 + 4            \ Polygon 40 points: 33, 39, 38, 33
 EQUB 64 + 10
 EQUB 64 + 9
 EQUB 64 + 4

.objPolygon041

 EQUB 64 + 9            \ Polygon 41 points: 38, 39, 42, 38
 EQUB 64 + 10
 EQUB 64 + 13
 EQUB 64 + 9

.objPolygon042

 EQUB 64 + 6            \ Polygon 42 points: 35, 41, 40, 35
 EQUB 64 + 12
 EQUB 64 + 11
 EQUB 64 + 6

.objPolygon043

 EQUB 64 + 11           \ Polygon 43 points: 40, 44, 43, 39, 40
 EQUB 64 + 15
 EQUB 64 + 14
 EQUB 64 + 10
 EQUB 64 + 11

.objPolygon044

 EQUB 64 + 13           \ Polygon 44 points: 42, 50, 49, 41, 42
 EQUB 64 + 21
 EQUB 64 + 20
 EQUB 64 + 12
 EQUB 64 + 13

.objPolygon045

 EQUB 64 + 10           \ Polygon 45 points: 39, 47, 50, 42, 39
 EQUB 64 + 18
 EQUB 64 + 21
 EQUB 64 + 13
 EQUB 64 + 10

.objPolygon046

 EQUB 64 + 12           \ Polygon 46 points: 41, 49, 48, 40, 41
 EQUB 64 + 20
 EQUB 64 + 19
 EQUB 64 + 11
 EQUB 64 + 12

.objPolygon047

 EQUB 64 + 19           \ Polygon 47 points: 48, 49, 50, 47, 48
 EQUB 64 + 20
 EQUB 64 + 21
 EQUB 64 + 18
 EQUB 64 + 19

.objPolygon048

 EQUB 64 + 17           \ Polygon 48 points: 46, 48, 47, 45, 46
 EQUB 64 + 19
 EQUB 64 + 18
 EQUB 64 + 16
 EQUB 64 + 17

.objPolygon049

 EQUB 64 + 14           \ Polygon 49 points: 43, 45, 47, 39, 43
 EQUB 64 + 16
 EQUB 64 + 18
 EQUB 64 + 10
 EQUB 64 + 14

.objPolygon050

 EQUB 64 + 11           \ Polygon 50 points: 40, 48, 46, 44, 40
 EQUB 64 + 19
 EQUB 64 + 17
 EQUB 64 + 15
 EQUB 64 + 11

.objPolygon051

 EQUB 64 + 15           \ Polygon 51 points: 44, 46, 45, 43, 44
 EQUB 64 + 17
 EQUB 64 + 16
 EQUB 64 + 14
 EQUB 64 + 15

\ ******************************************************************************
\
\       Name: L54A0
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L54A0

 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &00, &00, &00, &00, &00, &00, &00, &00
 EQUB &FF, &FF, &FF, &FF, &FF, &7F, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &FF, &FF, &FF, &FF, &FF, &FF, &FF, &FF
 EQUB &7E, &7B, &79, &7C, &7E, &7B, &79, &7C
 EQUB &B2, &B9, &B2, &A4, &A7, &A8, &A3, &9A
 EQUB &9C, &A5, &9F, &99, &97, &AC, &9E, &9A
 EQUB &A2, &9A, &A1, &9D, &9F, &A3, &00, &00

\ ******************************************************************************
\
\       Name: drawViewYawHi
\       Type: Variable
\   Category: Drawing the landscape
\    Summary: Storage for the yaw angles of tiles and object points for drawing
\             the current landscape view (high bytes)
\
\ ------------------------------------------------------------------------------
\
\ Tile angles are stored in the first 64 bytes (in two sets of 32 bytes), and
\ object point angles are stored in the last 32 bytes, from offset 64 onwards.
\
\ ******************************************************************************

.drawViewYawHi

 EQUB &01, &01, &02, &02, &03, &03, &04, &04
 EQUB &05, &05, &06, &06, &07, &07, &08, &08
 EQUB &09, &09, &0A, &0A, &0B, &0B, &0C, &0C
 EQUB &0C, &0D, &0D, &0E, &0E, &0F, &0F, &0F
 EQUB &01, &01, &02, &02, &03, &03, &04, &04
 EQUB &05, &05, &06, &06, &07, &07, &08, &08
 EQUB &09, &09, &0A, &0A, &0A, &0B, &0B, &0C
 EQUB &0C, &0D, &0D, &0E, &0E, &0E, &0F, &0F
 EQUB &0D, &0D, &0D, &0D, &0D, &0D, &0D, &0D
 EQUB &14, &15, &14, &12, &12, &13, &12, &11
 EQUB &11, &12, &11, &11, &10, &13, &11, &11
 EQUB &12, &11, &12, &11, &11, &12, &FF, &FF

\ ******************************************************************************
\
\       Name: GetHypotenuseAngle
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the angle of the hypotenuse in a right-angle triangle
\             given the two non-hypotenuse sides (i.e. two orthogonal axes)
\
\ ------------------------------------------------------------------------------
\
\ Calculate the tangent of the angle in a right-angle triangle, i.e. the angle
\ of the hypotenuse, given the two non-hypotenuse sides (typically orthogonal
\ coordinate axes).
\
\ The arguments are as follows:
\
\   * Absolute x-axis length in (xDeltaAbsoluteHi xDeltaLo)
\
\   * Sign of the x-axis length in xDeltaHi
\
\   * Absolute z-axis length in (zDeltaAbsoluteHi zDeltaLo)
\
\   * Sign of the z-axis length in zDeltaHi
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   xDeltaAbsoluteHi    High byte of the absolute x-axis length
\
\   xDeltaLo            Low byte of the absolute x-axis length
\
\   xDeltaHi            High byte of the signed x-axis length
\
\   zDeltaAbsoluteHi    High byte of the absolute z-axis length
\
\   zDeltaLo            Low byte of the absolute z-axis length
\
\   zDeltaHi            High byte of the signed z-axis length
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   angleTangent        The tangent of the angle of the hypotenuse
\
\   (angleHi angleLo)   The angle of the hypotenuse
\
\   (aHi aLo)           The length of the longer side in the triangle
\
\   (bHi bLo)           The length of the shorter side in the triangle
\
\ ******************************************************************************

.ghyp1

                        \ If we get here then A = 0

 STA angleTangent       \ Set angleTangent = 0

 STA angleLo            \ Set (angleHi angleLo) = 0
 STA angleHi

 RTS                    \ Return from the subroutine

.GetHypotenuseAngle

                        \ We are going to be calculating the angle in a
                        \ right-angled triangle with the following opposite and
                        \ adjacent sides:
                        \
                        \   (zDeltaAbsoluteHi zDeltaLo)
                        \
                        \   (xDeltaAbsoluteHi xDeltaLo)
                        \
                        \ We start by working out which is the longer of the two
                        \ non-hypotenuse sides

 LDA zDeltaAbsoluteHi   \ If zDeltaAbsoluteHi < xDeltaAbsoluteHi, jump to ghyp2
 CMP xDeltaAbsoluteHi
 BCC ghyp2

 BNE ghyp3              \ If zDeltaAbsoluteHi > xDeltaAbsoluteHi, jump to ghyp3

                        \ If we get here then the high bytes in zDeltaAbsoluteHi
                        \ and xDeltaAbsoluteHi are the same, so now we compare
                        \ the low bytes

 LDA zDeltaLo           \ If zDeltaLo >= xDeltaLo, jump to ghyp3
 CMP xDeltaLo
 BCS ghyp3

.ghyp2

                        \ If we get here then:
                        \
                        \   (zDeltaAbsoluteHi zDeltaLo) <
                        \                            (xDeltaAbsoluteHi xDeltaLo)

 LDA zDeltaAbsoluteHi   \ Set (bHi bLo) = (zDeltaAbsoluteHi zDeltaLo)
 STA bHi                \
 LDA zDeltaLo           \ So (bHi bLo) is the shorter side
 STA bLo

 LDA xDeltaLo           \ Set (aHi aLo) = (xDeltaAbsoluteHi xDeltaLo)
 STA aLo                \
 LDA xDeltaAbsoluteHi   \ So (aHi aLo) is the longer side
 STA aHi

 JMP ghyp5              \ Jump to ghyp5 to keep going

.ghyp3

                        \ If we get here then:
                        \
                        \   (zDeltaAbsoluteHi zDeltaLo) >=
                        \                            (xDeltaAbsoluteHi xDeltaLo)

 LDA xDeltaAbsoluteHi   \ Set (bHi bLo) = (xDeltaAbsoluteHi xDeltaLo)
 STA bHi                \
 LDA xDeltaLo           \ So (bHi bLo) is the shorter side
 STA bLo

 LDA zDeltaLo           \ Set (aHi aLo) = (zDeltaAbsoluteHi zDeltaLo)
 STA aLo                \
 LDA zDeltaAbsoluteHi   \ So (aHi aLo) is the longer side
 STA aHi

 ORA zDeltaLo           \ If both zDeltaAbsoluteHi and zDeltaLo are zero then
 BEQ ghyp1              \ (aHi aLo) = 0, so jump to ghyp1 to return from the
                        \ subroutine with the following:
                        \
                        \   * angleTangent = 0
                        \
                        \   * (angleHi angleLo) = 0

 LDA zDeltaAbsoluteHi   \ Set A to zDeltaAbsoluteHi once again

 JMP ghyp9              \ Jump to ghyp9 to keep going

.ghyp4

 ASL zDeltaLo           \ Shift (zDeltaAbsoluteHi zDeltaLo) left by one place to
 ROL zDeltaAbsoluteHi   \ scale it up

.ghyp5

                        \ If we jump here then:
                        \
                        \   * (zDeltaAbsoluteHi zDeltaLo) <
                        \                            (xDeltaAbsoluteHi xDeltaLo)
                        \
                        \   * (aHi aLo) is the longer side
                        \
                        \   * (bHi bLo) is the shorter side
                        \
                        \   * A = xDeltaAbsoluteHi
                        \
                        \ The last one means that the length of the x-axis side
                        \ is currently in (A xDeltaLo)

                        \ We start by shifting the lengths of both sides to the
                        \ left until bit 7 of A is set
                        \
                        \ As we know that (A xDeltaLo) is the longest side, this
                        \ scales both lengths up by the same amount until they
                        \ are as large as theycan be while still fitting into a
                        \ 16-bit number

 ASL xDeltaLo           \ Shift (A xDeltaLo) left by one place to scale it up
 ROL A

 BCC ghyp4              \ If we just shifted a zero out of bit 7 of (A xDeltaLo)
                        \ then jump back to ghyp4 to scale the x-axis length and
                        \ keep scaling until we shift a 1 out of bit 7, at which
                        \ point we have scaled (A xDeltaLo) as far as we can

 ROR A                  \ Shift the 1 back into bit 7 of (A xDeltaLo) to undo
 ROR xDeltaLo           \ the last left-shift, so (A xDeltaLo) is now as large
                        \ as it can be

 STA V                  \ Set V to the high byte of the scaled x-axis length

 LDA zDeltaLo           \ Set T to the low byte of the scaled z-axis length
 STA T

 LDA xDeltaLo           \ Set W to the low byte of the scaled x-axis length,
 AND #%11111100         \ with bits 0 and 1 cleared
 STA W                  \
                        \ Bits 0 and 1 of xDeltaLo will only be non-zero if the
                        \ x-axis length has not been scaled up or has only been
                        \ scaled up by one place, as scaling it up by two places
                        \ will clear these bits anyway
                        \
                        \ Is this a requirement for W so it can be passed to
                        \ GetAngleFromCoords ???

 LDA zDeltaAbsoluteHi   \ Set A to the high byte of the scaled z-axis length

                        \ So by this point we have:
                        \
                        \   * (A T) = the scaled z-axis length
                        \
                        \   * (V W) = the scaled x-axis length

 JSR GetAngleFromCoords \ Calculate the following angle:
                        \
                        \   (angleHi angleLo) = arctan( (A T) / (V W) )
                        \                     = arctan( z-axis / x-axis )
                        \
                        \ This works because the x-axis length is greater than
                        \ the z-axis length, so the x-axis is the adjacent side
                        \ and the z-axis is the opposite side

 LDA xDeltaHi           \ If xDeltaHi and zDeltaHi have different sign bits in
 EOR zDeltaHi           \ bit 7, then EOR'ing them will produce a 1, so jump to
 BMI ghyp6              \ ghyp6 to skip the following, as the sign of the angle
                        \ is already correct ???

 LDA #0                 \ Negate (angleHi angleLo) to give it the correct sign
 SEC
 SBC angleLo
 STA angleLo
 LDA #0
 SBC angleHi
 STA angleHi

.ghyp6

 LDA #%01000000         \ If bit 7 of xDeltaHi is clear then set A = %01000000
 BIT xDeltaHi           \ otherwise set A = %11000000
 BPL ghyp7
 LDA #%11000000

.ghyp7

 CLC                    \ Set angleHi = angleHi + A
 ADC angleHi            \
 STA angleHi            \ So this sets bits 6 and 7 of the angle correctly so it
                        \ is in the correct quadrant ???

 RTS                    \ Return from the subroutine

.ghyp8

 ASL xDeltaLo           \ Shift (xDeltaAbsoluteHi xDeltaLo) left by one place to
 ROL xDeltaAbsoluteHi   \ scale it up

.ghyp9

                        \ If we jump here then:
                        \
                        \   * (zDeltaAbsoluteHi zDeltaLo) >=
                        \                            (xDeltaAbsoluteHi xDeltaLo)
                        \
                        \   * (aHi aLo) is the longer side
                        \
                        \   * (bHi bLo) is the shorter side
                        \
                        \   * A = zDeltaAbsoluteHi
                        \
                        \ The last one means that the length of the z-axis side
                        \ is currently in (A zDeltaLo)

                        \ We start by shifting the lengths of both sides to the
                        \ left until bit 7 of A is set
                        \
                        \ As we know that (A zDeltaLo) is the longest side, this
                        \ scales both lengths up by the same amount until they
                        \ are as large as theycan be while still fitting into a
                        \ 16-bit number

 ASL zDeltaLo           \ Shift (A zDeltaLo) left by one place to scale it up
 ROL A

 BCC ghyp8              \ If we just shifted a zero out of bit 7 of (A zDeltaLo)
                        \ then jump back to ghyp8 to scale the z-axis length and
                        \ keep scaling until we shift a 1 out of bit 7, at which
                        \ point we have scaled (A zDeltaLo) as far as we can

 ROR A                  \ Shift the 1 back into bit 7 of (A zDeltaLo) to undo
 ROR zDeltaLo           \ the last left-shift, so (A zDeltaLo) is now as large
                        \ as it can be

 STA V                  \ Set V to the high byte of the scaled z-axis length

 LDA xDeltaLo           \ Set T to the low byte of the scaled x-axis length
 STA T

 LDA zDeltaLo           \ Set W to the low byte of the scaled z-axis length,
 AND #&FC               \ with bits 0 and 1 cleared
 STA W

 LDA xDeltaAbsoluteHi   \ Set A to the high byte of the scaled x-axis length

                        \ So by this point we have:
                        \
                        \   * (A T) = the scaled x-axis length
                        \
                        \   * (V W) = the scaled z-axis length

 JSR GetAngleFromCoords \ Calculate the following angle:
                        \
                        \   (angleHi angleLo) = arctan( (A T) / (V W) )
                        \                     = arctan( z-axis / x-axis )
                        \
                        \ This works because the z-axis length is greater than
                        \ the x-axis length, so the z-axis is the adjacent side
                        \ and the x-axis is the opposite side

 LDA xDeltaHi           \ If xDeltaHi and zDeltaHi have the same sign bits in
 EOR zDeltaHi           \ bit 7, then EOR'ing them will produce a 0, so jump to
 BPL ghyp10             \ ghyp10 to skip the following, as the sign of the angle
                        \ is already correct ???

 LDA #0                 \ Negate (angleHi angleLo) to give it the correct sign
 SEC
 SBC angleLo
 STA angleLo
 LDA #0
 SBC angleHi
 STA angleHi

.ghyp10

 LDA #%00000000         \ If bit 7 of zDeltaHi is clear then set A = %00000000
 BIT zDeltaHi           \ otherwise set A = %10000000
 BPL ghyp11
 LDA #%10000000

.ghyp11

 CLC                    \ Set angleHi = angleHi + A
 ADC angleHi
 STA angleHi            \ So this sets bits 6 and 7 of the angle correctly so it
                        \ is in the correct quadrant ???

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetPitchAngleDelta
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the pitch angle of a vector relative to an objects's
\             pitch angle
\
\ ------------------------------------------------------------------------------
\
\ This routine calculates the following pitch angle delta:
\
\   (pitchDeltaHi pitchDeltaLo) = (angleHi angleLo) - (objectPitchAngle 32)
\
\ where (angleHi angleLo) is the angle of this triangle:
\
\                                  _.-+             ^
\                              _.-   |             |
\                 vector   _.-       |         y-axis (up)
\                      _.-           |
\                  _.-               |  (A xDeltaLo)
\              _.-                   |
\           .- (angleHi angleLo)     |
\   viewer +--------------------------+
\           (hypotenuseHi hypotenuseLo)
\
\ This triangle is typically a viewing vector from the player's eyes to a
\ coordinate in the 3D world. The hypotenuse is the projection of the vector
\ down onto the ground (i.e. y = 0), and it has already been calculated by this
\ point from the x- and z-axis elements of the vector.
\
\ So this routine takes the hypotenuse length and the y-axis element of the
\ vector in (A xDeltaLo) and calculates the vector's pitch angle in (angleHi
\ angleLo), and then it calculates the difference between the vector's pitch
\ angle and the pitch angle for object #X (i.e. the viewer).
\
\ In other words, this calculates the pitch angle of the viewer's gaze towards
\ a coordinate (typically a tile), relative to the pitch angle of the viewer, so
\ that's relative to the current viewing direction. This is used to calculate
\ player-relative pitch angles for tiles in the current tile view, for example.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   (A xDeltaLo)        A vertical delta (i.e. a y-axis element)
\
\   hypotenuseHi        The high byte of the length of the hypotenuse
\
\   hypotenuseLo        The low byte of the length of the hypotenuse
\
\   X                   The object number
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   pitchDeltaHi        The high byte of the pitch angle delta
\
\   pitchDeltaLo        The low byte of the pitch angle delta
\
\ ******************************************************************************

.GetPitchAngleDelta

 STA xDeltaHi           \ Set (xDeltaHi xDeltaLo) to the vertical delta passed
                        \ to the routine

 TAY                    \ If the high byte is positive, jump to pdel1 to skip
 BPL pdel1              \ the following

 LDA #0                 \ Negate the result to make it positive, so we now have:
 SEC                    \
 SBC xDeltaLo           \   (A xDeltaLo) = |xDeltaHi xDeltaLo|
 STA xDeltaLo
 LDA #0
 SBC xDeltaHi

.pdel1

 STA xDeltaAbsoluteHi   \ Set xDeltaAbsoluteHi = |xDeltaHi|
                        \
                        \ So we now have the absolute delta in:
                        \
                        \   (xDeltaAbsoluteHi xDeltaLo)
                        \
                        \ and the original high byte of the signed delta is
                        \ still in xDeltaHi

 LDA hypotenuseLo       \ Set (zDeltaAbsoluteHi zDeltaLo) to the length of the
 STA zDeltaLo           \ hypotenuse (hypotenuseHi hypotenuseLo)
 LDA hypotenuseHi
 STA zDeltaAbsoluteHi

 LDA #0                 \ Set zDeltaHi to make the sign of zDelta positive in
 STA zDeltaHi           \ the call to GetHypotenuseAngle

 JSR GetHypotenuseAngle \ Calculate the angle of the hypotenuse in the triangle
                        \ with the following non-hypotenuse sides:
                        \
                        \   * (xDeltaHi xDeltaLo)
                        \
                        \   * (zDeltaHi zDeltaLo)
                        \
                        \ which are set as follows:
                        \
                        \   * (A xDeltaLo)
                        \
                        \   * (hypotenuseHi hypotenuseLo)
                        \
                        \ and return the angle in (angleHi angleLo), the tangent
                        \ in angleTangent, the length of the longer side in
                        \ (aHi aLo) and the length of the shorter side in
                        \ (bHi bLo)

 LDA angleLo            \ Set (A pitchDeltaLo) = (angleHi angleLo)
 SEC                    \                        - (objectPitchAngle 32)
 SBC #32                \
 STA pitchDeltaLo       \ starting with the low bytes

 LDA angleHi            \ And then the high bytes
 SBC objectPitchAngle,X

 PHP                    \ Store the status flags from the calculation

 LSR A                  \ Set (A pitchDeltaLo) = (A pitchDeltaLo) >> 4
 ROR pitchDeltaLo
 LSR A
 ROR pitchDeltaLo
 LSR A
 ROR pitchDeltaLo
 LSR A
 ROR pitchDeltaLo

 PLP                    \ If result is negative, set top four bits of A
 BPL pdel2
 ORA #%11110000

.pdel2

 STA pitchDeltaHi       \ Store result in (pitchDeltaHi pitchDeltaLo)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetHypotenuse
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the hypotenuse from an angle and two triangle sides with
\             one lookup and one multiplication (so without a square root)
\
\ ------------------------------------------------------------------------------
\
\ This routine calculates:
\
\   (hypotenuseHi hypotenuseLo) = (aHi aLo) + tan(theta / 2) * (bHi bLo)
\
\ for a triangle with angle theta, adjacent side a and opposite side b.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   angleTangent        The triangle angle theta
\
\   (aHi aLo)           The length of a, the adjacent side of the triangle
\
\   (bHi bLo)           The length of b, the opposite side of the triangle
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   Y                   Y is preserved
\
\   hypotenuseHi        The high byte of the length of the hypotenuse
\
\   hypotenuseLo        The low byte of the length of the hypotenuse
\
\ ******************************************************************************

.GetHypotenuse

 STY yStoreHypotenuse   \ Store Y in yStoreHypotenuse so it can be preserved
                        \ across calls to the routine

 LDA angleTangent       \ Set Y = angleTangent / 2
 LSR A                  \
 ADC #0                 \ The ADC instruction rounds the result to the nearest
 TAY                    \ integer
                        \
                        \ The value of angleTangent ranges from 0 to 255 to
                        \ represent the tangent of angles 0 to 45 degrees, but
                        \ the tanHalfAngle table ranges from 0 to 128 to
                        \ represent the same range of angles, so we have to
                        \ halve angleTangent so we can use it as an index into
                        \ the tanHalfAngle table to fetch the tangent of the
                        \ half angle

 LDA tanHalfAngle,Y     \ Set U = 2 * tan(theta / 2)
 STA U

 LDA bLo                \ Set (V T) = (bHi bLo)
 STA T
 LDA bHi
 STA V

 JSR Multiply8x16       \ Set (U T) = U * (V T) / 256
                        \           = 2 * tan(theta / 2) * (bHi bLo)

 LSR U                  \ Set (U T) = (U T) / 2
 ROR T                  \           = tan(theta / 2) * (bHi bLo)

 LDA T                  \ Calculate:
 CLC                    \
 ADC aLo                \  (hypotenuseHi hypotenuseLo)
 STA hypotenuseLo       \
 LDA U                  \     = (aHi aLo) + (U T)
 ADC aHi                \
 STA hypotenuseHi       \     = (aHi aLo) + tan(theta / 2) * (bHi bLo)

 LDY yStoreHypotenuse   \ Restore the value of Y from yStoreHypotenuse that we
                        \ stored at the start of the routine, so that it's
                        \ preserved

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: yStoreHypotenuse
\       Type: Variable
\   Category: Maths (Geometry)
\    Summary: Temporary storage for Y so it can be preserved through calls to
\             GetHypotenuse
\
\ ******************************************************************************

.yStoreHypotenuse

 EQUB 65                \ This value is workspace noise and has no meaning

\ ******************************************************************************
\
\       Name: GetRandomNumber
\       Type: Subroutine
\   Category: Maths (Arithmetic)
\    Summary: Set A to a random number
\
\ ******************************************************************************

.GetRandomNumber

                        \ We generate a new random number by taking our 24-bit
                        \ generator in randomGenerator(2 1 0) and adding it to
                        \ itself but shifted left by two places, so on each
                        \ iteration we do the following:
                        \
                        \   randomGenerator(2 1 0) += shiftGenerator(2 1 0)
                        \
                        \ We then return the high byte of randomGenerator(2 1 0)
                        \ as the next random number

 LDA randomGenerator    \ Set shiftGenerator(2 1 0) = randomGenerator(2 1 0)
 STA shiftGenerator
 LDA randomGenerator+1
 STA shiftGenerator+1
 LDA randomGenerator+2
 STA shiftGenerator+2

 ASL shiftGenerator     \ Shift shiftGenerator(2 1 0) left by two places
 ROL shiftGenerator+1
 ROL shiftGenerator+2
 ASL shiftGenerator
 ROL shiftGenerator+1
 ROL shiftGenerator+2

 LDA randomGenerator    \ Set randomGenerator(2 1 0) += shiftGenerator(2 1 0)
 CLC                    \
 ADC shiftGenerator     \ This also sets A to byte #2 of randomGenerator, so we
 STA randomGenerator    \ return this as the next random number
 LDA randomGenerator+1
 ADC shiftGenerator+1
 STA randomGenerator+1
 LDA randomGenerator+2
 ADC shiftGenerator+2
 STA randomGenerator+2

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: randomGenerator
\       Type: Variable
\   Category: Maths (Arithmetic)
\    Summary: A 24-bit random number generator that works independently from the
\             landscape seeds and with a much simpler generation algorithm
\
\ ******************************************************************************

.randomGenerator

 EQUB 1, 0, 0

\ ******************************************************************************
\
\       Name: shiftGenerator
\       Type: Variable
\   Category: Maths (Arithmetic)
\    Summary: Storage for randomGenerator(2 1 0) while we shift it left by two
\             places
\
\ ******************************************************************************

.shiftGenerator

 EQUB 1, 0, 0

\ ******************************************************************************
\
\       Name: DrawStars
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw 80 randomly positioned stars on the screen in colour 2
\             (white, yellow, cyan or red)
\
\ ******************************************************************************

.DrawStars

 LDA #%10000000         \ Set bit 7 of A to pass to the DrawRandomDots routine
                        \ so we draw random dots on-screen in colour 2 to look
                        \ like stars

 BNE DrawRandomDots     \ Jump to DrawRandomDots to draw 80 coloured dots on the
                        \ screen (this BNE is effectively a JMP as A is never
                        \ zero)

\ ******************************************************************************
\
\       Name: DrawBlackDots
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw 80 randomly positioned dots on the screen in colour 1 (black)
\
\ ******************************************************************************

.DrawBlackDots

 LDA #0                 \ Clear bit 7 of A to pass to the DrawRandomDots routine
                        \ so we draw random black dots on the screen to fade the
                        \ screen to black in a slowly decaying manner

                        \ Fall through into DrawRandomDots to draw 80 black dots
                        \ on the screen

\ ******************************************************************************
\
\       Name: DrawRandomDots
\       Type: Subroutine
\   Category: Graphics
\    Summary: Draw 80 randomly positioned dots on the screen
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The colour of the dots:
\
\                         * Bit 7 clear = colour 1 (black)
\
\                         * Bit 7 set = colour 2 (white, yellow, cyan or red)
\
\ ******************************************************************************

.DrawRandomDots

 STA dotColour          \ Set dotColour to the value of A from above, so we
                        \ draw coloured dots if bit 7 is set or black dots if
                        \ bit 7 is clear

 LDA #80                \ Set dotCounter = 80 so we draw 80 dots on the screen
 STA dotCounter

.dots1

 JSR GetRandomNumber    \ Set A to a random number

 STA screenAddr         \ Set the low byte of screenAddr(1 0) to the random
                        \ number in A

 LDA randomGenerator+1  \ Set randomPixel to the second byte of the random
 STA randomPixel        \ number generator, so this is also a random number

 AND #&1F               \ Reduce the random number to the range 0 to &1F

 CMP #&1E               \ If A >= &1E then loop back to dots1 to choose another
 BCS dots1              \ random number

 STA screenAddr+1       \ Set the high byte of screenAddr(1 0) to A, so we now
                        \ have screenAddr(1 0) set to a random number in the
                        \ range 0 to &1DFF

                        \ We can now add this to the address of the start of
                        \ screen memory in viewScreenAddr(1 0) to get the
                        \ address of a random pixel byte within screen memory

 LDA viewScreenAddr     \ Set screenAddr(1 0) = viewScreenAddr(1 0)
 CLC                    \                       + screenAddr(1 0)
 ADC screenAddr
 STA screenAddr
 LDA viewScreenAddr+1
 ADC screenAddr+1

 CMP #&80               \ If the high byte in A >= &80 then the new address is
 BCC dots2              \ past the end of screen memory, so subtract &20 from
 SBC #&20               \ the high byte so the address wraps around within the
                        \ range of screen memory between &6000 and &8000

.dots2

 STA screenAddr+1       \ Store the high byte of the result, so we now have:
                        \
                        \   screenAddr(1 0) = viewScreenAddr(1 0)
                        \                     + screenAddr(1 0)
                        \
                        \ So screenAddr(1 0) is the address of a random pixel
                        \ byte within screen memory

 LDA randomPixel        \ Take bits 6 and 7 of randomPixel and put them into
 ROL A                  \ bits 0 and 1 of X (with all the other bits clear), so
 ROL A                  \ X is a random number in the range 0 to 3 that we can
 ROL A                  \ use as the pixel number within the pixel byte for the
 AND #%00000011         \ dot we want to draw
 TAX

 LDY #0                 \ Set Y = 0 so we can use (screenAddr),Y below to behave
                        \ like AND (screenAddr) or STA (screenAddr)

 LDA pixelBitMask,X     \ Take the existing pixel byte from screenAddr(1 0) and
 EOR #%11111111         \ clear the two bits for pixel number X (the EOR inverts
 AND (screenAddr),Y     \ the mask in pixelBitMask so that AND'ing the mask will
                        \ clear pixel X while leaving the other pixels alone

 ORA pixelByteColour1,X \ Change the two bits for pixel X into colour 1 (%01),
                        \ which is black, so that drawing lots of dots will
                        \ slowly turn the screen to black

 BIT dotColour          \ If bit 7 of dotColour is set, flip the two bits of the
 BPL dots3              \ pixel so they are drawn in colour 2 (%10), for when we
 EOR pixelBitMask,X     \ we want to draw coloured stars instead

.dots3

 STA (screenAddr),Y     \ Store the updated pixel byte in screenAddr(1 0) to
                        \ draw a black dot or a coloured star on-screen

 DEC dotCounter         \ Decrement the dot counter

 BNE dots1              \ Loop back until we have drawn all 80 dots

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: dotCounter
\       Type: Variable
\   Category: Graphics
\    Summary: A counter for the number of dots drawn in the DrawRandomDots
\             routine
\
\ ******************************************************************************

.dotCounter

 EQUB 0

\ ******************************************************************************
\
\       Name: dotColour
\       Type: Variable
\   Category: Graphics
\    Summary: A flag that determines the colour of the dots drawn by the
\             DrawRandomDots routine
\
\ ******************************************************************************

.dotColour

 EQUB 0

\ ******************************************************************************
\
\       Name: pixelByteColour1
\       Type: Variable
\   Category: Sights
\    Summary: A table for converting a pixel number in the range 0 to 3 into a
\             screen mode 5 pixel byte with that pixel set to colour 1 (%01)
\
\ ******************************************************************************

.pixelByteColour1

 EQUB %00001000         \ Pixel byte with pixel 0 set to colour 1

 EQUB %00000100         \ Pixel byte with pixel 1 set to colour 1

 EQUB %00000010         \ Pixel byte with pixel 2 set to colour 1

 EQUB %00000001         \ Pixel byte with pixel 3 set to colour 1

\ ******************************************************************************
\
\       Name: SetScannerUpdate
\       Type: Subroutine
\   Category: Scanner and energy icons
\    Summary: Set the scanner update status and delay for 40 empty loops of 256
\             iterations each (i.e. 10,240 loops)
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The new value for scannerUpdate (this routine is only
\                       ever called from the main game loop with A = 0, so this
\                       sets scannerUpdate to zero to prevent scanner updates)
\
\ ******************************************************************************

.SetScannerUpdate

 STA scannerUpdate      \ Set scannerUpdate to the new value in A

 LDX #40                \ We now perform a delay with a nested loop, so set X
                        \ as an outer loop counter
                        \
                        \ We use Y as an inner loop counter to count down from
                        \ 255 to 0, though the first loop will depend on the
                        \ initial value of Y, which isn't explicitly set to
                        \ anything before the routine is called

.scup1

 DEY                    \ Decrement the inner loop counter in Y

 BNE scup1              \ Loop back until Y reaches zero

 DEX                    \ Decrement the inner loop counter in X

 BNE scup1              \ Loop back until X reaches zero

 RTS                    \ Return from the subroutine

 EQUB &FF, &FF          \ These bytes appear to be unused
 EQUB &FF, &FF

\ ******************************************************************************
\
\       Name: PrintCharacter
\       Type: Subroutine
\   Category: Text
\    Summary: Print a single-byte VDU command or character from a text token,
\             optionally printing a drop shadow if the character is alphanumeric
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The one-byte character to be printed
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   X                   X is preserved
\
\ ******************************************************************************

.PrintCharacter

 BIT textDropShadow     \ If bit 7 of textDropShadow is set, jump to byte2 to
 BMI byte2              \ print the character in A as-is (i.e. without a drop
                        \ shadow if it is alphanumeric)

 CMP #' '               \ If the character in A is a control character, jump to
 BCC byte2              \ byte2 to print the character as-is

 CMP #127               \ If the character in A is a top-bit-set character, jump
 BCS byte2              \ jump to byte2 to print the character as-is

                        \ If we get here then bit 7 of textDropShadow is clear
                        \ and the character in A is alphanumeric, so now we
                        \ print the character with a drop shadow
                        \
                        \ We do this by printing the sequence of VDU commands at
                        \ vduShadowRear and vduShadowFront, which produce the
                        \ drop shadow effect
                        \
                        \ The drop shadow is printed by first printing the VDU
                        \ commands in vduShadowRear, to print the rear character
                        \ in yellow, and then in vduShadowFront, to print the
                        \ front character in red or cyan
                        \
                        \ The rear character is offset down from the front
                        \ character by four graphics units, which equates to an
                        \ offset of one pixel in mode 5
                        \
                        \ The VDU commands are printed backwards, because that
                        \ makes the loop condition slightly simpler, and it also
                        \ means we can poke the character to print into the
                        \ start of each block of VDU commands, knowing that they
                        \ will then be printed last in each VDU sequence

 STA vduShadowFront     \ Insert the character to be printed into the sequence
 STA vduShadowRear      \ of VDU commands at vduShadowRear and vduShadowFront,
                        \ so that they print the required character with a drop
                        \ shadow

 TXA                    \ Store X on the stack so we can preserve it
 PHA

 LDX #22                \ The vduShadowRear and vduShadowFront variables contain
                        \ a total of 23 VDU command bytes, so set a byte counter
                        \ in X so we can work through them from the end of
                        \ vduShadowRear backwards to the start of vduShadowFront

.byte1

 LDA vduShadowFront,X   \ Print the X-th character from the vduShadowRear and
 JSR OSWRCH             \ vduShadowFront variables

 DEX                    \ Decrement the byte counter

 BPL byte1              \ Loop back until we have printed all 23 command bytes

 PLA                    \ Retrieve X from the stack so it is preserved across
 TAX                    \ calls to the routine

 RTS                    \ Return from the subroutine

.byte2

 JMP OSWRCH             \ We jump here if drop shadows are disabled, or if A is
                        \ not alphanumeric, in which case print the character in
                        \ A and return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: PrintVduCharacter
\       Type: Subroutine
\   Category: Text
\    Summary: Print a one-byte character from a text token or a multi-byte
\             VDU 25 command
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The character to be printed
\
\   Y                   The offset of the current character within the text
\                       token being printed
\
\ ******************************************************************************

.PrintVduCharacter

 CMP #25                \ If the character in A = 25, jump to prin2 to print a
 BEQ prin2              \ six-byte command in the form VDU 25, n, x; y;
                        \
                        \ We print the VDU 25 commands in its own loop because
                        \ the 16-bit arguments to the command (x and y) might
                        \ contain &FF, and we don't want this to be
                        \ misidentified as the end of the text token

 JMP PrintCharacter     \ Otherwise jump to PrintCharacter to print the single-
                        \ byte VDU command or character in A, returning from the
                        \ subroutine using a tail call

.prin1

 INY                    \ Increment the offset of the character being printed to
                        \ move on to the next character in the token

 LDA tokenBase,Y        \ Set A to the next character to print

.prin2

 JSR OSWRCH             \ Print the next character in the VDU 25 command (we
                        \ jump here from above with A = 25, which starts off
                        \ the six-byte VDU sequence)

 DEC vduCounter         \ Decrement the byte counter in vduCounter, which is
                        \ always 6 when we jump into this loop

 BNE prin1

 LDA #6                 \ Reset the byte counter in vduCounter to 6, ready for
 STA vduCounter         \ the next time we perform a VDU 25 command

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: vduCounter
\       Type: Variable
\   Category: Text
\    Summary: The number of bytes in a VDU 25, n, x; y; command
\
\ ******************************************************************************

.vduCounter

 EQUB 6

\ ******************************************************************************
\
\       Name: tokenOffset
\       Type: Variable
\   Category: Text
\    Summary: Address offsets for the text tokens (each offset in the table is
\             the offset of the token from tokenBase)
\
\ ******************************************************************************

.tokenOffset

 EQUB token0 - tokenBase
 EQUB token1 - tokenBase
 EQUB token2 - tokenBase
 EQUB token3 - tokenBase
 EQUB token4 - tokenBase
 EQUB token5 - tokenBase
 EQUB token6 - tokenBase
 EQUB token7 - tokenBase
 EQUB token8 - tokenBase
 EQUB token9 - tokenBase
 EQUB token10 - tokenBase
 EQUB token11 - tokenBase
 EQUB token12 - tokenBase
 EQUB token13 - tokenBase
 EQUB token14 - tokenBase
 EQUB token15 - tokenBase
 EQUB token16 - tokenBase
 EQUB token17 - tokenBase

.tokenBase

\ ******************************************************************************
\
\       Name: vduShadowFront
\       Type: Variable
\   Category: Text
\    Summary: VDU commands for printing the front character of a drop shadow
\
\ ------------------------------------------------------------------------------
\
\ The VDU commands below are printed by working backwards through the table, so
\ the character to be printed is actually the first entry in the table.
\
\ A drop shadow is printed by first printing the VDU commands in vduShadowRear,
\ to print the rear character in yellow, and then in vduShadowFront, to print
\ the front character in red or cyan. The rear character is offset down from the
\ front character by four graphics units, which equates to an offset of one
\ pixel in mode 5.
\
\ ******************************************************************************

.vduShadowFront

 EQUB "C"               \ 9. Print the character in red or cyan, for the front
                        \ character of the drop shadow
                        \
                        \ The "C" is replaced by the character to be printed

 EQUB 2, 0, 18          \ 8. VDU 18, 0, 2
                        \
                        \ Set the foreground colour to colour 2 (red or cyan,
                        \ depending on the current palette)
                        \
                        \ The "2" is replaced by the colour to be drawn

 EQUB &00, &04          \ 7. VDU 25, 0, 0; 4;
 EQUW 0                 \
 EQUB 0, 25             \ Move the graphics cursor relative to the last position
                        \ by (0, 4), so we move up the screen by four units, or
                        \ one pixel in mode 5

 EQUB 8                 \ 6. VDU 8
                        \
                        \ Backspace the cursor by one character, so it is on top
                        \ of the yellow character that we just printed in
                        \ vduShadowRear

\ ******************************************************************************
\
\       Name: vduShadowRear
\       Type: Variable
\   Category: Text
\    Summary: VDU commands for printing the rear character of a drop shadow
\
\ ------------------------------------------------------------------------------
\
\ The VDU commands below are printed by working backwards through the table, so
\ the character to be printed is actually the first entry in the table.
\
\ A drop shadow is printed by first printing the VDU commands in vduShadowRear,
\ to print the rear character in yellow, and then in vduShadowFront, to print
\ the front character in red or cyan. The rear character is offset down from the
\ front character by four graphics units, which equates to an offset of one
\ pixel in mode 5.
\
\ ******************************************************************************

.vduShadowRear

 EQUB "C"               \ 5. Print the character in yellow, for the rear
                        \ character of the drop shadow
                        \
                        \ The "C" is replaced by the character to be printed

 EQUB 3, 0, 18          \ 4. VDU 18, 0, 3
                        \
                        \ Set the foreground colour to colour 3 (yellow)
                        \
                        \ The "3" is replaced by the colour to be drawn

 EQUB &FF, &FC          \ 3. VDU 25, 0, 0; -4;
 EQUW 0                 \
 EQUB 0, 25             \ Move the graphics cursor relative to the last position
                        \ by (0, -4), so we move down the screen by four units,
                        \ or one pixel in mode 5

 EQUB 127               \ 2. Print a backspace to move the cursor back over the
                        \ top of the space we just printed

 EQUS " "               \ 1. Print a space to clear the screen for the new drop
                        \ shadow character

\ ******************************************************************************
\
\       Name: token0
\       Type: Variable
\   Category: Text
\    Summary: Background colour blue, print "PRESS ANY KEY" at (64, 100), set
\             text background to black
\
\ ******************************************************************************

.token0

 EQUB 200 + 10          \ Text token 10: Configure text to be printed at the
                        \ graphics cursor and set the background colour to
                        \ colour 0 (blue)

 EQUB 200 + 12          \ Text token 12: Move graphics cursor to (64, 100)

 EQUB 200 + 17          \ Text token 17: Print "PRESS ANY KEY"

 EQUB 17, 129           \ VDU 17, 129
                        \
                        \ Set text background to colour 1 (black)

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token1
\       Type: Variable
\   Category: Text
\    Summary: Print 13 spaces at (64, 100), print "LANDSCAPE NUMBER?" at
\             (64, 768), switch to text cursor, move text cursor to (5, 27)
\
\ ******************************************************************************

.token1

 EQUB 200 + 12          \ Text token 12: Move graphics cursor to (64, 100)

 EQUB 200 + 15          \ Text token 15: Print five spaces

 EQUB 200 + 15          \ Text token 15: Print five spaces

 EQUB 200 + 16          \ Text token 16: Print three spaces

 EQUB 200 + 7           \ Text token 7: Move the graphics cursor to (64, 768)

 EQUB 200 + 13          \ Text token 13: Print "LANDSCAPE"

 EQUS " NUMBER?"        \ Print " NUMBER?"

 EQUB 4                 \ VDU 4
                        \
                        \ Write text at the text cursor

 EQUB 31, 5, 27         \ VDU 31, 5, 27
                        \
                        \ Move the text cursor to (5, 27)

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token2
\       Type: Variable
\   Category: Text
\    Summary: Background colour blue, print "SECRET ENTRY CODE?" at (64, 768),
\             switch to text cursor, move text cursor to (2, 27)
\
\ ******************************************************************************

.token2

 EQUB 200 + 10          \ Text token 10: Configure text to be printed at the
                        \ graphics cursor and set the background colour to
                        \ colour 0 (blue)

 EQUB 200 + 7           \ Text token 7: Move the graphics cursor to (64, 768)

 EQUB 200 + 14          \ Text token 14: Print "SECRET ENTRY CODE"

 EQUS "?"               \ Print "?"

 EQUB 4                 \ VDU 4
                        \
                        \ Write text at the text cursor

 EQUB 31, 3, 27         \ VDU 31, 3, 27
                        \
                        \ Move the text cursor to (2, 27)

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token3
\       Type: Variable
\   Category: Text
\    Summary: Background colour blue, print "WRONG SECRET CODE" at (64, 768),
\             print "PRESS ANY KEY" at (64, 100), set text background to black
\
\ ******************************************************************************

.token3

 EQUB 200 + 10          \ Text token 10: Configure text to be printed at the
                        \ graphics cursor and set the background colour to
                        \ colour 0 (blue)

 EQUB 200 + 7           \ Text token 7: Move the graphics cursor to (64, 768)

 EQUS "WRONG SECRET "   \ Print "WRONG SECRET CODE"
 EQUS "CODE"

 EQUB 200 + 0           \ Text token 0: Background colour blue, print "PRESS
                        \ ANY KEY" at (64, 100), set text background to black

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token4
\       Type: Variable
\   Category: Text
\    Summary: Background colour black, print "PRESS ANY KEY" at (192, 64), print
\             "LANDSCAPE" two chars right of (64, 768), move cursor right
\
\ ******************************************************************************

.token4

 EQUB 200 + 11          \ Text token 11: Configure text to be printed at the
                        \ graphics cursor and set the background colour to
                        \ colour 1 (black)

 EQUB 200 + 9           \ Text token 9: Move the graphics cursor to (192, 64)

 EQUB 200 + 17          \ Text token 17: Print "PRESS ANY KEY"

 EQUB 200 + 7           \ Text token 7: Move the graphics cursor to (64, 768)

 EQUB 9, 9              \ VDU 9, 9
                        \
                        \ Move the cursor right by two characters

 EQUB 200 + 13          \ Text token 13: Print "LANDSCAPE"

 EQUB 9                 \ VDU 9
                        \
                        \ Move the cursor right by one character, so it moves on
                        \ to the next character

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token5
\       Type: Variable
\   Category: Text
\    Summary: Text token 5: Print "SECRET ENTRY CODE" at (64, 768), "LANDSCAPE"
\             at (192, 704), move cursor right
\
\ ******************************************************************************

.token5

 EQUB 200 + 7           \ Text token 7: Move the graphics cursor to (64, 768)

 EQUB 200 + 14          \ Text token 14: Print "SECRET ENTRY CODE"

 EQUB 200 + 8           \ Text token 8: Move the graphics cursor to (192, 704)

 EQUB 200 + 13          \ Text token 13: Print "LANDSCAPE"

 EQUB 9                 \ VDU 9
                        \
                        \ Move the cursor right by one character, so it moves on
                        \ to the next character

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token6
\       Type: Variable
\   Category: Text
\    Summary: Text token 6: Print "PRESS ANY KEY" at (64, 100)
\
\ ******************************************************************************

.token6

 EQUB 200 + 12          \ Text token 12: Move graphics cursor to (64, 100)

 EQUB 200 + 17          \ Text token 17: Print "PRESS ANY KEY"

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token7
\       Type: Variable
\   Category: Text
\    Summary: Text token 7: Move the graphics cursor to (64, 768)
\
\ ******************************************************************************

.token7

 EQUB 25, 4             \ VDU 25, 4, 64; 768;
 EQUW 64                \
 EQUW 768               \ Move graphics cursor to absolute position (64, 768)

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token8
\       Type: Variable
\   Category: Text
\    Summary: Text token 8: Move the graphics cursor to (192, 704)
\
\ ******************************************************************************

.token8

 EQUB 25, 4             \ VDU 25, 4, 192; 704;
 EQUW 192               \
 EQUW 704               \ Move graphics cursor to absolute position (192, 704)

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token9
\       Type: Variable
\   Category: Text
\    Summary: Text token 9: Move the graphics cursor to (192, 64)
\
\ ******************************************************************************

.token9

 EQUB 25, 4             \ VDU 25, 4, 192; 64;
 EQUW 192               \
 EQUW 64                \ Move graphics cursor to absolute position (192, 64)

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token10
\       Type: Variable
\   Category: Text
\    Summary: Text token 10: Configure text to be printed at the graphics cursor
\             and set the background colour to colour 0 (blue)
\
\ ******************************************************************************

.token10

 EQUB 5                 \ VDU 5
                        \
                        \ Write text at the graphics cursor rather than the text
                        \ cursor

 EQUB 18, 0, 128        \ VDU 18, 0, 128
                        \
                        \ Set the background colour to colour 0 (blue)

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token11
\       Type: Variable
\   Category: Text
\    Summary: Text token 11: Configure text to be printed at the graphics cursor
\             and set the background colour to colour 1 (black)
\
\ ******************************************************************************

.token11

 EQUB 5                 \ VDU 5
                        \
                        \ Write text at the graphics cursor rather than the text
                        \ cursor

 EQUB 18, 0, 129        \ VDU 18, 0, 129
                        \
                        \ Set the background colour to colour 1 (black)

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token12
\       Type: Variable
\   Category: Text
\    Summary: Text token 12: Move graphics cursor to (64, 100)
\
\ ******************************************************************************

.token12

 EQUB 25, 4             \ VDU 25, 4, 64; 160;
 EQUW 64                \
 EQUW 160               \ Move graphics cursor to absolute position (64, 100)

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token13
\       Type: Variable
\   Category: Text
\    Summary: Text token 13: Print "LANDSCAPE"
\
\ ******************************************************************************

.token13

 EQUS "LANDSCAPE"

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token14
\       Type: Variable
\   Category: Text
\    Summary: Text token 14: Print "SECRET ENTRY CODE"
\
\ ******************************************************************************

.token14

 EQUS "SECRET ENTRY CODE"

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token15
\       Type: Variable
\   Category: Text
\    Summary: Text token 15: Print five spaces
\
\ ******************************************************************************

.token15

 EQUS "     "

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token16
\       Type: Variable
\   Category: Text
\    Summary: Text token 16: Print three spaces
\
\ ******************************************************************************

.token16

 EQUS "   "

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: token17
\       Type: Variable
\   Category: Text
\    Summary: Text token 17: Print "PRESS ANY KEY"
\
\ ******************************************************************************

.token17

 EQUS "PRESS ANY KEY"

 EQUB &FF               \ End of token

\ ******************************************************************************
\
\       Name: musicData
\       Type: Variable
\   Category: Sound
\    Summary: Data for the game's music
\
\ ------------------------------------------------------------------------------
\
\ Music data is as follows:
\
\   * If a value is 200 + x, then the sound counter for all the following notes
\     is set to 4 * x, measured in 1/50 second (i.e. calls to the interrupt
\     handler)
\
\   * Otherwise the value is the pitch of the note to play
\
\ Each note is played on a separate tone channel, working through channels 1 to
\ 3 in sequence.
\
\ Setting the sound counter stops ProcessSound from doing anything until the
\ counter runs down. This means that the last three notes are played together,
\ so we can play three-note chords by playing two notes with a counter of zero,
\ followed by a third note with the counter set to the duration of the chord.
\
\ Setting the counter to zero for the last chord in a piece of music ensures
\ that the last chords plays until it naturally decays according to the sound
\ envelope for sound #3.
\
\ ******************************************************************************

.musicData

                        \ Music data offset 0: Hyperspace

 EQUB 200 + 0           \ Chord 1 = 8, 36, 36 with sound counter 6 * 4 = 24
 EQUB 8
 EQUB 36
 EQUB 200 + 6
 EQUB 36

 EQUB 200 + 0           \ Chord 2 = 20, 48, 48 with sound counter 6 * 4 = 24
 EQUB 20
 EQUB 48
 EQUB 200 + 6
 EQUB 48

 EQUB 200 + 0           \ Chord 3 = 28, 56, 56 with sound counter 6 * 4 = 24
 EQUB 28
 EQUB 56
 EQUB 200 + 6
 EQUB 56

 EQUB 200 + 0           \ Chord 4 = 0, 28, 28 with sound counter 6 * 4 = 24
 EQUB 0
 EQUB 28
 EQUB 200 + 6
 EQUB 28

 EQUB 200 + 0           \ Chord 5 = 8, 36, 36 with sound counter 0
 EQUB 8
 EQUB 36
 EQUB 36

 EQUB &FF               \ End of music data

                        \ Music data offset 25: Transfer into a new robot
                        \
                        \ Note that the transfer music plays the U-turn music as
                        \ its last two chords, as there is no terminator after
                        \ chord 2 below

 EQUB 200 + 0           \ Chord 1 = 8, 36, 36 with sound counter 6 * 4 = 24
 EQUB 8
 EQUB 36                
 EQUB 200 + 6
 EQUB 36

 EQUB 200 + 0           \ Chord 2 = 20, 48, 48 with sound counter 6 * 4 = 24
 EQUB 20
 EQUB 48    
 EQUB 200 + 6
 EQUB 48

 EQUB 200 + 0           \ Chord 2 = 16, 44, 44 with sound counter 6 * 4 = 24
 EQUB 16
 EQUB 44
 EQUB 200 + 6
 EQUB 44

                        \ Music data offset 25: U-turn

 EQUB 200 + 0           \ Chord 1 = 0, 28, 28 with sound counter 6 * 4 = 24
 EQUB 0
 EQUB 28
 EQUB 200 + 6
 EQUB 28

 EQUB 200 + 0           \ Chord 2 = 8, 36, 36 with sound counter 0
 EQUB 8
 EQUB 36
 EQUB 36

 EQUB &FF               \ End of music data

                        \ Music data offset 50: Game over

 EQUB 200 + 4           \ Note 1 = 8 with sound counter 4 * 4 = 16
 EQUB 8

 EQUB 36                \ Note 2 = 36 with sound counter 4 * 4 = 16

 EQUB 64                \ Note 3 = 64 with sound counter 4 * 4 = 16

 EQUB 68                \ Note 4 = 68 with sound counter 4 * 4 = 16

 EQUB 200 + 15          \ Note 5 = 8 with sound counter 15 * 4 = 60
 EQUB 84

 EQUB 200 + 1           \ Arpeggiated chord of five short notes, each with
 EQUB 104               \ sound counter 1 * 4 = 4:g
 EQUB 84                \
 EQUB 68                \ 104, 84, 68, 64, 36
 EQUB 64
 EQUB 36

 EQUB 200 + 12          \ Final note = 8 with counter 15 * 4 = 48
 EQUB 8

 EQUB &FF               \ End of music data

                        \ Music data offset 66: Landscape successfully finished

 EQUB 200 + 1           \ Chord 1 = 8, 36, 36 with sound counter 12 * 4 = 48 and
 EQUB 8                 \ the first two notes each introduced with a counter of
 EQUB 36                \ 1 * 4 = 4
 EQUB 200 + 12
 EQUB 36

 EQUB 200 + 1           \ Chord 2 = 0, 28, 28 with sound counter 5 * 4 = 20 and
 EQUB 0                 \ the first two notes each introduced with a counter of
 EQUB 28                \ 1 * 4 = 4
 EQUB 200 + 5
 EQUB 28

 EQUB 200 + 1           \ Chord 3 = 28, 56, 56 with sound counter 6 * 4 = 24 and
 EQUB 28                \ the first two notes each introduced with a counter of
 EQUB 56                \ 1 * 4 = 4
 EQUB 200 + 6
 EQUB 56

 EQUB 200 + 1           \ Chord 4 = 20, 48, 48 with sound counter 7 * 4 = 28 and
 EQUB 20                \ the first two notes each introduced with a counter of
 EQUB 48                \ 1 * 4 = 4
 EQUB 200 + 7
 EQUB 48

 EQUB 200 + 1           \ Chord 5 = 16, 28, 28 with sound counter 9 * 4 = 36 and
 EQUB 16                \ the first two notes each introduced with a counter of
 EQUB 28                \ 1 * 4 = 4
 EQUB 200 + 9
 EQUB 28

 EQUB 200 + 1           \ Chord 6 = 8, 36, 36 with sound counter 1 * 4 = 1 and 
 EQUB 8                 \ the first two notes each introduced with a counter of
 EQUB 36                \ 1 * 4 = 4
 EQUB 36

 EQUB &FF               \ End of music data

\ ******************************************************************************
\
\       Name: iconData
\       Type: Variable
\   Category: Graphics
\    Summary: Screen mode 5 bitmap data for the ten icons that make up the
\             energy icon and scanner row at the top of the screen
\
\ ******************************************************************************

.iconData

 EQUB &0F, &0F, &0F, &0F, &0F, &0F, &0F, &0F    \ Icon #0: Blank

 EQUB &6F, &0F, &00, &06, &09, &09, &0F, &0F    \ Icon #1: Robot

 EQUB &2F, &2F, &7A, &7A, &FA, &2D, &0F, &0F    \ Icon #2: Tree (left)

 EQUB &0F, &0F, &0F, &0F, &8F, &0F, &0F, &0F    \ Icon #3: Tree (right)

 EQUB &0F, &0F, &78, &D2, &87, &87, &0F, &0F    \ Icon #4: Boulder (left)

 EQUB &0F, &0F, &0F, &87, &87, &87, &0F, &0F    \ Icon #5: Boulder (right)

 EQUB &6F, &0F, &FF, &9F, &6F, &6F, &0F, &0F    \ Icon #6: High-energy robot

 EQUB &1E, &1E, &1E, &1E, &1E, &1E, &0F, &0F    \ Icon #7: Scanner box (left)

 EQUB &F0, &0F, &0F, &0F, &0F, &F0, &0F, &0F    \ Icon #8: Scanner box (middle)

 EQUB &87, &87, &87, &87, &87, &87, &0F, &0F    \ Icon #9: Scanner box (right)

\ ******************************************************************************
\
\       Name: soundData
\       Type: Variable
\   Category: Sound
\    Summary: OSWORD blocks for making the various game sounds
\
\ ------------------------------------------------------------------------------
\
\ Sound data. To make a sound, the MakeSound routine passes the bytes in this
\ table to OSWORD 7. These bytes are the OSWORD equivalents of the parameters
\ passed to the SOUND keyword in BASIC. The parameters have these meanings:
\
\   channel/flush, amplitude (or envelope number if 1-4), pitch, duration
\
\ where each value consists of two bytes, with the low byte first and the high
\ byte second.
\
\ For the channel/flush parameter, the top nibble of the low byte is the flush
\ control (where a flush control of 0 queues the sound, and a flush control of
\ 1 makes the sound instantly), while the bottom nibble of the low byte is the
\ channel number. When written in hexadecimal, the first figure gives the flush
\ control, while the second is the channel (so &13 indicates flush control = 1
\ and channel = 3).
\
\ ******************************************************************************

.soundData

 EQUB &10, &00          \ Sound data block #0: SOUND &10, 1, 7, 5
 EQUB &01, &00          \
 EQUB &07, &00          \ Used for the first part of sounds #0 (???), #1 (???)
 EQUB &05, &00          \ and #6 (game over)

 EQUB &11, &00          \ Sound data block #1: SOUND &11, 0, 120, 10
 EQUB &00, &00          \
 EQUB &78, &00          \ Used for the second part of sounds #0 (???), #1 (???)
 EQUB &0A, &00          \ and #6 (game over)

 EQUB &12, &00          \ Sound data block #2: SOUND &12, 3, 34, 20
 EQUB &03, &00          \
 EQUB &22, &00          \ Used for sounds #3 (music) and #4 (???)
 EQUB &14, &00

 EQUB &13, &00          \ Sound data block #3: SOUND &13, 4, 144, 20
 EQUB &04, &00          \
 EQUB &90, &00          \ Used for sound #5 (ping)
 EQUB &14, &00

 EQUB &10, &00          \ Sound data block #4: SOUND &10, 2, 4, 40
 EQUB &02, &00          \
 EQUB &04, &00          \ Used for sound #2 (create/absorb object white noise)
 EQUB &28, &00

\ ******************************************************************************
\
\       Name: envelopeData
\       Type: Variable
\   Category: Sound
\    Summary: Data for the six sound envelopes
\
\ ------------------------------------------------------------------------------
\
\ There are six sound envelopes defined in The Sentinel.
\
\   * Envelope 0 is used for sounds #0 and #1 (???).
\
\   * Envelope 1 is used for sound #2 (create/absorb object white noise).
\
\   * Envelope 2 is used for sound #3 (???).
\
\   * Envelope 3 is used for sound #4 (???).
\
\   * Envelope 4 is used for sound #5 (ping).
\
\   * Envelope 5 is used for sound #6 (game over).
\
\ ******************************************************************************

.envelopeData

 EQUB 1, 2, 0, 0, 0, 0, 0, 0, 20, 0, -20, -20, 120, 120

 EQUB 2, 4, 0, 0, 0, 0, 0, 0, 2, -1, 0, 0, 120, 120

 EQUB 4, 2, 1, -1, 0, 1, 1, 8, 120, -1, 0, -1, 120, 8

 EQUB 3, 1, 6, -6, 0, 1, 1, 0, 1, -1, 0, 0, 120, 8

 EQUB 4, &82, 1, -1, 0, 2, 1, 7, 120, -6, -2, -2, 120, 0

 EQUB 1, 1, 0, 0, 0, 0, 0, 0, 120, -120, -1, -1, 120, 0

 EQUB 0, 0, 0, 0        \ These bytes appear to be unused

\ ******************************************************************************
\
\       Name: sin
\       Type: Variable
\   Category: Maths (Geometry)
\    Summary: Table for sine values
\
\ ------------------------------------------------------------------------------
\
\ This table contains sine values for a quarter of a circle, i.e. for the range
\ 0 to 90 degrees, or 0 to PI/2 radians. The table contains values for indexes
\ 0 to 127, which cover the quarter from 0 to PI/2 radians. Entry X in the table
\ is therefore (X / 128) * (PI / 2) radians of the way round the quarter circle,
\ so the table at index X contains the sine of this value.
\
\ The value of sine across the quarter circle ranges from 0 to 1:
\
\   sin(0) = 0
\
\   sin(90) = sin(PI/2) = 1
\
\ It might help to think of sin(X) as an integer ranging from 0 to 256 across
\ the quarter circle, so entry X in this table contains sin(X) * 256, where X
\ ranges from 0 to 128 over the course of a quarter circle.
\
\ ******************************************************************************

.sin

 FOR I%, 0, 127

  N = INT(0.5 + 256 * SIN((I% / 128) * (PI / 2)))

  IF N >= 255
   EQUB 255
  ELSE
   EQUB N
  ENDIF

 NEXT

\ ******************************************************************************
\
\       Name: iconBuffer
\       Type: Variable
\   Category: Graphics
\    Summary: The icon screen buffer, which is used to buffer the energy icon
\             and scanner row before writing to screen memory
\
\ ******************************************************************************

.iconBuffer

 SKIP 0                 \ The icon screen buffer shares memory with L5A00

\ ******************************************************************************
\
\       Name: L5A00
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L5A00

 SKIP 256

\ ******************************************************************************
\
\       Name: L5B00
\       Type: Variable
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.L5B00

 SKIP 256

\ ******************************************************************************
\
\       Name: stripData
\       Type: Variable
\   Category: Landscape
\    Summary: Storage for tile data when smoothing strips of tiles during the
\             landscape generation process
\
\ ------------------------------------------------------------------------------
\
\ The initial contents of the variable is just workspace noise and is ignored.
\ It actually contains snippets of the original source code.
\
\ ******************************************************************************

 CLEAR &5A00, &5C00     \ Memory from &5A00 to &5BFF has two separate uses
 ORG &5A00              \
                        \ During the landscape generation process, it is used
                        \ for storing tile data that can be discarded once the
                        \ landscape is generated
                        \
                        \ During gameplay it is used to store the L5A00 and
                        \ L5B00 variables
                        \
                        \ These lines rewind BeebAsm's assembly back to &5A00
                        \ and clear the block from that point to the end of the
                        \ L5A00 and L5B00 variables at &5C00, so we can assemble
                        \ the landscape variables
                        \
                        \ The initial contents of the game binary at this
                        \ address actually contains snippets of the original
                        \ source code, left over from the BBC Micro assembly
                        \ process, so we include this workspace noise to ensure
                        \ that we generate an exact match for the game binary

.stripData

 EQUB &44, &58, &20, &45, &54, &45, &4D, &0D
 EQUB &14, &3C, &05, &20, &0D, &14, &46, &23
 EQUB &20, &20, &20, &20, &20, &20, &54, &59
 EQUB &41, &3A, &4A, &53, &52, &20, &45, &4D
 EQUB &49, &52, &54, &45, &53, &54, &3A, &42
 EQUB &43, &43, &20, &6D, &65, &61, &32, &0D
 EQUB &14, &50, &05, &20, &0D, &14, &5A, &1A
 EQUB &20, &20, &20, &20, &20, &20, &54, &59

\ ******************************************************************************
\
\       Name: tilesAtAltitude
\       Type: Variable
\   Category: Landscape
\    Summary: Storage for tile blocks at specific altitudes for placing enemies
\             on the landscape
\
\ ------------------------------------------------------------------------------
\
\ This table stores the altitude of 4x4 tile blocks at specific altitudes, for
\ use when placing enemies on the landscape. It is only used while the landscape
\ is being generated and the allocated memory is reused during gameplay.
\
\ The initial contents of the variable is just workspace noise and is ignored.
\ It actually contains snippets of the original source code.
\
\ ******************************************************************************

.tilesAtAltitude

 EQUB &41, &3A, &53, &54, &41, &20, &4D, &45
 EQUB &41, &4E, &59, &2C, &58, &20, &0D, &14
 EQUB &64, &05, &20, &0D, &14, &6E, &1C, &20
 EQUB &20, &20, &20, &20, &20, &4C, &44, &41
 EQUB &23, &34, &3A, &53, &54, &41, &20, &4F
 EQUB &42, &54, &59, &50, &45, &2C, &59, &0D
 EQUB &14, &78, &23, &20, &20, &20, &20, &20
 EQUB &20, &4C, &44, &41, &23, &31, &30, &34

 EQUB &3A, &53, &54, &41, &20, &4F, &42, &48    \ These bytes are unused until
 EQUB &41, &4C, &46, &53, &49, &5A, &45, &4D    \ the game is in progress, at
 EQUB &49, &4E, &0D, &14, &82, &11, &20, &20    \ which point this whole section
 EQUB &20, &20, &20, &20, &43, &4C, &43, &3A    \ of memory is reused
 EQUB &72, &74, &73, &0D, &14, &83, &05, &20
 EQUB &0D, &14, &84, &21, &2E, &6D, &65, &61
 EQUB &32, &20, &49, &4E, &43, &20, &4D, &54
 EQUB &52, &59, &43, &4E, &54, &2C, &58, &3A
 EQUB &4A, &4D, &50, &20, &45, &45, &58, &49
 EQUB &54, &0D, &14, &85, &05, &20, &0D, &14
 EQUB &8C, &05, &20, &0D, &14, &96, &26, &2E
 EQUB &74, &61, &6B, &35, &20, &4C, &44, &41
 EQUB &23, &31, &32, &38, &3A, &53, &54, &41
 EQUB &20, &54, &48, &45, &45, &4E, &44, &3A
 EQUB &4A, &4D, &50, &20, &45, &45, &58, &49
 EQUB &54, &0D, &14, &A0, &05, &20, &0D, &14

\ ******************************************************************************
\
\       Name: maxAltitude
\       Type: Variable
\   Category: Landscape
\    Summary: The maximum tile altitude for each 4x4 block of tiles
\
\ ------------------------------------------------------------------------------
\
\ This table stores the altitude of the highest tile in each 4x4 block of tiles
\ in the landscape. It is only used while the landscape is being generated and
\ the allocated memory is reused during gameplay.
\
\ The table is laid out with one byte for each 4x4 block, starting in the
\ front-left corner of the landscape at tile coordinate (0, 0), and moving along
\ the front row from left to right, and then moving back by four tiles and
\ moving that row from left to right, until we reach the rear row of 4x4 blocks.
\
\ The rear row and rightmost column of blocks are one tile smaller, so they are
\ 4x3-tile and 3x4-tile blocks, with the far-right block being 3x3 tiles.
\
\ You can picture this as partitioning the 31x31-tile landscape into an 8x8
\ chess board, where each square on the chess board is made up of a 4x4 block of
\ landscape tiles (and with smaller squares along the right and rear edges).
\
\ The blocks of memory either side of maxAltitude are included as they are
\ zeroed when adding enemies to the landscape, and including them means we don't
\ have to worry about the zeroing process leaking into neighbouring variable
\ when placing enemies near the edges of the landscape.
\
\ The initial contents of the variable is just workspace noise and is ignored.
\ It actually contains snippets of the original source code.
\
\ ******************************************************************************

 EQUB &AA, &14, &2E, &54, &41, &4B, &45, &20
 EQUB &4C, &44, &58, &20, &50, &45, &52, &53

.maxAltitude

 EQUB &4F, &4E, &0D, &14, &B4, &22, &20, &20
 EQUB &20, &20, &20, &20, &43, &50, &58, &20
 EQUB &50, &4C, &41, &59, &45, &52, &49, &4E
 EQUB &44, &45, &58, &3A, &42, &4E, &45, &20
 EQUB &74, &61, &6B, &31, &0D, &14, &BE, &1D
 EQUB &20, &20, &20, &20, &20, &20, &4C, &44
 EQUB &41, &20, &45, &4E, &45, &52, &47, &59
 EQUB &3A, &42, &45, &51, &20, &74, &61, &6B

 EQUB &35, &0D, &14, &C8, &1E, &20, &20, &20
 EQUB &20, &20, &20, &53, &45, &43, &3A, &53

\ ******************************************************************************
\
\       Name: xTileMaxAltitude
\       Type: Variable
\   Category: Landscape
\    Summary: The tile x-coordinate of the highest tile within each 4x4 block of
\             tiles
\
\ ------------------------------------------------------------------------------
\
\ This table stores the tile x-coordinate of the highest tile within each 4x4
\ block of tiles in the landscape. It is only used while the landscape is being
\ generated and the allocated memory is reused during gameplay.
\
\ The table is laid out with one byte for each 4x4 block, starting in the
\ front-left corner of the landscape at tile coordinate (0, 0), and moving along
\ the front row from left to right, and then moving back by four tiles and
\ moving that row from left to right, until we reach the rear row of 4x4 blocks.
\
\ The rear row and rightmost column of blocks are one tile smaller, so they are
\ 4x3-tile and 3x4-tile blocks, with the far-right block being 3x3 tiles.
\
\ You can picture this as partitioning the 31x31-tile landscape into an 8x8
\ chess board, where each square on the chess board is made up of a 4x4 block of
\ landscape tiles (and with smaller squares along the right and rear edges).
\
\ The initial contents of the variable is just workspace noise and is ignored.
\ It actually contains snippets of the original source code.
\
\ ******************************************************************************

.xTileMaxAltitude

 EQUB &42, &43, &23, &31, &3A, &53, &54, &41
 EQUB &20, &45, &4E, &45, &52, &47, &59, &0D
 EQUB &14, &D2, &12, &20, &20, &20, &20, &20
 EQUB &20, &4A, &53, &52, &20, &45, &44, &49
 EQUB &53, &0D, &14, &DC, &18, &20, &20, &20
 EQUB &20, &20, &20, &4C, &44, &41, &23, &35
 EQUB &3A, &4A, &53, &52, &20, &56, &49, &50
 EQUB &4F, &0D, &14, &E6, &16, &20, &20, &20

\ ******************************************************************************
\
\       Name: zTileMaxAltitude
\       Type: Variable
\   Category: Landscape
\    Summary: The tile z-coordinate of the highest tile within each 4x4 block of
\             tiles
\
\ ------------------------------------------------------------------------------
\
\ This table stores the tile z-coordinate of the highest tile within each 4x4
\ block of tiles in the landscape. It is only used while the landscape is being
\ generated and the allocated memory is reused during gameplay.
\
\ The table is laid out with one byte for each 4x4 block, starting in the
\ front-left corner of the landscape at tile coordinate (0, 0), and moving along
\ the front row from left to right, and then moving back by four tiles and
\ moving that row from left to right, until we reach the rear row of 4x4 blocks.
\
\ The rear row and rightmost column of blocks are one tile smaller, so they are
\ 4x3-tile and 3x4-tile blocks, with the far-right block being 3x3 tiles.
\
\ You can picture this as partitioning the 31x31-tile landscape into an 8x8
\ chess board, where each square on the chess board is made up of a 4x4 block of
\ landscape tiles (and with smaller squares along the right and rear edges).
\
\ The initial contents of the variable is just workspace noise and is ignored.
\ It actually contains snippets of the original source code.
\
\ ******************************************************************************

.zTileMaxAltitude

 EQUB &20, &20, &20, &53, &45, &43, &3A, &4A
 EQUB &4D, &50, &20, &74, &61, &6B, &33, &0D
 EQUB &14, &F0, &05, &20, &0D, &14, &FA, &05
 EQUB &20, &0D, &15, &04, &18, &2E, &74, &61
 EQUB &6B, &31, &20, &54, &58, &41, &3A, &4A
 EQUB &53, &52, &20, &45, &4D, &49, &52, &50
 EQUB &54, &0D, &15, &0E, &05, &20, &0D, &15
 EQUB &18, &1F, &20, &20, &20, &20, &20, &20

 EQUB &4C, &44, &41, &20, &4F, &42, &54, &59    \ These bytes are unused until
 EQUB &50, &45, &2C, &58, &3A, &42, &4E, &45    \ the game is in progress, at
 EQUB &20, &74, &61, &6B, &34, &0D, &15, &22    \ which point this whole section
 EQUB &05, &20, &0D, &15, &2C, &1E, &20, &5C    \ of memory is reused

\ ******************************************************************************
\
\       Name: GetObjectAngles
\       Type: Subroutine
\   Category: 3D objects
\    Summary: Calculate the angles and distances of the vector from the viewer
\             to a specific object
\
\ ------------------------------------------------------------------------------
\
\ This routine calculates the following for an object:
\
\ 1. (xDeltaHi xDeltaLo) etc.: Calculate the difference (the delta) in all three
\ axes between the viewer and the object we are analysing, to give us the 3D
\ vector from the viewer to the object.
\
\ 2. (angleHi angleLo): Calculate the angle of the hypotenuse of the triangle
\ formed by the x- and z-axes axes, which is the projection of the 3D vector
\ from the viewer to the object down onto the ground plane (so imagine a light
\ shining down from above, casting the vector's shadow onto the y = 0 plane -
\ that's the hypotenuse)
\
\ 3. (objectViewYawHi objectViewYawLo): The angle of the hypotenuse is the yaw
\ angle of the 3D vector from the viewer to the object we are analysing. We
\ subtract the viewer's yaw angle and the yaw adjustment, and add half a screen
\ width to get the yaw angle delta from the viewer's gaze to the object,
\ relative to the viewer's gaze, i.e. the screen). This gives us the yaw angle
\ relative to the view. You can think of this as the screen x-coordinate of the
\ object, or how far the object appears from the left edge of the screen.
\
\ 4. (objectGazeYawHi objectGazeYawLo) and (hypotenuseHi hypotenuseLo): Set to
\ the object's gaze relative to the viewer's gaze.
\
\ 5. If this is the landscape preview, rotate the object to face forwards and
\ scale it so it looks good.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The number of the object to be analysed
\
\   viewType            Landscape preview flag:
\
\                         * Zero = this is the landscape preview, so rotate all
\                                  the in the preview objects to face the viewer
\
\                         * Non-zero = this is not the landscape preview, so
\                                      leave the objects alone
\
\ ******************************************************************************

 RTS                    \ This instruction appears to be unused

.GetObjectAngles

 STY objectToAnalyse    \ Set objectToAnalyse to the number of the object being
                        \ analysed

 LDA objectTypes,Y      \ Set objTypeToAnalyse to the type of the object being
 STA objTypeToAnalyse   \ analysed

                        \ We start by calculating the difference (the delta) in
                        \ all three axes between the viewer and the object we
                        \ are analysing, to give us the 3D vector from the
                        \ viewer to the object

 LDX viewingObject      \ Set X to the object number of the viewer

 JSR GetHorizontalDelta \ Calculate the following:
                        \
                        \   (xDeltaHi xDeltaLo) =   x-coordinate of object #Y
                        \                         - x-coordinate of object #X
                        \                         - xTitleOffset
                        \
                        \   xDeltaAbsoluteHi = |xDeltaAbsoluteHi|
                        \
                        \   (zDeltaHi zDeltaLo) =   z-coordinate of object #Y
                        \                         - z-coordinate of object #X
                        \
                        \   zDeltaAbsoluteHi = |zDeltaHi|
                        \
                        \ So this calculates the difference in both horizontal
                        \ axes between object #X (the viewer) and object #Y (the
                        \ object being analysed)
                        \
                        \ Note that xTitleOffset is zero during gameplay, and is
                        \ only non-zero when we are drawing large 3D text on the
                        \ title screen

 JSR GetVerticalDelta   \ Calculate the following:
                        \
                        \   (yDeltaHi yDeltaLo) =   y-coordinate of object #Y
                        \                         - y-coordinate of object #X
                        \
                        \ So this calculates the difference in altitude between
                        \ object #X (the viewer) and object #Y (the object being
                        \ analysed)

                        \ We now have deltas for all three axes, so we now can
                        \ calculate the angle of the hypotenuse of the triangle
                        \ formed by the x- and z-axes axes, which is the
                        \ projection of the 3D vector from the viewer to the
                        \ object down onto the ground plane (so imagine a light
                        \ shining down from above, casting the vector's shadow
                        \ onto the y = 0 plane - that's the hypotenuse)

 JSR GetHypotenuseAngle \ Calculate the angle of the hypotenuse in the triangle
                        \ with the following non-hypotenuse sides:
                        \
                        \   * (xDeltaHi xDeltaLo)
                        \
                        \   * (zDeltaHi zDeltaLo)
                        \
                        \ and return the angle in (angleHi angleLo), the tangent
                        \ in angleTangent, the length of the longer side in
                        \ (aHi aLo) and the length of the shorter side in
                        \ (bHi bLo)
                        \
                        \ This call also sets the (aHi aLo) and (bHi bLo)
                        \ variables so we can call GetHypotenuse below ???

                        \ The angle of the hypotenuse is the yaw angle of the
                        \ 3D vector from the viewer to the object we are
                        \ analysing
                        \
                        \ We also subtract the following:
                        \
                        \   * objectYawAngle,X from the high byte so the result
                        \     is the relative yaw angle from object #X (the
                        \     viewer's gaze) to the object
                        \
                        \   * yawAdjustmentLo from the low byte so ???
                        \
                        \ and add the following:
                        \
                        \   * (10 0) to add half a screen width (as the screen
                        \     is 20 yaw angles wide)
                        \
                        \ So the result in (objectViewYawHi objectViewYawLo) is
                        \ the yaw angle delta from the viewer's gaze to the
                        \ object, plus adjustments and half a screen, to give us
                        \ the yaw angle relative to the view
                        \
                        \ You can think of this as the screen x-coordinate of
                        \ the object, or how far the object appears from the
                        \ left edge of the screen

 LDX viewingObject      \ Set X to the object number of the viewer

 LDA angleLo            \ Set (objectViewYawHi objectViewYawLo) =
 SEC                    \               (angleHi angleLo) - (0 yawAdjustmentLo)
 SBC yawAdjustmentLo    \                                 - (objectYawAngle,X 0)
 STA objectViewYawLo    \                                 + (10 0)
 LDA angleHi
 SBC objectYawAngle,X
 CLC
 ADC #10
 STA objectViewYawHi

 LDY objectToAnalyse    \ Set Y to the number of the object being analysed

 LDA #0                 \ Set (objectGazeYawHi objectGazeYawLo) =
 SEC                    \               (objectYawAngle,Y 0) - (angleHi angleLo)
 SBC angleLo            \
 STA objectGazeYawLo    \ This is the difference in yaw angles between the
 LDA objectYawAngle,Y   \ hypotenuse (i.e. the viewer's gaze) and the direction
 SBC angleHi            \ in which the object is facing (i.e. the object's gaze
 STA objectGazeYawHi    \ to wherever it is looking), so that's the object's
                        \ gaze relative to the viewer's gaze

 JSR GetHypotenuse      \ Calculate the length of the hypotenuse in the triangle
                        \ with side lengths of (aHi aLo) and (bHi bLo) and angle
                        \ angleTangent, which are still set from the call to
                        \ GetHypotenuseAngle above to the values for the
                        \ projection of the 3D vector from the viewer to the
                        \ object down onto the ground plane
                        \
                        \ The hypotenuse length is returned in (hypotenuseHi
                        \ hypotenuseLo)

 LDA viewType           \ If viewType is non-zero then this is not the landscape
 BNE oang1              \ preview, so jump to oang1 to skip the following

                        \ This is the landscape preview, so we rotate the object
                        \ to face towards the back of the landscape, so the
                        \ Sentinel and sentries all neatly look out of the
                        \ screen in the preview

 LDA #128               \ Set (objectGazeYawHi objectGazeYawLo) = (128 0)
 STA objectGazeYawHi    \
 LDA #0                 \ The degree system in the Sentinel looks like this:
 STA objectGazeYawLo    \
                        \            0
                        \      -32   |   +32         Overhead view of object
                        \         \  |  /
                        \          \ | /             0 = looking straight ahead
                        \           \|/              +64 = looking sharp right
                        \   -64 -----+----- +64      -64 = looking sharp left
                        \           /|\
                        \          / | \
                        \         /  |  \
                        \      -96   |   +96
                        \           128
                        \
                        \ So this makes the object face directly out of the
                        \ screen

 CPY #63                \ If we are analysing object #63, then this is either
 BEQ oang1              \ a block of 3D text or the Sentinel's tower, and the
                        \ landscape preview doesn't use 3D text so it must be
                        \ the Sentinel's tower, so jump to oang1 to skip the
                        \ following
                        \
                        \ This ensures that all objects apart from the tower
                        \ are drawn at double size, so they stand out more
                        \ clearly in the landscape preview (the tower is the
                        \ biggest object by far, so doubling its size would
                        \ make it too large)

 LSR hypotenuseHi       \ Halve the hypotenuse length to make the object appear
 ROR hypotenuseLo       \ to be half the distance away, so it is drawn at twice
                        \ the size

 SEC                    \ Halve the object's altitude in (yDeltaHi yDeltaLo) for
 ROR yDeltaHi           \ the same reason
 ROR yDeltaLo           \
                        \ Because this is the landscape view, the viewer is very
                        \ high above the landscape (as well as a long way in
                        \ front of the front edge), so we know that (yDeltaHi
                        \ yDeltaLo) will be negative, as it's calculated as the
                        \ altitude of the object being analysed minus the
                        \ altitude of the viewer, and the latter is higher than
                        \ any object on the landscape
                        \
                        \ So we can halve the value of (yDeltaHi yDeltaLo) by
                        \ shifting a set bit into the top end of yDeltaHi, so we
                        \ keep the sign correct

 LDA yDeltaLo           \ Set (yDeltaHi yDeltaLo) += 112
 CLC                    \
 ADC #112               \ Starting with the low bytes
 STA yDeltaLo

 BCC oang1              \ And then the high byte
 INC yDeltaHi           \
                        \ This moves the Sentinel and sentries up so they stand
                        \ out more clearly in the landscape preview, as
                        \ otherwise they would appear to be sinking into the
                        \ landscape rather than perching on top of it

.oang1

 LDA hypotenuseLo       \ Set (objectAdjacentHi objectAdjacentLo) to the length
 STA objectAdjacentLo   \ of the hypotenuse, which is the length of the adjacent
 LDA hypotenuseHi       \ side in the right-angled triangle with the vector from
 STA objectAdjacentHi   \ the viewer to the object as the hypotenuse

 LDA yDeltaLo           \ Set (objectOppositeHi objectOppositeLo) to the height
 STA objectOppositeLo   \ of the object relative to the viewer, which is the
 LDA yDeltaHi           \ length of the opposite side in the right-angled
 STA objectOppositeHi   \ triangle with the vector from the viewer to the object
                        \ as the hypotenuse

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetObjPointAngles
\       Type: Subroutine
\   Category: Drawing objects
\    Summary: Calculate the view-relative pitch and yaw angles of all the points
\             in an object
\
\ ------------------------------------------------------------------------------
\
\ This routine loops through each point in an object definition and calculates
\ the following, storing the results in the last 32 bytes of the drawing tables
\ at (drawViewYawHi drawViewYawLo) and (drawViewPitchHi drawViewPitchLo):
\
\ 1. A: Calculate the yaw angle of the point, rotated by the rotation of the
\ object itself (i.e. its gaze), so this is the yaw angle of the object point
\ within the object, but with the the correct rotation for the direction the
\ object is facing.
\
\ 2. (xDeltaHi xDeltaLo), (zDeltaHi zDeltaLo): Convert this yaw angle and the
\ polar distance into x- and z-coordinates for the point in the y = 0 plane
\ (i.e. on the ground) using cos(A) and sin(A) on a triangle with the line along
\ the polar distance to the point as the hypotenuse. So these are the x- and
\ z-coordinates of the object point within the object itself (i.e. relative to
\ the object's origin and rotated to the correct gaze).
\
\ 3. (angleHi angleLo): Calculate the angle of the right-angled triangle made
\ up of the object point's object-relative x- and z-coordinates, to give us the
\ angle of the vector from the object's origin to the to the point within the
\ object.
\
\ 4. (drawViewYawHi drawViewYawLo): Rotate the yaw angle of the point within
\ the object definition by the object's view-relative yaw angle to get the
\ view-relative yaw angle of the point. This is the yaw angle of the vector from
\ the viewer to the object point.
\
\ 5. (drawViewPitchHi drawViewPitchLo): Construct the vertical triangle that
\ has the viewer-to-point vector as the hypotenuse, the point altitude as the
\ opposite side and the projection onto the ground of the vector as the adjacent
\ side, and use this to calculate the pitch angle of the vector from the viewer
\ to the object point.
\
\ ******************************************************************************

.GetObjPointAngles

 LDX objTypeToAnalyse   \ Set X to the number of the object we are drawing

 LDA #64                \ Set drawingTableIndex to 64 to use as the index into
 STA drawingTableIndex  \ the drawing tables for the object we are drawing, so
                        \ we store the results in the following drawing tables:
                        \
                        \   (drawViewYawHi drawViewYawLo)
                        \
                        \   (drawViewPitchHi drawViewPitchLo)
                        \
                        \ Note that these drawing tables live just after the
                        \ tile drawing tables in memory, and the index is set
                        \ accordingly
                        \
                        \ Specifically, the tile view angles is stored with a
                        \ drawing index of 0 or 32, thus taking up the first 64
                        \ bytes of each table, while the object point angles
                        \ are stored from drawing index 64
                        \
                        \ Each drawing table is 96 bytes in total, so they fit
                        \ together nicely

 LDA objPointRange+1,X  \ Set objectLastPoint to entry X + 1 from the table at
 STA objectLastPoint    \ objPointRange, so this now contains the number of the
                        \ first point for the next object, object #X + 1, which
                        \ is one greater than the last point number for object
                        \ #X, as the lists of object points are sequential (so
                        \ object #0's points are first in the object data
                        \ tables, then object #1's points, and so on)

 LDY objPointRange,X    \ Set Y and pointNumber to entry X from the table at
 STY pointNumber        \ objPointRange, so this now contains the number of the
                        \ first point for object #X

                        \ We now work through the points in the object, using Y
                        \ as the point number and working through the points
                        \ from first to last
                        \
                        \ Object points are stored as polar coordinates plus a
                        \ height, to define where they appear within the object
                        \
                        \ The polar coordinate consists of a polar yaw angle and
                        \ a polar distance (where these are relative to the gaze
                        \ and origin of the object in the object's definition),
                        \ which together define the position of the point on the
                        \ ground plane (y = 0), as if we were looking at the
                        \ object from above
                        \
                        \ The height defines the y-coordinate of the point
                        \ relative to the object's origin, so that's the height
                        \ of the point within the object
                        \
                        \ You can think of the polar coordinate as defining the
                        \ positions of the points on a piece of paper, and the
                        \ height then extruding those points up and down, away
                        \ from the paper, to create a 3D model

.obpt1

 LDA objectGazeYawLo    \ Set (A T) =   (objectGazeYawHi objectGazeYawLo)
 STA T                  \             + yaw angle for point Y
 LDA objectGazeYawHi    \
 CLC                    \ So this is the yaw angle of point Y in the object,
 ADC objPointYaw,Y      \ rotated by the rotation of the object itself (i.e. its
                        \ gaze), so this is the yaw angle of the object point
                        \ within the object, but with the correct rotation for
                        \ the direction the object is facing

 JSR GetSineAndCosine   \ Calculate the following:
                        \
                        \   sinA = |sin(A)|
                        \
                        \   cosA = |cos(A)|
                        \
                        \ where A is the yaw angle of the object point
                        \
                        \ This also returns the quadrant of the angle in bits 6
                        \ and 7 of H ???

 LDY pointNumber        \ Set U to the polar distance of the object point
 LDA objPointDistance,Y
 STA U

 LDA cosA               \ Set (A T) = A * U
 JSR Multiply8x8        \           = distance * cos(A)

 STA T                  \ Set (A T) = distance * cos(A) / 256
 LDA #0                 \
                        \ This discards the fractional part of the result

 BIT H                  \ If bit 6 of H is clear then the result already has the
 BVC obpt2              \ correct sign, so jump to obpt2 to skip the following
                        \ ???

 JSR Negate16Bit        \ Set (A T) = -(A T)
                        \
                        \ So the result now has the correct sign

.obpt2

 STA U                  \ Set (U T) = (A T)
                        \           = distance * cos(A)
                        \
                        \ So this is the length of the adjacent side in the
                        \ triangle with the polar distance as the hypotenuse

 LDA objectAdjacentLo   \ Set (zDeltaHi zDeltaLo) =
 CLC                    \     (objectAdjacentHi objectAdjacentLo) + (U T)
 ADC T                  \
 STA zDeltaLo           \ So this adds the adjacent side of the vector from the
 LDA objectAdjacentHi   \ viewer to the object, to the adjacent side of the
 ADC U                  \ polar coordinate of the object point
 STA zDeltaHi           \
                        \ This gives the distance along the axis of the object
                        \ point, i.e. the point's coordinate

 BPL obpt3              \ If the high byte of the result is positive, jump to
                        \ obpt3 as the result in A is already correct for the
                        \ absolute value (i.e. A = zDeltaHi = |zDeltaHi|)

 LDA #0                 \ Negate (zDeltaHi zDeltaLo) so it contains the absolute
 SEC                    \ value of the coordinate
 SBC zDeltaLo
 STA zDeltaLo
 LDA #0
 SBC zDeltaHi

.obpt3

                        \ As the angle of the triangle is at the viewer end of
                        \ the hypotenuse, the length of the adjacent side is
                        \ effectively the length of the side along the z-axis,
                        \ so we can use the distance as a z-coordinate

 STA zDeltaAbsoluteHi   \ Set zDeltaAbsoluteHi = |zDeltaHi|
                        \
                        \ So we now have the absolute z-axis length in:
                        \
                        \   (zDeltaAbsoluteHi zDeltaLo)
                        \
                        \ and the original high byte of the signed z-axis length
                        \ is still in zDeltaHi

                        \ We now do a similar calculation for the x-axis, but
                        \ using sin(A) instead of cos(A) to get the length of
                        \ the opposite side of the triangle instead of the
                        \ adjacent

 LDA objPointDistance,Y \ Set U to the polar distance of the object point
 STA U

 LDA sinA               \ Set (A T) = A * U
 JSR Multiply8x8        \           = distance * sin(A)

 STA xDeltaLo           \ Set (A xDeltaLo) = distance * sin(A) / 256
 LDA #0

 STA xDeltaAbsoluteHi   \ Set xDeltaAbsoluteHi = 0 so it is correctly set to the
                        \ high byte of (A xDeltaLo), as A is 0

 LDA H                  \ Set xDeltaHi to the quadrant of the angle so that
 STA xDeltaHi           \ (xDeltaHi xDeltaLo) is the correctly signed length of
                        \ the opposite ???

                        \ So we now have the x- and z-coordinates of the object
                        \ point within the object itself (i.e. relative to the
                        \ object's origin and rotated to the correct gaze), so
                        \ we can calculate the angle in that triangle, to give
                        \ us the yaw angle of the point relative to the object's
                        \ origin

 JSR GetHypotenuseAngle \ Calculate the angle of the hypotenuse in the triangle
                        \ with the following non-hypotenuse sides:
                        \
                        \   * (xDeltaHi xDeltaLo)
                        \
                        \   * (zDeltaHi zDeltaLo)
                        \
                        \ and return the angle in (angleHi angleLo), the tangent
                        \ in angleTangent, the length of the longer side in
                        \ (aHi aLo) and the length of the shorter side in
                        \ (bHi bLo)
                        \
                        \ So (angleHi angleLo) is the angle of the right-angled
                        \ triangle made up of the object point's object-relative
                        \ x- and z-coordinates, i.e. the yaw angle of the point
                        \ within the object, or the angle of the vector from the
                        \ object's origin to the to the point within the object

                        \ We now calculate the yaw and pitch angles of the point
                        \ in terms of the 3D world, storing the results in the
                        \ following tables:
                        \
                        \   (drawViewYawHi drawViewYawLo)
                        \
                        \   (drawViewPitchHi drawViewPitchLo)
                        \
                        \ We do this by constructing two right-angled triangles,
                        \ one flat on the ground (to calculate the yaw angle)
                        \ and the other standing vertically (to calculate the
                        \ pitch angle)
                        \
                        \ Let's start with the triangle on the ground
                        \
                        \ The object has a view-relative yaw angle of:
                        \
                        \   (objectViewYawHi objectViewYawLo)
                        \
                        \ which was set up by the call to the GetObjectAngles
                        \ routine before we called this routine
                        \
                        \ This contains the yaw angle of the object relative to
                        \ the view
                        \
                        \ We just calculated the object-relative yaw angle of
                        \ the object point in:
                        \
                        \   (angleHi angleLo)
                        \
                        \ If we add these two yaw angles together to get:
                        \
                        \  (angleHi angleLo) + (objectViewYawHi objectViewYawLo)
                        \
                        \ then this gives us the view-relative yaw angle of the
                        \ object point, which is what we are trying to calculate
                        \ in this routine

 LDY drawingTableIndex  \ Set Y to the drawing table index for this object point
                        \ so we store the results in the last 32 bytes of the
                        \ tile view drawing tables (i.e. in the object point
                        \ drawing tables)

 LDA angleLo            \ Set (drawViewYawHi drawViewYawLo) for this point to:
 CLC                    \
 ADC objectViewYawLo    \  (angleHi angleLo) + (objectViewYawHi objectViewYawLo)
 STA drawViewYawLo,Y    \
 LDA angleHi            \ So this is the angle in our first triangle, which is
 ADC objectViewYawHi    \ the view-relative yaw angle of the object point, so
 STA drawViewYawHi,Y    \ store this in the drawing table at (drawViewYawHi
                        \ drawViewYawLo)

                        \ We now move on to calculating the view-relative pitch
                        \ angle of the object point by looking at the second
                        \ triangle
                        \
                        \ In the first triangle, we calculated the length and
                        \ angle of the hypotenuse along the ground, which
                        \ represents the projection from above of the vector
                        \ from the viewer to the object point
                        \
                        \ We're now interested in the y-axis element, so let's
                        \ construct a triangle that stands vertically, and whose
                        \ hypotenuse is the 3D vector from the viewer to the
                        \ object point
                        \
                        \ The hypotenuse that we used to calculate the yaw angle
                        \ is now along the ground, acting as the bottom side
                        \ of the new triangle, i.e. the adjacent side where the
                        \ triangle's angle is the pitch angle
                        \
                        \ The opposite side of the triangle is the height of the
                        \ point above the ground (if we're looking up) or below
                        \ ground (if we're looking down), which we can calculate
                        \ using the objPointHeight table, which contains the
                        \ height of the point within the object, and adding the
                        \ view-relative y-coordinate of the object
                        \
                        \ Given these two sides, we can then calculate the pitch
                        \ angle of our new triangle to give the view-relative
                        \ pitch angle of the object point, which is what we are
                        \ trying to calculate in this routine

 JSR GetHypotenuse      \ Calculate the length of the hypotenuse in the triangle
                        \ with side lengths of (aHi aLo) and (bHi bLo) and angle
                        \ angleTangent, which are still set from the call to
                        \ GetHypotenuseAngle above to the values for the vector
                        \ from the object's origin to the to the point within
                        \ the object
                        \
                        \ So this is the adjacent side of our new triangle,
                        \ along the ground
                        \
                        \ The hypotenuse length is returned in (hypotenuseHi
                        \ hypotenuseLo)

 LDY pointNumber        \ Set A to the objPointHeight entry for the object point
 LDA objPointHeight,Y   \
                        \ The height is stored in objPointHeight as follows:
                        \
                        \   * Bit 7 contains the sign bit
                        \
                        \   * Bits 0 to 6 contain half the magnitude of the
                        \     height
                        \
                        \ So the height stored as a scaled, sign-magnitude value
                        \ that we now need to extract into a signed number

 ASL A                  \ Shift the sign bit into the C flag and double the
                        \ value in bits 0 to 6 to get the magnitude of the
                        \ height in A, so:
                        \
                        \   A = |height|

 STA T                  \ Set (A T) = |height|
 LDA #0

 BCC obpt4              \ If the sign bit is clear then the height is positive
                        \ and (A T) already has the correct sign, so jump to
                        \ obpt4 to skip the following

                        \ Otherwise the sign bit is set and the height is
                        \ negative, so we need to negate the absolute value to
                        \ get the signed height

 JSR Negate16Bit        \ Set (A T) = -(A T)
                        \
                        \ So the result now has the correct sign

.obpt4

 STA U                  \ Set (U T) = (A T)
                        \
                        \ So (U T) contains the height of the object point
                        \ relative to the object's origin, i.e. within the
                        \ object

                        \ We already calculated the object's view-relative
                        \ y-coordinate in (objectOppositeHi objectOppositeLo),
                        \ so now we add the two together to get the height
                        \ of the object point, relative to the view

 LDA T                  \ Set (A xDeltaLo) = (U T) + 
 CLC                    \                    (objectOppositeHi objectOppositeLo)
 ADC objectOppositeLo   \
 STA xDeltaLo           \ So (A xDeltaLo) now contains the vertical delta, ready
 LDA U                  \ to pass to GetPitchAngleDelta
 ADC objectOppositeHi

 LDX viewingObject      \ Set X to the object number of the viewer so the call
                        \ to GetPitchAngleDelta calculates the pitch angle
                        \ relative to the viewing object's gaze

 JSR GetPitchAngleDelta \ Set (pitchDeltaHi pitchDeltaLo) to the pitch angle of
                        \ the vector along the hypotenuse of our new triangle,
                        \ given the length of the vertical side in (A xDeltaLo)
                        \ and the length of the adjacent side in (hypotenuseHi
                        \ hypotenuseLo), relative to the viewing object's gaze
                        \
                        \ So we now have the view-relative pitch angle of the
                        \ object point, which is what we are trying to calculate
                        \ in this routine

 LDY drawingTableIndex  \ Set Y to the drawing table index for this object point
                        \ so we store the results in the last 32 bytes of the
                        \ tile view drawing tables (i.e. in the object point
                        \ drawing tables)

 LDA pitchDeltaHi       \ Store (pitchDeltaHi pitchDeltaLo) in the drawing table
 STA drawViewPitchHi,Y  \ as (drawViewPitchHi drawViewPitchLo)
 LDA pitchDeltaLo
 STA drawViewPitchLo,Y

 INC pointNumber        \ Increment the point number to move on to the next
                        \ point in the object

 INC drawingTableIndex  \ Increment the index into the drawing table so we store
                        \ the results for the next point in the next byte in the
                        \ drawing tables

 LDY pointNumber        \ If we have reached the first point of the next object
 CPY objectLastPoint    \ then we have processed all the points in this object,
 BEQ obpt5              \ so jump to obpt5 to return from the subroutine

 JMP obpt1              \ Loop back to process the next point in the object

.obpt5

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: DrawObject
\       Type: Subroutine
\   Category: Drawing objects
\    Summary: Draw a 3D object
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   Y                   The number of the object to be drawn
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   Y                   Y is preserved
\
\ ******************************************************************************

.DrawObject

 JSR GetObjectAngles    \ Calculate the angles and distances of the vector from
                        \ the viewer to the object into the following variables:
                        \
                        \   * Set (objectViewYawHi objectViewYawLo) to the yaw
                        \     angle of the viewer's gaze towards the object,
                        \     relative to the screen
                        \
                        \   * Set (objectGazeYawHi objectGazeYawLo) to the
                        \     difference in yaw angles between the viewer's gaze
                        \     towards the object and the object's gaze to
                        \     wherever it is looking (so that's the object's
                        \     gaze relative to the viewer's gaze)
                        \
                        \   * Set (objectAdjacentHi objectAdjacentLo) to the
                        \     length of the adjacent side in the right-angled
                        \     triangle with the vector from the viewer to the
                        \     object as the hypotenuse
                        \
                        \   * Set (objectOppositeHi objectOppositeLo) to the
                        \     length of the opposite side in the right-angled
                        \     triangle with the vector from the viewer to the
                        \     object as the hypotenuse
                        \
                        \ This also sets (hypotenuseHi hypotenuseLo) to the same
                        \ value as as (objectAdjacentHi objectAdjacentLo), and
                        \ it sets objectToAnalyse to the number of the object
                        \ that we are drawing

 LDA hypotenuseHi       \ If hypotenuseHi (i.e. objectAdjacentHi) is greater or
 CMP #15                \ equal to 15 then the object is a fair distance away
 ROR blendPolygonEdges  \ from the viewer along the z-axis, so set bit 7 of
                        \ blendPolygonEdges so we draw the polygon edges in the
                        \ same colour as the polygon body (i.e. the fill
                        \ colour), so the edges blend into the body
                        \
                        \ We do this for distant objects because distinct edge
                        \ colours can make those object look messy

 JSR GetObjPointAngles  \ Calculate the view-relative pitch and yaw angles of
                        \ all the points in the object and put them into the
                        \ drawing tables at:
                        \
                        \   (drawViewYawHi drawViewYawLo)
                        \
                        \   (drawViewPitchHi drawViewPitchLo)
                        \
                        \ We can use these as screen x- and y-coordinates, using
                        \ the same screen projection that is used in Revs

 LDA #%01000000         \ Clear bit 7 and set bit 6 of polygonType so the call
 STA polygonType        \ to DrawPolygon below draws the correct type of polygon
                        \ for being part of an object

 LDA #0                 \ Set drawingPhaseCount = 0, so the default is to draw
 STA drawingPhaseCount  \ the object in one phase (we may change this later if
                        \ the object needs to be drawn in two phases)

 STA drawingPhase       \ Clear bit 7 of drawingPhase so for objects that need
                        \ two drawing phases, we start by drawing the first
                        \ phase (as the current phase is determined by bit 7)

 LDX objTypeToAnalyse   \ Set X to the number of the object we are drawing

 LDA objPolygonPhases,X \ Set A to the phase data for the object we are drawing,
                        \ which helps determine the number of drawing phases

 BEQ drob4              \ If A = 0 then this object only has one drawing phase,
                        \ so jump to drob4 to move on to drawing the object
                        \ (this applies to the tree, the boulder, the Sentinel's
                        \ tower and the 3D text blocks)

                        \ If we get here then bit 1 of A must be set, as the
                        \ only values used in the objPolygonPhases table are
                        \ %00, %10 and and %11

 LSR A                  \ If bit 0 of A is set then this object might need two
 BCS drob1              \ drawing phases, so jump to drob1 to work out how many
                        \ phases are required by checking the relative altitude
                        \ of the object (this applies to the robot, the sentry
                        \ and the Sentinel)

                        \ If we get here then bit 0 of A is clear and bit 1 is
                        \ set, so we need to work out how many phases are
                        \ required by checking whether or not the object is
                        \ facing the viewer as given in the object's yaw angle
                        \ (this applies to the meanie only)

 LDA objectGazeYawHi    \ Set A to the object's gaze yaw angle + 192, to turn it
 ADC #192               \ anticlockwise (left) through 90 degrees for the phase
                        \ calculation (the addition works because the C flag is
                        \ clear, as we just passed through a BCS)

 JMP drob3              \ Jump to drob3 to set drawingPhaseCount to 0 or 2,
                        \ depending on the direction in which the meanie is now
                        \ facing:
                        \
                        \   * 0 = one phase if the meanie's gaze yaw angle is
                        \     positive after the rotation, which means it must
                        \     be facing towards the viewer (so we leave
                        \     drawingPhaseCount = 0)
                        \
                        \   * 2 = two phases if the meanie's gaze yaw angle is
                        \     negative after the rotation, which means it must
                        \     be facing away from the viewer (so we set the
                        \     drawingPhaseCount = 2)

.drob1

                        \ If we get here then we are drawing a robot, a sentry
                        \ or the Sentinel, so we need to work out how many
                        \ drawing phases are required

 LDA objectOppositeHi   \ If (objectOppositeHi objectOppositeLo) has a non-zero
 BNE drob2              \ high byte, then jump to drob2 to:
                        \
                        \   * Draw the object in two phases if objectOppositeHi
                        \     is positive (i.e. the object is reasonably far
                        \     above the viewer)
                        \
                        \   * Draw the object in one phase if objectOppositeHi
                        \     is negative (i.e. the object is below the viewer)

 LDA objectOppositeLo   \ If (objectOppositeHi objectOppositeLo) = 0 then the
 BEQ drob4              \ object is at the same height as the viewer, so jump to
                        \ drob4 to draw the object in one phase (by leaving
                        \ drawingPhaseCount = 0)

                        \ If we get here then objectOppositeHi is zero but
                        \ objectOppositeLo is non-zero, so the object is only a
                        \ little bit above the viewer and we draw the object in
                        \ two phases (so now we set drawingPhaseCount = 2)

 LSR A                  \ Clear bit 7 of A, so the following EOR instruction
                        \ will set bit 7, so we pass through the BPL instruction
                        \ and set drawingPhaseCount = 2 before falling through
                        \ into drob4 to do the actual drawing

.drob2

 EOR #%10000000         \ Flip bit 7 of A, which will contain objectOppositeHi
                        \ if we jumped here from the BNE above

.drob3

 BPL drob4              \ If we jumped here because we are drawing a meanie,
                        \ then this jumps to drob4 if the updated object's gaze
                        \ yaw angle is positive
                        \
                        \ If we fell through from drob2, then this jumps to
                        \ drob4 if bit 7 of objectOppositeHi is set, i.e. if
                        \ (objectOppositeHi objectOppositeLo) is negative

                        \ If we get here then one of these is true:
                        \
                        \   * We are drawing a meanie and it is facing away from
                        \     the viewer
                        \
                        \   * We are drawing a robot, a sentry or the Sentinel
                        \     and one of these is true:
                        \
                        \     * (objectOppositeHi objectOppositeLo) is positive
                        \       and objectOppositeHi > 0 (so the object is
                        \       reasonably far above the viewer)
                        \
                        \     * objectOppositeHi is zero and objectOppositeLo is
                        \       non-zero (so the object is a little bit above
                        \       the viewer)
                        \
                        \     In other words we are drawing a robot, a sentry or
                        \     the Sentinel and the object is above the viewer

 LDA #2                 \ Set drawingPhaseCount = 2 so we draw the object in two
 STA drawingPhaseCount  \ phases

.drob4

 LDX objTypeToAnalyse   \ Set X to the number of the object we are drawing

 LDA objPolygonRange+1,X    \ Set objectLastPolygon to entry X + 1 from the
 STA objectLastPolygon      \ table at objPolygonRange, so this now contains the
                            \ number of the first polygon for the next object,
                            \ object #X + 1, which is one greater than the last
                            \ polygon number for object #X, as the lists of
                            \ object polygons are sequential (so object #0's
                            \ polygons are first in the object data tables, then
                            \ object #1's polygons, and so on)

 LDY objPolygonRange,X  \ Set Y to entry X from the table at objPolygonRange, so
                        \ so this now contains the number of the first polygon
                        \ for object #X
                        \
                        \ This means that in the following loop, we start the
                        \ drawing process with the first polygon for object #X

.drob5

 STY polygonNumber      \ Set polygonNumber to Y, so we start from the first
                        \ polygon and work through them in order

 LDA objPolygonData,Y   \ Set A to the polygon data byte for the polygon we are
                        \ drawing

 LDX drawingPhaseCount  \ If drawingPhaseCount = 0 then jump to drob6 to skip
 BEQ drob6              \ the following, as there is only one drawing phase for
                        \ this object

 EOR drawingPhase       \ If bit 7 of the polygon data byte does not match bit 7
 BMI drob7              \ of drawingPhase, then we do not draw this polygon in
                        \ this phase, so jump to drob7 to skip drawing the
                        \ polygon and move on to the next one

                        \ If we get here then bit 7 of the polygon data byte
                        \ matches the phase we are currently drawing, so we draw
                        \ the polygon

.drob6

 AND #%00111100         \ Extract bits 2 to 5 from the polygon data byte to get
 STA polygonColours     \ the polygon's edge and fill colours, and put then into
                        \ polygonColours

 LDA objPolygonData,Y   \ Set A to the polygon data byte for the polygon we are
                        \ drawing

 AND #%00000011         \ Extract bits 0 to 1 from the polygon data byte to get
 CLC                    \ the number of sides in the polygon (where 0 means
 ADC #3                 \ three sides and 1 means four sides)
 STA polygonPointCount  \
                        \ Then add 3 to get the number of points in the polygon
                        \ point list, which will be four for a triangle or five
                        \ for a quadrilateral, as the list includes the first
                        \ point repeated at the end
                        \
                        \ And store the result in polygonPointCount

 LDA objPolygonAddrLo,Y \ Set drawViewAngles(1 0) to the address of the list of
 STA drawViewAngles     \ object-relative point numbers for this polygon so the
 LDA objPolygonAddrHi,Y \ DrawPolygon routine can use the yaw and pitch angles
 STA drawViewAngles+1   \ that we calculated for the object points in the
                        \ GetObjPointAngles routine

 JSR DrawPolygon        \ Draw the polygon

 LDY polygonNumber      \ Set Y to the polygon number once again, as the call
                        \ to DrawPolygon will have corrupted it

.drob7

 INY                    \ Increment the polygon number in Y

 CPY objectLastPolygon  \ If we have not yet reached the end of the list, loop
 BCC drob5              \ back to drob5 to draw the next polygon, until we have
                        \ processed all the polygons in the object

 DEC drawingPhaseCount  \ Decrement the drawing phase counter

 BMI drob8              \ If drawingPhaseCount was zero before being decremented
                        \ then there is only one drawing phase, so jump to drob8
                        \ to finish up

 BEQ drob8              \ If drawingPhaseCount was 1 before being decremented
                        \ then there are two drawing phases and we have just
                        \ finished drawing the second phase, so jump to drob8 to
                        \ finish up

                        \ If we get here then drawingPhaseCount was 2 before
                        \ being decremented, so this is a two-phase object and
                        \ we have only drawn the first phase, so now we draw the
                        \ second phase

 LDA #%10000000         \ Set bit 7 of drawingPhase so we now draw the second
 STA drawingPhase       \ phase

 BMI drob4              \ Jump back to drob4 to draw the second phase for the
                        \ two-phase object

.drob8

 LDA #LO(L0C40)         \ Set drawViewAngles(1 0) = L0C40 ???
 STA drawViewAngles     \
 LDA #HI(L0C40)         \ This resets drawViewAngles(1 0) so DrawPolygon will
 STA drawViewAngles+1   \ return to the default setting of drawing using point
                        \ data for tile faces rather than object polygons

 LSR blendPolygonEdges  \ Clear bit 7 of blendPolygonEdges so we return to the
                        \ default setting of allowing drawing polygon edges to
                        \ be a different colour to the polygon fill

 LDY objectToAnalyse    \ Set Y to the number of the object we just drew, so it
                        \ is preserved

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetHorizontalDelta
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the difference in the x-axis and z-axis between two
\             objects, as both signed and absolute deltas
\
\ ------------------------------------------------------------------------------
\
\ This routine calculates the following:
\
\   (xDeltaHi xDeltaLo) = x-coordinate of object #Y - x-coordinate of object #X
\                                                   - xTitleOffset
\
\   xDeltaAbsoluteHi = |xDeltaHi|
\
\   (zDeltaHi zDeltaLo) = z-coordinate of object #Y - z-coordinate of object #X
\
\   zDeltaAbsoluteHi = |zDeltaHi|
\
\ So this calculates the difference (the "delta") in both the x-coordinate and
\ z-coordinate between the two objects, which are the differences along the
\ left-right x-axis and the z-axis the goes into the screen.
\
\ Note that xTitleOffset is zero during gameplay, and is only non-zero when we
\ are drawing large 3D text on the title screen.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of the first object
\
\   Y                   The number of the second object
\
\ ******************************************************************************

.GetHorizontalDelta

                        \ The x-coordinates for each object are stored as 8-bit
                        \ signed integers, with the x-coordinate for object #X
                        \ in xObject+X and for object #Y in xObject+Y
                        \
                        \ We want to calculate the deltas in 16-bit accuracy,
                        \ where the low byte is effectively a fractional part,
                        \ so we can convert these x-coordinates into 16-bit
                        \ numbers like this:
                        \
                        \   * x-coordinate for object #X = (xObject+X 0)
                        \
                        \   * x-coordinate for object #Y = (xObject+Y 0)
                        \
                        \ and we can then do a multi-byte subtraction to get the
                        \ delta, with the title offset included in the
                        \ calculation as (xTitleOffset 0)

 LDA #0                 \ Calculate the following:
 STA xDeltaLo           \
                        \   (xDeltaHi xDeltaLo) = (xObject+Y 0) - (xObject,X 0)
                        \                                    - (xTitleOffset 0)
                        \
                        \ starting with the low byte (which we know will be
                        \ zero)

 SEC                    \ And then subtracting the high bytes
 LDA xObject,Y
 SBC xObject,X
 SEC
 SBC xTitleOffset
 STA xDeltaHi

 BPL delt1              \ If the high byte of the result is positive, jump to
                        \ delt1 as the result in A is already correct for the
                        \ absolute value (i.e. A = xDeltaHi = |xDeltaHi|)

 SEC                    \ The high byte is negative, so set:
 LDA #0                 \
 SBC xDeltaHi           \   A = 0 - xDeltaHi
                        \     = -xDeltaHi
                        \     = |xDeltaHi|

.delt1

 STA xDeltaAbsoluteHi   \ Set xDeltaAbsoluteHi = |xDeltaHi|
                        \
                        \ So we now have the absolute x-axis length in:
                        \
                        \   (xDeltaAbsoluteHi xDeltaLo)
                        \
                        \ and the original high byte of the signed x-axis length
                        \ is still in xDeltaHi

                        \ We now do the same thing, but with the z-coordinates
                        \
                        \ There is no title delta to include for the z-axis
                        \ calculation

 LDA #0                 \ Calculate the following:
 STA zDeltaLo           \
                        \   (zDeltaHi zDeltaLo) = (zObject+Y 0) - (zObject,X 0)
                        \
                        \ starting with the low byte (which we know will be
                        \ zero)

 SEC                    \ And then subtracting the high bytes
 LDA zObject,Y
 SBC zObject,X
 STA zDeltaHi

 BPL delt2              \ If the high byte of the result is positive, jump to
                        \ delt2 as the result in A is already correct for the
                        \ absolute value (i.e. A = zDeltaHi = |zDeltaHi|)

 SEC                    \ The high byte is negative, so set:
 LDA #0                 \
 SBC zDeltaHi           \   A = 0 - zDeltaHi
                        \     = -zDeltaHi
                        \     = |zDeltaHi|

.delt2

 STA zDeltaAbsoluteHi   \ Set zDeltaAbsoluteHi = |zDeltaHi|
                        \
                        \ So we now have the absolute z-axis length in:
                        \
                        \   (zDeltaAbsoluteHi zDeltaLo)
                        \
                        \ and the original high byte of the signed z-axis length
                        \ is still in zDeltaHi

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: GetVerticalDelta
\       Type: Subroutine
\   Category: Maths (Geometry)
\    Summary: Calculate the difference in the y-axis between two objects as a
\             signed delta
\
\ ------------------------------------------------------------------------------
\
\ This routine calculates the following:
\
\   (yDeltaHi yDeltaLo) = y-coordinate of object #Y - y-coordinate of object #X
\
\ So (yDeltaHi yDeltaLo) contains the difference (the "delta") in the
\ y-coordinate between the two objects, which is the difference in altitude.
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   X                   The number of the first object
\
\   Y                   The number of the second object
\
\ ******************************************************************************

.GetVerticalDelta

 LDA yObjectLo,Y        \ Set (yDeltaHi yDeltaLo) = 
 SEC                    \                    (yObjectHi yObjectLo) for object #Y
 SBC yObjectLo,X        \                  - (yObjectHi yObjectLo) for object #X
 STA yDeltaLo           \
                        \ starting with the low bytes

 LDA yObjectHi,Y        \ And then the high bytes 
 SBC yObjectHi,X
 STA yDeltaHi

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: ReadKeyboard
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Enable the keyboard and read a character from it
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   The character read from the keyboard
\
\ ******************************************************************************

.ReadKeyboard

 JSR EnableKeyboard     \ Select the keyboard as the input stream and flush the
                        \ keyboard buffer

                        \ Fall through into ReadCharacter to read a character
                        \ from the keyboard and return it in A

\ ******************************************************************************
\
\       Name: ReadCharacter
\       Type: Subroutine
\   Category: Keyboard
\    Summary: Read a character from the currently selected input stream
\
\ ------------------------------------------------------------------------------
\
\ Returns:
\
\   A                   The character read from the input stream, in ASCII
\
\ ******************************************************************************

.ReadCharacter

 JSR OSRDCH             \ Read a character from the currently selected input
                        \ stream into A

 BCC read1              \ If the C flag is clear then the call to OSRDCH read a
                        \ valid character, so jump to read1 to return from the
                        \ subroutine

 CMP #27                \ If the character read is not ESCAPE, jump to read1 to
 BNE read1              \ return from the subroutine

                        \ If we get here then we have an ESCAPE condition, so we
                        \ need to acknowledge it and try again

 TYA                    \ Store Y on the stack to we can preserve it through the
 PHA                    \ call to OSBYTE

 LDA #126               \ Call OSBYTE with A = 126 to acknowledge the ESCAPE
 JSR OSBYTE             \ condition

 PLA                    \ Retrieve Y from the stack
 TAY

 JMP ReadCharacter      \ Loop back to read another character

.read1

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: EnableKeyboard
\       Type: Subroutine
\   Category: Keybpard
\    Summary: Select the keyboard as the input stream and flush the keyboard
\             buffer
\
\ ******************************************************************************

.EnableKeyboard

 LDA #2                 \ Call OSBYTE with A = 2 and X = 0 to select the
 LDX #0                 \ keyboard as the input stream and disable the RS423
 JSR OSBYTE

 LDX #0                 \ Set X = 0 to denote the keyboard buffer

 JMP FlushBuffer        \ Call FlushBuffer to flush the keyboard buffer and
                        \ return from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: SetColourPalette
\       Type: Subroutine
\   Category: Graphics
\    Summary: Set the logical colours for each of the four physical colours in
\             screen mode 5
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   Defines how the four physical colours in the mode 5
\                       palette are set:
\
\                         * If bit 7 is clear then bits 0-6 contain the physical
\                           colour to set for all four logical colours (so the
\                           screen is effectively blanked to this colour)
\
\                         * If bit 7 is set then bits 0-6 contain the offset
\                           within the colourPalettes table of the last of the
\                           four physical colours to set for logical colours
\                           3, 2, 1 and 0 (so we work backwards through the
\                           table from the offset in bits 0-6)
\
\ ******************************************************************************

.SetColourPalette

 STA T                  \ Store the argument in T

 AND #%01111111         \ Extract bits 0-6 of the argument into Y
 TAY

 LDA #3                 \ We now work through the logical colours from 3 down
 STA U                  \ to 0, setting the physical colour for each one in
                        \ turn, so set a logical colour counter in U

.pall1

 LDX T                  \ Set X to the argument in T

 BPL pall2              \ If bit 7 of the argument in T is clear, skip the
                        \ following instruction, so X contains the physical
                        \ colour in the routine's argument (i.e. the colour to
                        \ which we set all four logical colours)

                        \ If we get here then bit 7 of the argument in T is set,
                        \ which means bits 0-6 contain the offset within the
                        \ colourPalettes table of the four physical colours in
                        \ the palette
                        \
                        \ We set Y above to the value of bits 0-6, so we can use
                        \ this as the index into the colourPalettes table (we
                        \ will decrement Y below for each of the four colours,
                        \ so we end up setting all four logical colours to the
                        \ four values in the table)

 LDX colourPalettes,Y   \ Fetch the physical colour from the Y-th entry in
                        \ colourPalettes, which we now want to allocate to
                        \ logical colour U

.pall2

 LDA #19                \ Start a VDU 19 command, which sets a logical colour to
 JSR OSWRCH             \ a physical colour using the following format:
                        \
                        \   VDU 19, logical, physical, 0, 0, 0
                        \
                        \ which we output as follows:
                        \
                        \   VDU 19, U, X, 0, 0, 0

 LDA U                  \ Write the value in U, which is the logical colour we
 JSR OSWRCH             \ want to define

 TXA                    \ Set A to the value in X

 LDX #4                 \ Set X = 4 to use as a byte counter as we output the
                        \ physical colour and three zeroes

.pall3

 JSR OSWRCH             \ Write the value in A, which is the physical colour we
                        \ want to set (in the first iteration of the loop), or
                        \ one of three trailing zeroes (in later iterations)

 LDA #0                 \ Set A = 0 so the remaining three iterations of the
                        \ loop output the trailing zeroes

 DEX                    \ Decrement the byte counter

 BNE pall3              \ Loop back until we have output the whole VDU command

 DEY                    \ Decrement the colourPalettes index in Y

 DEC U                  \ Decrement the logical colour counter in U

 BPL pall1              \ Loop back until we have defined the logical colours
                        \ for all four physical colours

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: colourPalettes
\       Type: Variable
\   Category: Graphics
\    Summary: The logical colours for two mode 5 palettes
\
\ ------------------------------------------------------------------------------
\
\ This table contains the logical colours that are set in the SetColourPalette
\ routine when it is called with an argument with bit 7 set. This routine is
\ only ever called with an argument of &83 or &87.
\
\ If the argument to SetColourPalette is &83 then the palette is set to the
\ correct colours for playing the current landscape. The colours are set in the
\ SpawnEnemies routine when the landscape is generated. Colours 0 and 1 are
\ always blue and black, but colours 2 and 3 are set to different physical
\ colours depending on the number of enemies in the landscape. The different
\ palettes are as follows:
\
\   * Enemy count = 1: blue, black, white, green
\
\   * Enemy count = 2: blue, black, yellow, red
\
\   * Enemy count = 3: blue, black, cyan, yellow
\
\   * Enemy count = 4: blue, black, red, cyan
\
\   * Enemy count = 5: blue, black, white, red
\
\   * Enemy count = 6: blue, black, yellow, cyan
\
\   * Enemy count = 7: blue, black, cyan, red
\
\   * Enemy count = 8: blue, black, red, yellow
\
\ Landscape 0000 has one enemy, so the starting landscape is therefore in blue,
\ black, white and green.
\
\ If the argument to SetColourPalette is &87, the palette is set as follows:
\
\   * Colour 0 = 4 (blue)
\
\   * Colour 1 = 0 (black)
\
\   * Colour 2 = 1 (red)
\
\   * Colour 3 = 3 (yellow)
\
\ This palette is fixed and is used for the title screens.
\
\ ******************************************************************************

.colourPalettes

 EQUB 4, 0, 6, 3        \ Palette with SetColourPalette offset 3

 EQUB 4, 0, 1, 3        \ Palette with SetColourPalette offset 7

\ ******************************************************************************
\
\       Name: sub_C5E5F
\       Type: Subroutine
\   Category: ???
\    Summary: ???
\
\ ******************************************************************************

.sub_C5E5F

 LDA #&FF
 STA L0CD2
 LDA bufferColumns
 ASL A
 ASL A
 ASL A
 STA L0CD3
 SEC
 SBC #&01
 BEQ C5E7B
 LDY #&FF

.P5E74

 ASL A
 INY
 BCC P5E74
 LDA leadingBitMask,Y

.C5E7B

 STA L0CCF

.C5E7E

 SEI

 JSR GetRandomNumber    \ Set A to a random number

 LDY randomGenerator+1
 STY L0CD0
 CLI
 CLC
 ADC L0CCD
 AND L0CCF
 CMP L0CD3
 BCC C5E98
 SBC L0CD3

.C5E98

 STA L0CCD
 LDA L0CD0
 AND #&1F
 STA L0013
 LSR A
 CLC
 ADC L0013
 AND #&FE
 STA L0013
 ASL A
 ASL A
 ADC L0013
 STA L0013
 LDA #0
 LSR L0013
 ROR A
 LSR L0013
 ROR A
 LSR L0013
 ROR A
 ADC L0CCD
 STA fromAddr
 LDA L0013
 ADC #&00
 STA fromAddr+1
 LDA L2092
 CLC
 ADC fromAddr
 STA toAddr
 LDA L2092+1
 ADC fromAddr+1
 CMP #&80
 BCC C5ED9
 SBC #&20

.C5ED9

 STA toAddr+1
 LDA fromAddr+1
 CLC
 ADC #&3F
 STA fromAddr+1
 CMP #&53
 BCC C5EF3
 LDA fromAddr
 SEC
 SBC #&60
 STA fromAddr
 LDA fromAddr+1
 SBC #&13
 STA fromAddr+1

.C5EF3

 LDA L0CD0
 ASL A
 ROL A
 ROL A
 AND #&03
 TAX
 LDY #0
 LDA (fromAddr),Y
 AND pixelBitMask,X
 STA L0013
 LDA (toAddr),Y
 AND clearPixelMask,X
 ORA L0013
 STA (toAddr),Y

 BIT L0C1E              \ If bit 7 of L0C1E is set, jump to CRE41 to return from
 BMI CRE41              \ the subroutine

 DEC L0CD2
 BNE C5F20

 JSR ProcessSound       \ Process any sounds or music that are being made in the
                        \ background

 DEC L2094
 BEQ CRE41

.C5F20

 JMP C5E7E

.CRE41

 RTS

\ ******************************************************************************
\
\       Name: ShowGameOverScreen
\       Type: Subroutine
\   Category: Title screen
\    Summary: Display the game over screen
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number of 2400-dot plotting cycles to perform when
\                       decaying the screen from the landscape view to the game
\                       over screen
\                       
\                         * 5 = 12,000 dots for when the player runs out of
\                               energy when trying to hyperspace
\                       
\                         * 30 = 72,000 dots for when the player is absorbed by
\                                the Sentinel
\
\   titleObjectToDraw   The type of object to draw on the game over screen
\
\                         * ???
\
\ ******************************************************************************

.ShowGameOverScreen

 PHA                    \ Store the argument in A on the stack, so we can fetch
                        \ it later

 JSR FlushSoundBuffers  \ Flush all four sound channel buffers

 JSR ClearIconsScanner  \ Clear the energy icon and scanner row at the top of
                        \ the screen

 LDA #6                 \ Set soundEffect = 6 so the sound is processed as the
 STA soundEffect        \ game over sound

 LDA #250               \ Set gameOverSoundPitch = 250 to start the sound effect
 STA gameOverSoundPitch \ processing for the game over sound

 PLA                    \ Retrieve the argument A from the stack, so it contains
                        \ the number of black dots to draw on the screen

 JSR DecayScreenToBlack \ Decay the screen to black with a mass of A * 2400
                        \ randomly placed black dots

 LDY #0                 \ Set sightsByteCount to zero to reset the sights pixel
 STY sightsByteCount    \ byte stash

 STY sightsAreVisible   \ Clear bit 7 of sightsAreVisible to indicate that the
                        \ sights are not visible

 LDA titleObjectToDraw  \ Call SpawnTitleObject to spawn an object of type
 JSR SpawnTitleObject   \ titleObjectToDraw as object #1, using the
                        \ configuration specified in Y (i.e. 0) so the object
                        \ is spawned for use in the game over screen

 LDA #3                 \ Set screenBackground = 3 so the next time the screen
 STA screenBackground   \ is cleared, it shows a black background with stars

 LDA #1                 \ Set currentObject = 1 ???
 STA currentObject

 LDA #%11000000         \ Set bits 6 and 7 of L0C4D ???
 STA L0C4D

 STA L0C6D              \ Set bits 6 and 7 of L0C6D ???

 LSR L0C1E              \ Clear bit 7 of L0C1E ???

 LDA #50                \ Call the PlayMusic routine with A = 50 to play the
 JSR PlayMusic          \ game over music

 JSR sub_C1F84          \ ???

 LDA #30                \ Smother the screen in 30 * 2400 = 72,000 randomly
 JMP DecayScreenToBlack \ placed black dots to decay the screen to black,
                        \ returning from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: DecayScreenToBlack
\       Type: Subroutine
\   Category: Graphics
\    Summary: Smother the screen with randomly placed black dots to decay the
\             screen to black
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number of 2400-dot plotting cycles to perform when
\                       decaying the screen
\
\ ******************************************************************************

.DecayScreenToBlack

 STA blackDotCounter    \ Set blackDotCounter to the number of 2400-dot
                        \ plotting cycles we need to perform

.deca1

 LDA #30                \ Set loopCounter = 30 for the inner loop, so each
 STA loopCounter        \ iteration of the inner loop draws 30 * 80 = 2400 dots

.deca2

 JSR DrawBlackDots      \ Draw 80 randomly positioned dots on the screen in
                        \ colour 1 (black) to fade the screen to black in a
                        \ slowly decaying manner

 JSR ProcessSound       \ Process any sounds or music that are being made in the
                        \ background

 DEC loopCounter        \ Loop back to plot another 80 dots until we have done
 BNE deca2              \ this 30 times (to give a total of 2400 dots)

 DEC blackDotCounter    \ Loop back to plot 80 * 30 dots until we have done this
 BNE deca1              \ blackDotCounter times (to give a total of
                        \ 2400 * blackDotCounter dots)

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: JumpToPreview
\       Type: Subroutine
\   Category: Cracker protection
\    Summary: An intentionally confusing jump point for controlling the main
\             title loop flow when returning from the GenerateLandscape routine
\
\ ******************************************************************************

.JumpToPreview

 EQUB &4C               \ This byte is never executed, as the stack modification
                        \ in the SmoothTileData routine sets the return address
                        \ on the stack to JumpToPreview, and the RTS instruction
                        \ will therefore jump to JumpToPreview+1 (as that's how
                        \ the RTS instruction works)
                        \
                        \ This byte is the opcode for a JMP instruction, so this
                        \ makes it look like there is a JumpToPreview routine
                        \ that contains the following:
                        \
                        \   &4C &30 &3F     JMP &3F30
                        \
                        \ as the BMI instruction below assembles into &30 &3F
                        \
                        \ This would jump to a valid instruction halfway through
                        \ the ConfigureMachine routine, so this byte, although
                        \ unused, is presumably a JMP opcode to confuse any
                        \ crackers who have reached this point in their analysis

 BMI PreviewLandscape   \ We only get here if the stack has been modified by the
                        \ SmoothTileData routine, which makes the RTS at the end
                        \ end of the GenerateLandscape routine jump here
                        \
                        \ The penultimate instruction in GenerateLandscape is a
                        \ call to the ProcessTileData routine, which happens to
                        \ set the N flag, so when the RTS instruction jumps here
                        \ using the modified return address, this BMI branch is
                        \ taken, so this instruction is effectively a JMP to the
                        \ PreviewLandscape routine

\ ******************************************************************************
\
\       Name: SpawnTitleObject
\       Type: Subroutine
\   Category: Title screen
\    Summary: Spawn the title object (robot or the Sentinel) as object #1
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The type of object to spawn
\
\   Y                   The configuration to use when spawning the object:
\
\                         * 0 = the object on the game over screen (i.e. the
\                               enemy that ended the game)
\
\                         * 1 = the Sentinel on the main title screen or the
\                               robot on the secret code screen
\
\                         * 2 = the tower on which the Sentinel or robot stands
\
\ ******************************************************************************

.SpawnTitleObject

                        \ We set up the object that we want to draw on the title
                        \ screen in object #1, and we set up the viewing object
                        \ for that object in object #2
                        \
                        \ The values come from the Y-th entry in each of the
                        \ following configuration tables, so this routine sets
                        \ up the following, depending on the object that we are
                        \ spawning:
                        \
                        \   * Object #1 (the object to draw) is set to a yaw
                        \     of 128 for the game over screen (so the enemy
                        \     stares directly out of the screen), or -114 for the
                        \     object on the tower (so it looks towards the left
                        \     of the viewer) or -50 for the tower (so it is
                        \     rotated slightly to the left)
                        \
                        \   * Object #1 (the object to draw) is set to a yaw
                        \     of 128 for the game over screen, so the enemy
                        \     stares directly out of the screen
                        \
                        \   * Object #1 (the object to draw) is set to a yaw
                        \     of -114 for the object on the tower, so the robot
                        \     or Sentinel looks out of the screen, towards the
                        \     left of the viewer
                        \
                        \   * Object #1 (the object to draw) is set to a yaw
                        \     of -50 for the tower, so it is rotated slightly to
                        \     the left
                        \
                        \   * Object #2 (the viewing object) is set to a pitch
                        \     of -12 for the game over screen, so the camera
                        \     points down, thus moving the object down the
                        \     screen
                        \
                        \   * Object #2 (the viewing object) is set to a pitch
                        \     of -5 and a yaw of -8 for the title screen, so the
                        \     camera points down and left, thus moving the tower
                        \     and object to the right
                        \
                        \   * Object #1 is always at the same x-coordinate as
                        \     the viewing object
                        \
                        \   * The tower and game over objects are at the same
                        \     y-coordinate as the viewer (so they at the same
                        \     altitude)
                        \
                        \   * The object on the tower is higher than the viewer
                        \     by one y-coordinate
                        \
                        \   * The game over object is at a z-coordinate distance
                        \     of 5 from the viewer, while the object and tower
                        \     are at a distance of 7

 STA objectTypes+1      \ Set the object type for object #1 to the argument in A

 LDA zTitleObject,Y     \ Set the z-coordinate for object #1 to the z-coordinate
 CLC                    \ of object #2 plus the Y-th entry from the zTitleObject
 ADC zObject+2          \ table
 STA zObject+1

 LDA yObjectHi+2        \ Set the high byte of the y-coordinate for object #1 to
 CLC                    \ the high byte of the y-coordinate of object #2 plus
 ADC yTitleObject,Y     \ the Y-th entry from the yTitleObject table
 STA yObjectHi+1

 LDA xObject+2          \ Set the x-coordinate for object #1 to the x-coordinate
 STA xObject+1          \ of object #2

 LDA titleViewerPitch,Y \ Set the pitch angle of the viewer in object #2 to the
 STA objectPitchAngle+2 \ Y-th entry from the titleViewerPitch table

 LDA titleViewerYaw,Y   \ Set the yaw angle of the viewer in object #2 to the
 STA objectYawAngle+2   \ Y-th entry from the titleViewerYaw table

 LDA #0                 \ Zero the low bytes of the y-coordinates for both
 STA yObjectLo+2        \ objects
 STA yObjectLo+1

 LDA titleObjectYaw,Y   \ Set the yaw angle of object #1 to the Y-th entry from
 STA objectYawAngle+1   \ the titleObjectYaw

 LDX #2                 \ Set the viewing object to object #2 so the screen will
 STX viewingObject      \ be drawn from this perspective

 RTS                    \ Return from the subroutine

\ ******************************************************************************
\
\       Name: zTitleObject
\       Type: Variable
\   Category: Title screen
\    Summary: The z-coordinate of an object on the title screen, as a delta from
\             the z-coordinate of the viewing object
\
\ ******************************************************************************

.zTitleObject

 EQUB 5                 \ Object 0 = the game over object

 EQUB 7                 \ Object 1 = the object on the tower

 EQUB 7                 \ Object 2 = the tower

\ ******************************************************************************
\
\       Name: PreviewLandscape
\       Type: Subroutine
\   Category: Landscape
\    Summary: Draw an aerial preview of the landscape
\
\ ******************************************************************************

.PreviewLandscape

 JSR SpawnEnemies       \ Calculate the number of enemies for this landscape,
                        \ add them to the landscape and set the palette
                        \ accordingly

 LDX #3                 \ Set X = 3 to pass to DrawTitleView so the background
                        \ of the landscape preview is black with stars

 LDY #0                 \ Set Y = 0 to pass to DrawTitleView so it draws the
                        \ screen with the correct perspective for the landscape
                        \ preview

 LDA #&80               \ Set A = &80 so the call to DrawTitleView draws the
                        \ landscape preview

 JSR DrawTitleView      \ Draw the landscape preview

 LDX #4                 \ Print text token 4: Background colour black, print
 JSR PrintTextToken     \ "PRESS ANY KEY" at (192, 64), print "LANDSCAPE" two
                        \ characters right of (64, 768), move cursor right

 JSR PrintLandscapeNum  \ Print the four-digit landscape number (0000 to 9999)

 JSR SpawnPlayer        \ Add the player and trees to the landscape
                        \
                        \ If the entered secret entry code in the keyboard input
                        \ buffer does not match the generated secret code for
                        \ this landscape then the call will return here so we
                        \ can display an error
                        \
                        \ If the codes match then the CheckSecretCode will jump
                        \ to the PlayGame routine instead to play the game

 JMP SecretCodeError    \ The entered secret entry in the keyboard input buffer
                        \ does not match the generated secret code for this
                        \ landscape, so jump to SecretCodeError to display the
                        \ "WRONG SECRET CODE" error, wait for a key press and
                        \ rejoin the main title loop

\ ******************************************************************************
\
\       Name: titleViewerPitch
\       Type: Variable
\   Category: Title screen
\    Summary: The pitch angle of the viewer for objects on the title screen
\
\ ******************************************************************************

.titleViewerPitch

 EQUB -12               \ Object 0 = when viewing the game over object

 EQUB -5                \ Object 1 = when viewing the object on the tower

 EQUB -5                \ Object 2 = when viewing the tower

\ ******************************************************************************
\
\       Name: yTitleObject
\       Type: Variable
\   Category: Title screen
\    Summary: The y-coordinate of an object on the title screen, as a delta from
\             the y-coordinate of the viewing object
\
\ ******************************************************************************

.yTitleObject

 EQUB 0                 \ Object 0 = the game over object

 EQUB 1                 \ Object 1 = the object on the tower

 EQUB 0                 \ Object 2 = the tower

\ ******************************************************************************
\
\       Name: titleObjectYaw
\       Type: Variable
\   Category: Title screen
\    Summary: The yaw angle of an object on the title screen
\
\ ******************************************************************************

.titleObjectYaw

 EQUB 128               \ Object 0 = the game over object

 EQUB -114              \ Object 1 = the object on the tower

 EQUB -50               \ Object 2 = the tower

\ ******************************************************************************
\
\       Name: titleViewerYaw
\       Type: Variable
\   Category: Title screen
\    Summary: The yaw angle of the viewer for objects on the title screen
\
\ ******************************************************************************

.titleViewerYaw

 EQUB 0                 \ Object 0 = when viewing the game over object

 EQUB -8                \ Object 1 = when viewing the object on the tower

 EQUB -8                \ Object 2 = when viewing the tower

\ ******************************************************************************
\
\       Name: DrawTitleObjects
\       Type: Subroutine
\   Category: Title screen
\    Summary: ???
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The type of object to draw on top of a tower on the
\                       right side of the screen:
\
\                         * 0 to draw a robot for the secret code screen
\
\                         * 5 to draw the Sentinel for the main title screen
\                       
\ ******************************************************************************

.DrawTitleObjects

                        \ We start by drawing a robot or the Sentinel, according
                        \ to the object type in A

 LDY #1                 \ Set Y = 1 so the call to DrawTitleObject chooses the
                        \ configuration for the object standing on the tower in
                        \ the main title screen or secret code screen

 JSR DrawTitleObject    \ Draw an object of type A, so that's either a robot or
                        \ the Sentinel

                        \ We now draw the tower on which the robot or Sentinel
                        \ standing

 LDY #2                 \ Set Y = 2 so the call to DrawTitleObject chooses the
                        \ configuration for the tower on which the robot or
                        \ Sentinel is standing

 LDA #6                 \ Set A to 6, the object type for the Sentinel's tower,
                        \ so DrawTitleObject draws the tower

                        \ Fall through into DrawTitleObject to draw the tower
                        \ beneath the robot or the Sentinel

\ ******************************************************************************
\
\       Name: DrawTitleObject
\       Type: Subroutine
\   Category: Title screen
\    Summary: Draw an object on the title screen
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The type of object to draw
\
\   Y                   The configuration to use when drawing the object:
\
\                         * 1 = the Sentinel on the main title screen or the
\                               robot on the secret code screen
\
\                         * 2 = the tower on which the Sentinel or robot stands
\
\ ******************************************************************************

.DrawTitleObject

 JSR SpawnTitleObject   \ Call SpawnTitleObject to spawn an object of type A in
                        \ object #1, using the configuration specified in Y

 LDY #1                 \ Call DrawObject with Y = 1 to draw object #1 and return
 JMP DrawObject         \ from the subroutine using a tail call

\ ******************************************************************************
\
\       Name: PlayMusic
\       Type: Subroutine
\   Category: Sound
\    Summary: Play a piece of music
\
\ ------------------------------------------------------------------------------
\
\ Arguments:
\
\   A                   The number of the music to play (which is expressed as
\                       a byte offset into the music data at musicData):
\
\                         * 0 = hyperspace
\
\                         * 25 = player has just transferred onto the Sentinel's
\                                tower
\
\                         * 40 = U-turn
\
\                         * 50 = game over
\
\                         * 66 = landscape successfully finished
\
\ ******************************************************************************

.PlayMusic

 STA musicCounter       \ Set the musicCounter to the value in A to start the
                        \ music playing from this point

 LDA #3                 \ Set soundEffect = 3 to tell the ProcessSound routine
 STA soundEffect        \ that this is music and should therefore be processed
                        \ using the ProcessMusic routine

 RTS                    \ Return from the subroutine

 EQUB &23               \ This byte appears to be unused

\ ******************************************************************************
\
\       Name: ConfigureMachine
\       Type: Subroutine
\   Category: Setup
\    Summary: Configure the custom screen mode, set the break handler to clear
\             memory, move code, reset timers and set the interrupt handler
\
\ ------------------------------------------------------------------------------
\
\ The custom screen mode is based on screen mode 5, but with only 25 character
\ rows rather than 32. This gives the game screen a letterbox appearance.
\
\ The custom mode has a vertical resolution of 25 * 8 = 200 pixels, compared to
\ the 256 pixels of standard mode 5. The horizontal resolution is the same at
\ 160 pixels.
\
\ Screen memory for the custom mode runs from &6000 to &7F3F, with four pixels
\ per byte and four colours per pixel.
\
\ ******************************************************************************

 CLEAR &3F00, &4100     \ Memory from &3F00 to &4100 has three separate uses
 ORG &3F00              \
                        \ During startup it is used to store the startup
                        \ routines ConfigureMachine and ClearMemory, which
                        \ aren't needed again once the game has started
                        \
                        \ While the landscape is being generated it is used to
                        \ store the secret code stash at secretCodeStash
                        \
                        \ While the game is running it is used to store the
                        \ first few rows of the screen buffer, starting from
                        \ screenBufferRow0
                        \
                        \ These lines rewind BeebAsm's assembly back to &3F00
                        \ and clear the block from that point to the end of the
                        \ startup code at &4100, so we can assemble the startup
                        \ routines
                        \
                        \ At the end of the ClearMemory routine, the initial
                        \ contents of the game binary actually contains snippets
                        \ of the original source code, left over from the BBC
                        \ Micro assembly process, so we include this workspace
                        \ noise to ensure that we generate an exact match for
                        \ the game binary

 SEC                    \ Set bit 7 of gameInProgress to indicate that a game is
 ROR gameInProgress     \ not currently in progress and that we are in the title
                        \ and preview screens (so the interrupt handler doesn't
                        \ progress the game)
                        \
                        \ This code is never actually run in this location
                        \ (identical code can be found at the start of the
                        \ ResetVariables routine)

.ConfigureMachine

 LDA #4                 \ Call OSBYTE with A = 4, X = 1 and Y = 0 to disable
 LDY #0                 \ cursor editing
 LDX #1
 JSR OSBYTE

 LDA #144               \ Call OSBYTE with A = 144, X = 0 and Y = 0 to switch
 LDX #0                 \ interlace on
 LDY #0
 JSR OSBYTE

 LDA #22                \ Switch to screen mode 5 with the following VDU
 JSR OSWRCH             \ command:
 LDA #5                 \
 JSR OSWRCH             \   VDU 22, 5

 SEI                    \ Disable interrupts so we can update the 6845 registers

 LDA #6                 \ Set 6845 register R6 = 25
 STA SHEILA+&00         \
 LDA #25                \ This is the "vertical displayed" register, which sets
 STA SHEILA+&01         \ the number of displayed character rows to 25. For
                        \ comparison, this value is 32 for standard mode 5, but
                        \ we claw back seven rows to create the game's letterbox
                        \ screen mode

 LDA #7                 \ Set 6845 register R7 = 32
 STA SHEILA+&00         \
 LDA #32                \ This is the "vertical sync position" register, which
 STA SHEILA+&01         \ determines the vertical sync position with respect to
                        \ the reference, programmed in character row times. For
                        \ comparison this is 34 for mode 5, but it needs to be
                        \ adjusted for our custom screen's vertical sync

 LDA #10                \ Set 6845 register R10 = %00100000
 STA SHEILA+&00         \
 LDA #%00100000         \ This is the "cursor start" register, and bits 5 and 6
 STA SHEILA+&01         \ define the "cursor display mode", as follows:
                        \
                        \   * %00 = steady, non-blinking cursor
                        \
                        \   * %01 = do not display a cursor
                        \
                        \   * %10 = fast blinking cursor (blink at 1/16 of the
                        \           field rate)
                        \
                        \   * %11 = slow blinking cursor (blink at 1/32 of the
                        \           field rate)
                        \
                        \ We can therefore turn off the cursor completely by
                        \ setting cursor display mode %01, with bit 6 of R10
                        \ clear and bit 5 of R10 set

 CLI                    \ Re-enable interrupts

 LDA #151               \ Call OSBYTE with A = 151, X = &42 and Y = %11111111 to
 LDX #&42               \ write the value %11111111 to SHEILA+&42
 LDY #%11111111         \
 JSR OSBYTE             \ This sets the direction of all eight ports of the 6522
                        \ System VIA to output by setting the corresponding bits
                        \ in the Data Direction Register B (SHEILA &42)

 LDA #151               \ Call OSBYTE with A = 151, X = &40 and Y = %00000101 to
 LDX #&40               \ write the value %00000101 to SHEILA+&40
 LDY #%00000101         \
 JSR OSBYTE             \ Writing a value of %vaaa to SHEILA+&40 writes to the
                        \ System VIA's addressable latch, setting latch address
                        \ %aaa to value v
                        \
                        \ This therefore sets address %101 to 1, which is
                        \ address B5 in the System VIA
                        \
                        \ We now we set B4 as well

 LDA #151               \ Call OSBYTE with A = 151, X = &40 and Y = %00001100 to
 LDX #&40               \ write the value %00001100 to SHEILA+&40
 LDY #%00001100         \
 JSR OSBYTE             \ Writing a value of %vaaa to SHEILA+&40 writes to the
                        \ System VIA's addressable latch, setting latch address
                        \ %aaa to value v
                        \
                        \ This therefore sets address %100 to 0, which is
                        \ address B4 in the System VIA
                        \
                        \ B4 and B5 in the System VIA control the address of the
                        \ start of screen memory and the screen size, so this
                        \ sets screen memory to &6000 and screen size to 8K (see
                        \ page 429 of the "Advanced User Guide for the BBC
                        \ Micro" by Bray, Dickens and Holmes for details)

 LDA #0                 \ Call OSBYTE with A = 0 and X = 255 to fetch the
 LDX #255               \ operating system version into X
 JSR OSBYTE

 CPX #0                 \ If X = 0 then this is either a BBC Micro running an
 BEQ setp1              \ operating system version of 1.00 or earlier, or it's
                        \ an Electron, so in either case jump to setp1 to skip
                        \ the following

                        \ If we get here then this is not an Electron or an
                        \ early operating system, so it must be a BBC Micro with
                        \ MOS 1.20 or later, or a BBC Master

 LDA #200               \ Call OSBYTE with A = 200, X = 2 and Y = 0 to set the
 LDX #2                 \ normal action for the ESCAPE key and clear memory if
 LDY #0                 \ the BREAK key is pressed
 JSR OSBYTE

 JMP setp3              \ Jump to setp3 to skip the setup for the Electron

.setp1

                        \ If we get here then this is either a BBC Micro running
                        \ MOS 1.00 or earlier, or it's an Electron
                        \
                        \ In MOS 0.10, OSBYTE 200 does not let you set the BREAK
                        \ key to clear memory, so we need to set this up by hand
                        \ (otherwise crackers could load the game on MOS 0.10
                        \ and simply press BREAK to access the loaded game code)
                        \
                        \ The Electron and MOS 1.00 do not need this code, as
                        \ OSBYTE 200 is supported in these versions of the
                        \ operating system, but OSBYTE 0 doesn't distinguish
                        \ between the Electron and MOS 1.00 and earlier (they
                        \ all return X = 0)
                        \
                        \ There's no harm in manually clearing memory on those
                        \ systems, though, so the following code is run on
                        \ BREAK on MOS 1.00 and earlier and on the Electron
                        \
                        \ To set this up, we copy the break handler routine from
                        \ ClearMemory to address BRKI (this points to the
                        \ cassette filing system workspace, which is unused
                        \ now that the game is loaded, so it's a suitable
                        \ location for our handler)

 LDX #&1C               \ Set a counter in X for the size of the ClearMemory
                        \ routine

.setp2

 LDA ClearMemory,X      \ Copy the X-th byte of the ClearMemory routine into the
 STA BRKI,X             \ X-th byte of BRKI

 DEX                    \ Decrement the byte counter

 BPL setp2              \ Loop back until we have copied the whole ClearMemory
                        \ routine to BRKI

 LDA #&4C               \ Set the Break Intercept code to the following, so that
 STA BRKIV              \ BRKI gets called when the BREAK key is pressed:
 LDA #LO(BRKI)          \
 STA BRKIV+1            \    4C 80 03   JMP BRKI
 LDA #HI(BRKI)          \
 STA BRKIV+2            \ &4C is the opcode for the JMP instruction, and BRKI is
                        \ at address &0380 (part of the cassette filing system
                        \ workspace)

.setp3

                        \ Next we copy a block of game code in memory as
                        \ follows:
                        \
                        \   * &4100-&49FF is copied to &5800-&60FF
                        \
                        \ The game binary could easily have been structured to
                        \ avoid this copy, so presumably it's just done to make
                        \ the game code harder to crack

 LDA #&00               \ Set (Q P) = &4100
 STA P                  \
 STA R                  \ We use this as the source address for the copy
 LDA #&41
 STA Q

 LDA #&58               \ Set (S R) = &5800
 STA S                  \
                        \ We use this as the destination address for the copy

.setp4

 LDY #0                 \ Set up a byte counter in Y

.setp5

 LDA (P),Y              \ Copy the Y-th byte of (Q P) to the Y-th byte of (S R)
 STA (R),Y

 DEY                    \ Decrement the byte counter

 BNE setp5              \ Loop back until we have copied a whole page of bytes

 INC Q                  \ Increment the high byte of (Q P) to point to the next
                        \ page in memory

 INC S                  \ Increment the high byte of (S R) to point to the next
                        \ page in memory

 LDA Q                  \ Loop back until (Q P) reaches &4A00, at which point we
 CMP #&4A               \ have copied the whole block of memory
 BCC setp4

 SEI                    \ Disable interrupts so we can update the interrupt
                        \ vector and VIA

 LDA IRQ1V              \ Store the current address from the IRQ1V vector in
 STA irq1Address        \ irq1Address, so the IRQ handler can jump to it after
 LDA IRQ1V+1            \ implementing the custom interrupt handler
 STA irq1Address+1

                        \ We now wait for the vertical sync, which we can check
                        \ by reading bit 1 of the 6522 System VIA status byte
                        \ (SHEILA &4D), which is set if vertical sync has
                        \ occurred on the video system

 LDA #%00000010         \ Set a bit mask in A that we can use to read bit 1 of
                        \ the 6522 System VIA status byte

.setp6

 BIT SHEILA+&4D         \ Loop around until bit 1 of the 6522 System VIA status
 BEQ setp6              \ byte is set, so we wait until the vertical sync

                        \ We now set timer 1 in the 6522 User VIA to count down
                        \ regularly, triggering the interrupt handler routine at
                        \ IRQHandler every time it counts down
                        \
                        \ The timer is initially set to count down from 14,592
                        \ to zero, and then a value of 19,998 is latched into
                        \ the timer so that it triggers the interrupt every time
                        \ it counts down from 20,000 to zero (the latching
                        \ process takes two ticks, which gives us a total count
                        \ of 20,000)
                        \
                        \ The timer counts down at 1 MHz. or one million times a
                        \ second, so this means the interrupt is triggered every
                        \ 0.02 seconds, or exactly 50 times a second
                        \
                        \ This regular interrupt is used to progress the game
                        \ counters and manage the screen panning effect (see the
                        \ IRQHandler routine for details)

 LDA #%01000000         \ Set 6522 User VIA auxiliary control register ACR
 STA SHEILA+&6B         \ (SHEILA &6B) bits 7 and 6 to disable PB7 (which is one
                        \ of the pins on the user port) and set continuous
                        \ interrupts for timer 1

 LDA #%11000000         \ Set 6522 User VIA interrupt enable register IER
 STA SHEILA+&6E         \ (SHEILA &4E) bits 6 and 7 (i.e. enable the Timer1
                        \ interrupt from the User VIA)

 LDA #&00               \ Set 6522 User VIA T1C-L timer 1 low-order counter
 STA SHEILA+&64         \ (SHEILA &64) to &00 (so this sets the low-order
                        \ counter but does not start counting until the
                        \ high-order counter is set)

 LDA #&39               \ Set 6522 User VIA T1C-H timer 1 high-order counter
 STA SHEILA+&65         \ (SHEILA &45) to &39 to start the T1 counter
                        \ counting down from &3900 (14592) at a rate of 1 MHz

 LDA #&1E               \ Set 6522 User VIA T1L-L timer 1 low-order latches
 STA SHEILA+&66         \ to &1E (so this sets the low-order counter but does
                        \ not start counting until the high-order counter is
                        \ set)

 LDA #&4E               \ Set 6522 User VIA T1L-H timer 1 high-order latches
 STA SHEILA+&67         \ to &4E (so this sets the timer to &4E1E (19998) but
                        \ does not start counting until the current timer has
                        \ run down)

 LDA #HI(IRQHandler)    \ Set the IRQ1V vector to IRQHandler, so the IRQHandler
 STA IRQ1V+1            \ routine is now the interrupt handler
 LDA #LO(IRQHandler)
 STA IRQ1V

 CLI                    \ Re-enable interrupts

 JMP MainTitleLoop      \ Jump to MainTitleLoop to start the main title loop,
                        \  wherewe display the title screen, fetch the landscape
                        \ number and code, preview the landscape and then jump
                        \ to the main game loop

\ ******************************************************************************
\
\       Name: ClearMemory
\       Type: Subroutine
\   Category: Setup
\    Summary: Clear game memory, so that the BREAK key can remove all trace of
\             the game code in early versions of the operating system
\
\ ******************************************************************************

.ClearMemory

 LDA #&04               \ Set (Q P) = &0400
 STA Q                  \
 LDA #&00               \ We use this as the start address for clearing memory,
 STA P                  \ which is where the game code starts
                        \
                        \ This also sets A = 0, which we can use to zero memory

.cmem1

 LDY #&FF               \ Set Y = &FF to use as a byte counter

.cmem2

 STA (P),Y              \ Zero the Y-th byte at (Q P)

 DEY                    \ Decrement the byte counter

 BNE cmem2              \ Loop back until we have zeroed a whole page of memory

 INC Q                  \ Increment the high byte of (Q P) to point to the next
                        \ page in memory

 LDX Q                  \ Loop back until (Q P) reaches &7C00, at which point we
 CPX #&7C               \ have zeroed all the game code (including any code
 BCC cmem1              \ still left at the higher memory address where it's
                        \ first loaded)

 LDA #&00               \ Set the Break Intercept code to a BRK instruction to
 STA BRKIV              \ reinstate the default break handler

 RTS                    \ Return from the subroutine

 EQUB &20, &65, &74, &73, &36, &0D, &12, &CA    \ These bytes are unused until
 EQUB &19, &20, &20, &20, &20, &20, &20, &4C    \ the game is in progress, at
 EQUB &44, &58, &23, &36, &3A, &4A, &53, &52    \ which point this whole section
 EQUB &20, &43, &46, &4C, &53, &48, &0D, &12    \ of memory is reused
 EQUB &D4, &05, &20, &0D, &12, &DE, &0D, &2E    \
 EQUB &65, &74, &73, &36, &20, &72, &74, &73    \ The initial content is just
 EQUB &0D, &12, &E8, &05, &20, &0D, &12, &F2    \ workspace noise and is ignored
 EQUB &05, &20, &0D, &12, &FC, &05, &20, &0D    \
 EQUB &13, &06, &05, &20, &0D, &13, &10, &05    \ It actually contains snippets
 EQUB &20, &0D, &13, &1A, &05, &20, &0D, &13    \ of the original source code
 EQUB &24, &05, &20, &0D, &13, &2E, &2A, &2E
 EQUB &4D, &49, &4E, &49, &20, &4C, &44, &41
 EQUB &23, &31, &32, &38, &3A, &53, &54, &41
 EQUB &20, &4D, &45, &41, &4E, &59, &2C, &58
 EQUB &3A, &53, &54, &41, &20, &4D, &45, &4D
 EQUB &4F, &52, &59, &2C, &58, &0D, &13, &38
 EQUB &1F, &20, &20, &20, &20, &20, &20, &4C
 EQUB &44, &41, &23, &30, &3A, &53, &54, &41
 EQUB &20, &4D, &45, &41, &4E, &59, &53, &43
 EQUB &41, &4E, &2C, &58, &0D, &13, &42, &22
 EQUB &20, &20, &20, &20, &20, &20, &4C, &44
 EQUB &41, &23, &36, &34, &3A, &53, &54, &41
 EQUB &20, &4D, &54, &52, &59, &43, &4E, &54
 EQUB &2C, &58, &3A, &72, &74, &73, &0D, &13
 EQUB &4C, &05, &20, &0D, &13, &56, &1A, &2E
 EQUB &4D, &45, &41, &4E, &20, &4C, &44, &41
 EQUB &23, &34, &30, &3A, &53, &54, &41, &20
 EQUB &43, &4F, &56, &45, &52, &0D, &13, &60
 EQUB &1B, &20, &20, &20, &20, &20, &20, &4C
 EQUB &44, &58, &20, &45, &54, &45, &4D, &3A
 EQUB &53, &54, &58, &20, &58, &54

\ ******************************************************************************
\
\       Name: Entry
\       Type: Subroutine
\   Category: Setup
\    Summary: The main entry point for the game
\
\ ******************************************************************************

 ORG &6D00              \ Set the assembly address to &6D00

.Entry

                        \ We start by copying the game code in memory as
                        \ follows:
                        \
                        \   * &1900-&6CFF is copied to &0400-&57FF
                        \
                        \ The game binary has a load address of &1900 and an
                        \ execution address of &6D00 (the address of this
                        \ routine)

 LDA #&00               \ Set (Q P) = &1900
 STA P                  \
 STA R                  \ We use this as the source address for the copy
 LDA #&19
 STA Q

 LDA #&04               \ Set (S R) = &0400
 STA S                  \
                        \ We use this as the destination address for the copy

.entr1

 LDY #0                 \ Set up a byte counter in Y

.entr2

 LDA (P),Y              \ Copy the Y-th byte of (Q P) to the Y-th byte of (S R)
 STA (R),Y

 INY                    \ Increment the byte counter

 BNE entr2              \ Loop back until we have copied a whole page of bytes

 INC Q                  \ Increment the high byte of (Q P) to point to the next
                        \ page in memory

 INC S                  \ Increment the high byte of (S R) to point to the next
                        \ page in memory

 LDA Q                  \ Loop back until (Q P) reaches &6D00, at which point we
 CMP #&6D               \ have copied all the game code
 BNE entr1

 JMP ConfigureMachine   \ Jump to ConfigureMachine to configure the computer,
                        \ ready for a new game

\ ******************************************************************************
\
\ Save Sentinel.bin
\
\ ******************************************************************************

                               \ Game addr to file addr
 COPYBLOCK &4900, &4A00, &6000 \ 4900-49FF to 6000-60FF
 COPYBLOCK &5800, &6100, &4100 \ 5800-60FF to 4100-49FF
 COPYBLOCK &0400, &5800, LOAD% \ 0400-57FF to 1900-6CFF

 SAVE "3-assembled-output/TheSentinel.bin", LOAD%, P%
